diff --git a/autoware.ai/src/autoware/core_perception/points_downsampler/nodes/voxel_grid_filter/voxel_grid_filter.cpp b/autoware.ai/src/autoware/core_perception/points_downsampler/nodes/voxel_grid_filter/voxel_grid_filter.cpp
index 2aa58dfa..6958f845 100644
--- a/autoware.ai/src/autoware/core_perception/points_downsampler/nodes/voxel_grid_filter/voxel_grid_filter.cpp
+++ b/autoware.ai/src/autoware/core_perception/points_downsampler/nodes/voxel_grid_filter/voxel_grid_filter.cpp
@@ -62,7 +62,7 @@ static void config_callback(const autoware_config_msgs::ConfigVoxelGridFilter::C
 }
 
 inline static void publish_filtered_cloud(const sensor_msgs::PointCloud2::ConstPtr& input)
-{
+{  
   pcl::PointCloud<pcl::PointXYZI> scan;
   pcl::fromROSMsg(*input, scan);
 
@@ -97,12 +97,10 @@ inline static void publish_filtered_cloud(const sensor_msgs::PointCloud2::ConstP
   filtered_msg.header = input->header;
   filtered_points_pub.publish(filtered_msg);
 
-  if(rubis::instance_mode_ && rubis::instance_ != RUBIS_NO_INSTANCE){
-    rubis_msgs::PointCloud2 rubis_filtered_msg;
-    rubis_filtered_msg.msg = filtered_msg;
-    rubis_filtered_msg.instance = rubis::instance_;
-    rubis_filtered_points_pub.publish(rubis_filtered_msg);
-  }
+  rubis_msgs::PointCloud2 rubis_filtered_msg;
+  rubis_filtered_msg.msg = filtered_msg;
+  rubis_filtered_msg.instance = rubis::instance_;
+  rubis_filtered_points_pub.publish(rubis_filtered_msg);
 
   points_downsampler_info_msg.header = input->header;
   points_downsampler_info_msg.filter_name = "voxel_grid_filter";
@@ -137,22 +135,24 @@ inline static void publish_filtered_cloud(const sensor_msgs::PointCloud2::ConstP
       << points_downsampler_info_msg.exe_time << ","
       << std::endl;
   }
-
-  if(rubis::sched::is_task_ready_ == TASK_NOT_READY) rubis::sched::init_task();
-  rubis::sched::task_state_ = TASK_STATE_DONE;
+  
 }
 
 static void scan_callback(const sensor_msgs::PointCloud2::ConstPtr& input)
 {
-  rubis::instance_ = RUBIS_NO_INSTANCE;
+  rubis::instance_ = 0;
   publish_filtered_cloud(input);
 }
 
 static void rubis_scan_callback(const rubis_msgs::PointCloud2::ConstPtr& _input)
 {
+  rubis::start_task_profiling();
+
   sensor_msgs::PointCloud2::ConstPtr input = boost::make_shared<const sensor_msgs::PointCloud2>(_input->msg);
   rubis::instance_ = _input->instance;
   publish_filtered_cloud(input);
+
+  rubis::stop_task_profiling(rubis::instance_, 0);
 }
 
 int main(int argc, char** argv)
@@ -162,15 +162,6 @@ int main(int argc, char** argv)
   ros::NodeHandle nh;
   ros::NodeHandle private_nh("~");
 
-  // Scheduling Setup
-  int task_scheduling_flag;
-  int task_profiling_flag;
-  std::string task_response_time_filename;
-  int rate;
-  double task_minimum_inter_release_time;
-  double task_execution_time;
-  double task_relative_deadline; 
-
   private_nh.param<std::string>("input_topic_name", input_topic_name_, std::string("points_raw"));
   private_nh.param<std::string>("output_topic_name", output_topic_name_, std::string("filtered_points"));
   private_nh.getParam("output_log", _output_log);
@@ -185,23 +176,32 @@ int main(int argc, char** argv)
   private_nh.param<double>("measurement_range", measurement_range, MAX_MEASUREMENT_RANGE);
   private_nh.param<double>("leaf_size", voxel_leaf_size, 0.1);
 
+  // Scheduling & Profiling Setup
   std::string node_name = ros::this_node::getName();
-  private_nh.param<int>(node_name+"/task_scheduling_flag", task_scheduling_flag, 0);
-  private_nh.param<int>(node_name+"/task_profiling_flag", task_profiling_flag, 0);
-  private_nh.param<std::string>(node_name+"/task_response_time_filename", task_response_time_filename, "~/Documents/profiling/response_time/voxel_grid_filter.csv");
+  std::string task_response_time_filename;
+  private_nh.param<std::string>(node_name+"/task_response_time_filename", task_response_time_filename, "~/Documents/profiling/response_time/voexl_grid_filter.csv");
+
+  int rate;
   private_nh.param<int>(node_name+"/rate", rate, 10);
-  private_nh.param(node_name+"/task_minimum_inter_release_time", task_minimum_inter_release_time, (double)10);
-  private_nh.param(node_name+"/task_execution_time", task_execution_time, (double)10);
-  private_nh.param(node_name+"/task_relative_deadline", task_relative_deadline, (double)10);
-  private_nh.param<int>(node_name+"/instance_mode", rubis::instance_mode_, 0);
 
-  /* For Task scheduling */
-  if(task_profiling_flag) rubis::sched::init_task_profiling(task_response_time_filename);
+  struct rubis::sched_attr attr;
+  std::string policy;
+  int priority, exec_time ,deadline, period;
+    
+  private_nh.param(node_name+"/task_scheduling_configs/policy", policy, std::string("NONE"));    
+  private_nh.param(node_name+"/task_scheduling_configs/priority", priority, 99);
+  private_nh.param(node_name+"/task_scheduling_configs/exec_time", exec_time, 0);
+  private_nh.param(node_name+"/task_scheduling_configs/deadline", deadline, 0);
+  private_nh.param(node_name+"/task_scheduling_configs/period", period, 0);
+  attr = rubis::create_sched_attr(priority, exec_time, deadline, period);    
+  rubis::init_task_scheduling(policy, attr);
+
+  rubis::init_task_profiling(task_response_time_filename);
+
 
   // Publishers
   filtered_points_pub = nh.advertise<sensor_msgs::PointCloud2>(output_topic_name_, 10);
-  if(rubis::instance_mode_)
-    rubis_filtered_points_pub = nh.advertise<rubis_msgs::PointCloud2>("/rubis_" + output_topic_name_, 10);
+  rubis_filtered_points_pub = nh.advertise<rubis_msgs::PointCloud2>("/rubis_" + output_topic_name_, 10);
   points_downsampler_info_pub = nh.advertise<points_downsampler::PointsDownsamplerInfo>("/points_downsampler_info", 1000);
 
   // Subscribers
@@ -209,47 +209,9 @@ int main(int argc, char** argv)
   // ros::Subscriber scan_sub = nh.subscribe(input_topic_name_, 10, scan_callback);
   ros::Subscriber scan_sub;
   
-  if(rubis::instance_mode_) scan_sub = nh.subscribe("/rubis_"+input_topic_name_, 10, rubis_scan_callback);
-  else scan_sub = nh.subscribe(input_topic_name_, 10, scan_callback);
-
-  /*  RT Scheduling setup  */
-  // ros::Subscriber config_sub = nh.subscribe("config/voxel_grid_filter", 1, config_callback); // origin 10
-  // ros::Subscriber scan_sub = nh.subscribe(input_topic_name_, 1, scan_callback); // origin 10
-
-  if(!task_scheduling_flag && !task_profiling_flag){
-    ros::spin();
-  }
-  else{
-    ros::Rate r(rate);
-    // Initialize task ( Wait until first necessary topic is published )
-    while(ros::ok()){
-      if(rubis::sched::is_task_ready_ == TASK_READY) break;
-      ros::spinOnce();
-      r.sleep();      
-    }
-
-    // Executing task
-    while(ros::ok()){
-      if(task_profiling_flag) rubis::sched::start_task_profiling();
-      if(rubis::sched::task_state_ == TASK_STATE_READY){        
-        if(task_scheduling_flag) rubis::sched::request_task_scheduling(task_minimum_inter_release_time, task_execution_time, task_relative_deadline); 
-        rubis::sched::task_state_ = TASK_STATE_RUNNING;     
-      }
-
-      ros::spinOnce();
-
-      if(task_profiling_flag) rubis::sched::stop_task_profiling(rubis::instance_, rubis::sched::task_state_);
-      if(rubis::sched::task_state_ == TASK_STATE_DONE){        
-        if(task_scheduling_flag) rubis::sched::yield_task_scheduling();        
-        rubis::sched::task_state_ = TASK_STATE_READY;
-      }
-      
-      r.sleep();
-    }
-  }
+  scan_sub = nh.subscribe("/rubis_"+input_topic_name_, 1, rubis_scan_callback); // Def: 10
 
-  if(rubis::sched::is_task_ready_ == TASK_NOT_READY) rubis::sched::init_task();
-  rubis::sched::task_state_ = TASK_STATE_DONE;
+  ros::spin();
 
   return 0;
 }
diff --git a/autoware.ai/src/autoware/core_perception/points_downsampler/nodes/voxel_grid_filter/voxel_grid_filter.origin.cpp b/autoware.ai/src/autoware/core_perception/points_downsampler/nodes/voxel_grid_filter/voxel_grid_filter.origin.cpp
new file mode 100644
index 00000000..b931fd74
--- /dev/null
+++ b/autoware.ai/src/autoware/core_perception/points_downsampler/nodes/voxel_grid_filter/voxel_grid_filter.origin.cpp
@@ -0,0 +1,211 @@
+/*
+ * Copyright 2015-2019 Autoware Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <ros/ros.h>
+#include <sensor_msgs/PointCloud2.h>
+
+#include <pcl/point_types.h>
+#include <pcl_conversions/pcl_conversions.h>
+#include <pcl/filters/voxel_grid.h>
+
+#include "autoware_config_msgs/ConfigVoxelGridFilter.h"
+
+#include <points_downsampler/PointsDownsamplerInfo.h>
+
+#include <chrono>
+
+#include "points_downsampler.h"
+
+#include <rubis_lib/sched.hpp>
+#include <rubis_msgs/PointCloud2.h>
+
+#define SPIN_PROFILING
+
+#define MAX_MEASUREMENT_RANGE 200.0
+
+ros::Publisher filtered_points_pub;
+ros::Publisher rubis_filtered_points_pub;
+
+// Leaf size of VoxelGrid filter.
+static double voxel_leaf_size = 2.0;
+
+static ros::Publisher points_downsampler_info_pub;
+static points_downsampler::PointsDownsamplerInfo points_downsampler_info_msg;
+
+static std::chrono::time_point<std::chrono::system_clock> filter_start, filter_end;
+
+static bool _output_log = false;
+static std::ofstream ofs;
+static std::string filename;
+
+static std::string input_topic_name_;
+static std::string output_topic_name_;
+static double measurement_range = MAX_MEASUREMENT_RANGE;
+
+static void config_callback(const autoware_config_msgs::ConfigVoxelGridFilter::ConstPtr& input)
+{
+  voxel_leaf_size = input->voxel_leaf_size;
+  measurement_range = input->measurement_range;
+}
+
+inline static void publish_filtered_cloud(const sensor_msgs::PointCloud2::ConstPtr& input)
+{  
+  pcl::PointCloud<pcl::PointXYZI> scan;
+  pcl::fromROSMsg(*input, scan);
+
+  if(measurement_range != MAX_MEASUREMENT_RANGE){
+    scan = removePointsByRange(scan, 0, measurement_range);
+  }
+
+  pcl::PointCloud<pcl::PointXYZI>::Ptr scan_ptr(new pcl::PointCloud<pcl::PointXYZI>(scan));
+  pcl::PointCloud<pcl::PointXYZI>::Ptr filtered_scan_ptr(new pcl::PointCloud<pcl::PointXYZI>());
+
+  sensor_msgs::PointCloud2 filtered_msg;
+
+  filter_start = std::chrono::system_clock::now();
+
+  // if voxel_leaf_size < 0.1 voxel_grid_filter cannot down sample (It is specification in PCL)
+  if (voxel_leaf_size >= 0.1)
+  {
+    // Downsampling the velodyne scan using VoxelGrid filter
+    pcl::VoxelGrid<pcl::PointXYZI> voxel_grid_filter;
+    voxel_grid_filter.setLeafSize(voxel_leaf_size, voxel_leaf_size, voxel_leaf_size);
+    voxel_grid_filter.setInputCloud(scan_ptr);
+    voxel_grid_filter.filter(*filtered_scan_ptr);
+    pcl::toROSMsg(*filtered_scan_ptr, filtered_msg);
+  }
+  else
+  {
+    pcl::toROSMsg(*scan_ptr, filtered_msg);
+  }
+
+  filter_end = std::chrono::system_clock::now();
+
+  filtered_msg.header = input->header;
+  filtered_points_pub.publish(filtered_msg);
+
+  rubis_msgs::PointCloud2 rubis_filtered_msg;
+  rubis_filtered_msg.msg = filtered_msg;
+  rubis_filtered_msg.instance = rubis::instance_;
+  rubis_filtered_points_pub.publish(rubis_filtered_msg);
+
+  points_downsampler_info_msg.header = input->header;
+  points_downsampler_info_msg.filter_name = "voxel_grid_filter";
+  points_downsampler_info_msg.measurement_range = measurement_range;
+  points_downsampler_info_msg.original_points_size = scan.size();
+  if (voxel_leaf_size >= 0.1)
+  {
+    points_downsampler_info_msg.filtered_points_size = filtered_scan_ptr->size();
+  }
+  else
+  {
+    points_downsampler_info_msg.filtered_points_size = scan_ptr->size();
+  }
+  points_downsampler_info_msg.original_ring_size = 0;
+  points_downsampler_info_msg.filtered_ring_size = 0;
+  points_downsampler_info_msg.exe_time = std::chrono::duration_cast<std::chrono::microseconds>(filter_end - filter_start).count() / 1000.0;
+  points_downsampler_info_pub.publish(points_downsampler_info_msg);
+
+  if(_output_log == true){
+    if(!ofs){
+      std::cerr << "Could not open " << filename << "." << std::endl;
+      exit(1);
+    }
+    ofs << points_downsampler_info_msg.header.seq << ","
+      << points_downsampler_info_msg.header.stamp << ","
+      << points_downsampler_info_msg.header.frame_id << ","
+      << points_downsampler_info_msg.filter_name << ","
+      << points_downsampler_info_msg.original_points_size << ","
+      << points_downsampler_info_msg.filtered_points_size << ","
+      << points_downsampler_info_msg.original_ring_size << ","
+      << points_downsampler_info_msg.filtered_ring_size << ","
+      << points_downsampler_info_msg.exe_time << ","
+      << std::endl;
+  }
+  
+}
+
+static void scan_callback(const sensor_msgs::PointCloud2::ConstPtr& input)
+{
+  rubis::instance_ = 0;
+  publish_filtered_cloud(input);
+}
+
+static void rubis_scan_callback(const rubis_msgs::PointCloud2::ConstPtr& _input)
+{
+  rubis::start_task_profiling();
+
+  sensor_msgs::PointCloud2::ConstPtr input = boost::make_shared<const sensor_msgs::PointCloud2>(_input->msg);
+  rubis::instance_ = _input->instance;
+  publish_filtered_cloud(input);
+
+  rubis::stop_task_profiling(rubis::instance_, 0);
+}
+
+int main(int argc, char** argv)
+{
+  ros::init(argc, argv, "rubis_voxel_grid_filter");
+
+  ros::NodeHandle nh;
+  ros::NodeHandle private_nh("~");
+
+  // Scheduling Setup
+  std::string task_response_time_filename;
+  int rate;
+  double task_minimum_inter_release_time;
+  double task_execution_time;
+  double task_relative_deadline; 
+
+  private_nh.param<std::string>("input_topic_name", input_topic_name_, std::string("points_raw"));
+  private_nh.param<std::string>("output_topic_name", output_topic_name_, std::string("filtered_points"));
+  private_nh.getParam("output_log", _output_log);
+  if(_output_log == true){
+    char buffer[80];
+    std::time_t now = std::time(NULL);
+    std::tm *pnow = std::localtime(&now);
+    std::strftime(buffer,80,"%Y%m%d_%H%M%S",pnow);
+    filename = "voxel_grid_filter_" + std::string(buffer) + ".csv";
+    ofs.open(filename.c_str(), std::ios::app);
+  }
+  private_nh.param<double>("measurement_range", measurement_range, MAX_MEASUREMENT_RANGE);
+  private_nh.param<double>("leaf_size", voxel_leaf_size, 0.1);
+
+  std::string node_name = ros::this_node::getName();
+  private_nh.param<std::string>(node_name+"/task_response_time_filename", task_response_time_filename, "~/Documents/profiling/response_time/voxel_grid_filter.csv");
+  private_nh.param<int>(node_name+"/rate", rate, 10);
+  private_nh.param(node_name+"/task_minimum_inter_release_time", task_minimum_inter_release_time, (double)10);
+  private_nh.param(node_name+"/task_execution_time", task_execution_time, (double)10);
+  private_nh.param(node_name+"/task_relative_deadline", task_relative_deadline, (double)10);
+
+  /* For Task scheduling */
+  rubis::init_task_profiling(task_response_time_filename);
+
+  // Publishers
+  filtered_points_pub = nh.advertise<sensor_msgs::PointCloud2>(output_topic_name_, 10);
+  rubis_filtered_points_pub = nh.advertise<rubis_msgs::PointCloud2>("/rubis_" + output_topic_name_, 10);
+  points_downsampler_info_pub = nh.advertise<points_downsampler::PointsDownsamplerInfo>("/points_downsampler_info", 1000);
+
+  // Subscribers
+  ros::Subscriber config_sub = nh.subscribe("config/voxel_grid_filter", 10, config_callback);
+  // ros::Subscriber scan_sub = nh.subscribe(input_topic_name_, 10, scan_callback);
+  ros::Subscriber scan_sub;
+  
+  scan_sub = nh.subscribe("/rubis_"+input_topic_name_, 10, rubis_scan_callback);
+
+  ros::spin();
+
+  return 0;
+}
diff --git a/autoware.ai/src/autoware/core_perception/points_preprocessor/include/points_preprocessor/ray_ground_filter/ray_ground_filter.h b/autoware.ai/src/autoware/core_perception/points_preprocessor/include/points_preprocessor/ray_ground_filter/ray_ground_filter.h
index 18298682..5551e95e 100644
--- a/autoware.ai/src/autoware/core_perception/points_preprocessor/include/points_preprocessor/ray_ground_filter/ray_ground_filter.h
+++ b/autoware.ai/src/autoware/core_perception/points_preprocessor/include/points_preprocessor/ray_ground_filter/ray_ground_filter.h
@@ -78,8 +78,6 @@ private:
   std::vector<cv::Scalar> colors_;
   const size_t color_num_ = 60;  // different number of color to generate
 
-  int instance_mode_ = 0;
-
   struct PointXYZIRTColor
   {
     pcl::PointXYZI point;
diff --git a/autoware.ai/src/autoware/core_perception/points_preprocessor/launch/ray_ground_filter.launch b/autoware.ai/src/autoware/core_perception/points_preprocessor/launch/ray_ground_filter.launch
index d4fcb70e..5418c56f 100755
--- a/autoware.ai/src/autoware/core_perception/points_preprocessor/launch/ray_ground_filter.launch
+++ b/autoware.ai/src/autoware/core_perception/points_preprocessor/launch/ray_ground_filter.launch
@@ -14,7 +14,6 @@
   <arg name="reclass_distance_threshold" default="0.2" />  <!-- Distance between points at which re classification will occur (default 0.2 meters)-->
   <arg name="no_ground_point_topic" default="/points_no_ground" />
   <arg name="ground_point_topic" default="/points_ground" />
-  <arg name="instance_mode" default="0" />
 
   <!-- rosrun points_preprocessor ray_ground_filter -->
   <node pkg="points_preprocessor" type="ray_ground_filter" name="ray_ground_filter_$(arg label)" output="log">
@@ -31,6 +30,5 @@
     <param name="reclass_distance_threshold" value="$(arg reclass_distance_threshold)" />
     <param name="no_ground_point_topic" value="$(arg no_ground_point_topic)_$(arg label)" />
     <param name="ground_point_topic" value="$(arg ground_point_topic)_$(arg label)" />
-    <param name="instance_mode" value="$(arg instance_mode)" />
   </node>
 </launch>
diff --git a/autoware.ai/src/autoware/core_perception/points_preprocessor/launch/ray_ground_filter_params.launch b/autoware.ai/src/autoware/core_perception/points_preprocessor/launch/ray_ground_filter_params.launch
index 25fbed0c..eb60b4a3 100755
--- a/autoware.ai/src/autoware/core_perception/points_preprocessor/launch/ray_ground_filter_params.launch
+++ b/autoware.ai/src/autoware/core_perception/points_preprocessor/launch/ray_ground_filter_params.launch
@@ -14,7 +14,6 @@
   <arg name="reclass_distance_threshold" default="0.2" />  <!-- Distance between points at which re classification will occur (default 0.2 meters)-->
   <arg name="no_ground_point_topic" default="/points_no_ground" />
   <arg name="ground_point_topic" default="/points_ground" />
-  <!-- <arg name="instance_mode" default="0" /> -->
 
   <!-- rosrun points_preprocessor ray_ground_filter -->
   <node pkg="points_preprocessor" type="ray_ground_filter" name="ray_ground_filter_$(arg label)" output="screen">
@@ -31,6 +30,5 @@
     <param name="reclass_distance_threshold" value="$(arg reclass_distance_threshold)" />
     <param name="no_ground_point_topic" value="$(arg no_ground_point_topic)_$(arg label)" />
     <param name="ground_point_topic" value="$(arg ground_point_topic)_$(arg label)" />
-    <!-- <param name="instance_mode" value="$(arg instance_mode)" /> -->
   </node>
 </launch>
diff --git a/autoware.ai/src/autoware/core_perception/points_preprocessor/nodes/compare_map_filter/compare_map_filter.cpp b/autoware.ai/src/autoware/core_perception/points_preprocessor/nodes/compare_map_filter/compare_map_filter.cpp
index 92454425..d205d30f 100644
--- a/autoware.ai/src/autoware/core_perception/points_preprocessor/nodes/compare_map_filter/compare_map_filter.cpp
+++ b/autoware.ai/src/autoware/core_perception/points_preprocessor/nodes/compare_map_filter/compare_map_filter.cpp
@@ -221,8 +221,7 @@ void CompareMapFilter::sensorPointsCallback(const sensor_msgs::PointCloud2::Cons
     return;
   }
   unmatch_points_pub_.publish(sensorTF_unmatch_cloud_msg);
-  if(rubis::sched::is_task_ready_ == TASK_NOT_READY) rubis::sched::init_task();
-  rubis::sched::task_state_ = TASK_STATE_DONE;
+  
 }
 
 void CompareMapFilter::searchMatchingCloud(const pcl::PointCloud<pcl::PointXYZI>::Ptr in_cloud_ptr,
diff --git a/autoware.ai/src/autoware/core_perception/points_preprocessor/nodes/ray_ground_filter/ray_ground_filter.cpp b/autoware.ai/src/autoware/core_perception/points_preprocessor/nodes/ray_ground_filter/ray_ground_filter.cpp
index 005e14fb..e5b8bdca 100644
--- a/autoware.ai/src/autoware/core_perception/points_preprocessor/nodes/ray_ground_filter/ray_ground_filter.cpp
+++ b/autoware.ai/src/autoware/core_perception/points_preprocessor/nodes/ray_ground_filter/ray_ground_filter.cpp
@@ -379,8 +379,6 @@ inline void RayGroundFilter::PublishFilteredClouds(const sensor_msgs::PointCloud
   publish_cloud(ground_points_pub_, ground_cloud_ptr, in_sensor_cloud->header);
   publish_cloud(groundless_points_pub_, no_ground_cloud_ptr, in_sensor_cloud->header);
 
-  if(rubis::sched::is_task_ready_ == TASK_NOT_READY) rubis::sched::init_task();
-  rubis::sched::task_state_ = TASK_STATE_DONE;
 }
 
 void RayGroundFilter::CloudCallback(const sensor_msgs::PointCloud2ConstPtr& in_sensor_cloud)
@@ -391,9 +389,11 @@ void RayGroundFilter::CloudCallback(const sensor_msgs::PointCloud2ConstPtr& in_s
 
 void RayGroundFilter::RubisCloudCallback(const rubis_msgs::PointCloud2ConstPtr in_rubis_cloud)
 {
+  rubis::start_task_profiling();
   sensor_msgs::PointCloud2ConstPtr in_sensor_cloud = boost::make_shared<const sensor_msgs::PointCloud2>(in_rubis_cloud->msg);
   rubis::instance_ = in_rubis_cloud->instance;
   PublishFilteredClouds(in_sensor_cloud);
+  rubis::stop_task_profiling(rubis::instance_, 0);
 }
 
 RayGroundFilter::RayGroundFilter() : node_handle_("~"), tf_listener_(tf_buffer_)
@@ -405,15 +405,6 @@ RayGroundFilter::RayGroundFilter() : node_handle_("~"), tf_listener_(tf_buffer_)
 
 void RayGroundFilter::Run()
 {
-  // Scheduling Setup
-  int task_scheduling_flag;
-  int task_profiling_flag;
-  std::string task_response_time_filename;
-  int rate;
-  double task_minimum_inter_release_time;
-  double task_execution_time;
-  double task_relative_deadline;
-
   // Model   |   Horizontal   |   Vertical   | FOV(Vertical)    degrees / rads
   // ----------------------------------------------------------
   // HDL-64  |0.08-0.35(0.32) |     0.4      |  -24.9 <=x<=2.0   (26.9  / 0.47)
@@ -469,51 +460,31 @@ void RayGroundFilter::Run()
   groundless_points_pub_ = node_handle_.advertise<rubis_msgs::PointCloud2>(no_ground_topic, 2);
   ground_points_pub_ = node_handle_.advertise<sensor_msgs::PointCloud2>(ground_topic, 2);
   
+  // Scheduling & Profiling Setup
   std::string node_name = ros::this_node::getName();
-  node_handle_.param<int>(node_name+"/task_scheduling_flag", task_scheduling_flag, 0);
-  node_handle_.param<int>(node_name+"/task_profiling_flag", task_profiling_flag, 0);
+  std::string task_response_time_filename;
   node_handle_.param<std::string>(node_name+"/task_response_time_filename", task_response_time_filename, "~/Documents/profiling/response_time/ray_ground_filter.csv");
-  node_handle_.param<int>(node_name+"/rate", rate, 10);
-  node_handle_.param(node_name+"/task_minimum_inter_release_time", task_minimum_inter_release_time, (double)10);
-  node_handle_.param(node_name+"/task_execution_time", task_execution_time, (double)10);
-  node_handle_.param(node_name+"/task_relative_deadline", task_relative_deadline, (double)10);
-  node_handle_.param<int>(node_name+"/instance_mode", instance_mode_, 0);
 
-  points_node_sub_ = node_handle_.subscribe("/rubis_"+input_point_topic_.substr(1), 1, &RayGroundFilter::RubisCloudCallback, this);
-
-  ROS_INFO("Ready");
+  int rate;
+  node_handle_.param<int>(node_name+"/rate", rate, 10);
 
-  /* For Task scheduling */
-  if(task_profiling_flag) rubis::sched::init_task_profiling(task_response_time_filename);
+  struct rubis::sched_attr attr;
+  std::string policy;
+  int priority, exec_time ,deadline, period;
+    
+  node_handle_.param(node_name+"/task_scheduling_configs/policy", policy, std::string("NONE"));    
+  node_handle_.param(node_name+"/task_scheduling_configs/priority", priority, 99);
+  node_handle_.param(node_name+"/task_scheduling_configs/exec_time", exec_time, 0);
+  node_handle_.param(node_name+"/task_scheduling_configs/deadline", deadline, 0);
+  node_handle_.param(node_name+"/task_scheduling_configs/period", period, 0);
+  attr = rubis::create_sched_attr(priority, exec_time, deadline, period);    
+  rubis::init_task_scheduling(policy, attr);
 
-  if(!task_scheduling_flag && !task_profiling_flag){
-    ros::spin();
-  }
-  else{
-    ros::Rate r(rate);    
-    while(ros::ok()){
-      if(rubis::sched::is_task_ready_) break;
-      ros::spinOnce();
-      r.sleep();      
-    }
+  rubis::init_task_profiling(task_response_time_filename);
 
-    // Executing task
-    while(ros::ok()){
-      if(task_profiling_flag) rubis::sched::start_task_profiling();
-      if(rubis::sched::task_state_ == TASK_STATE_READY){        
-        if(task_scheduling_flag) rubis::sched::request_task_scheduling(task_minimum_inter_release_time, task_execution_time, task_relative_deadline); 
-        rubis::sched::task_state_ = TASK_STATE_RUNNING;     
-      }
+  points_node_sub_ = node_handle_.subscribe("/rubis_"+input_point_topic_.substr(1), 1, &RayGroundFilter::RubisCloudCallback, this);
 
-      ros::spinOnce();
+  ROS_INFO("Ready");
 
-      if(task_profiling_flag) rubis::sched::stop_task_profiling(rubis::instance_, rubis::sched::task_state_);
-      if(rubis::sched::task_state_ == TASK_STATE_DONE){
-        if(task_scheduling_flag) rubis::sched::yield_task_scheduling();
-        rubis::sched::task_state_ = TASK_STATE_READY;
-      }
-      
-      r.sleep();
-    }
-  }
+  ros::spin();
 }
diff --git a/autoware.ai/src/autoware/core_perception/range_vision_fusion/src/range_vision_fusion.cpp b/autoware.ai/src/autoware/core_perception/range_vision_fusion/src/range_vision_fusion.cpp
index 1ced3fe7..65943460 100644
--- a/autoware.ai/src/autoware/core_perception/range_vision_fusion/src/range_vision_fusion.cpp
+++ b/autoware.ai/src/autoware/core_perception/range_vision_fusion/src/range_vision_fusion.cpp
@@ -717,15 +717,13 @@ ROSRangeVisionFusionApp::Run()
   ros::NodeHandle private_node_handle("~");
 
   // Scheduling Setup
-  int task_scheduling_flag;
-  int task_profiling_flag;
   std::string task_response_time_filename;
   int rate;
   double task_minimum_inter_release_time;
   double task_execution_time;
   double task_relative_deadline;
 
-  if(task_profiling_flag) rubis::sched::init_task_profiling(task_response_time_filename);
+  rubis::init_task_profiling(task_response_time_filename);
   
   tf::TransformListener transform_listener;
 
diff --git a/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/activation_kernels.cu b/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/activation_kernels.cu
index c7f2ef0b..83a0a55f 100644
--- a/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/activation_kernels.cu
+++ b/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/activation_kernels.cu
@@ -156,10 +156,8 @@ __global__ void binary_gradient_array_kernel(float *x, float *dy, int n, int s,
 
 extern "C" void binary_gradient_array_gpu(float *x, float *dx, int n, int size, BINARY_ACTIVATION a, float *y) 
 {
-    request_gpu();
-    binary_gradient_array_kernel<<<cuda_gridsize(n/2), BLOCK>>>(x, dx, n/2, size, a, y);
-    yield_gpu_with_remark("binary_gradient_array_kernel");
-    check_error(cudaPeekAtLastError());
+        binary_gradient_array_kernel<<<cuda_gridsize(n/2), BLOCK>>>(x, dx, n/2, size, a, y);
+        check_error(cudaPeekAtLastError());
 }
 __global__ void binary_activate_array_kernel(float *x, int n, int s, BINARY_ACTIVATION a, float *y)
 {
@@ -173,9 +171,7 @@ __global__ void binary_activate_array_kernel(float *x, int n, int s, BINARY_ACTI
 
 extern "C" void binary_activate_array_gpu(float *x, int n, int size, BINARY_ACTIVATION a, float *y) 
 {
-    request_gpu();
-    binary_activate_array_kernel<<<cuda_gridsize(n/2), BLOCK>>>(x, n/2, size, a, y);
-    yield_gpu_with_remark("binary_activate_array_kernel");
+        binary_activate_array_kernel<<<cuda_gridsize(n/2), BLOCK>>>(x, n/2, size, a, y);
     check_error(cudaPeekAtLastError());
 }
 
@@ -193,16 +189,12 @@ __global__ void gradient_array_kernel(float *x, int n, ACTIVATION a, float *delt
 
 extern "C" void activate_array_gpu(float *x, int n, ACTIVATION a) 
 {
-    request_gpu();
-    activate_array_kernel<<<cuda_gridsize(n), BLOCK>>>(x, n, a);
-    yield_gpu_with_remark("activate_array_kernel");
+        activate_array_kernel<<<cuda_gridsize(n), BLOCK>>>(x, n, a);
     check_error(cudaPeekAtLastError());
 }
 
 extern "C" void gradient_array_gpu(float *x, int n, ACTIVATION a, float *delta) 
 {
-    request_gpu();
-    gradient_array_kernel<<<cuda_gridsize(n), BLOCK>>>(x, n, a, delta);
-    yield_gpu_with_remark("gradient_array_kernel");
+        gradient_array_kernel<<<cuda_gridsize(n), BLOCK>>>(x, n, a, delta);
     check_error(cudaPeekAtLastError());
 }
diff --git a/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/avgpool_layer_kernels.cu b/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/avgpool_layer_kernels.cu
index 5a0473bc..65a521a2 100644
--- a/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/avgpool_layer_kernels.cu
+++ b/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/avgpool_layer_kernels.cu
@@ -47,10 +47,7 @@ extern "C" void forward_avgpool_layer_gpu(avgpool_layer layer, network net)
 {
     size_t n = layer.c*layer.batch;
 
-    request_gpu();
-    forward_avgpool_layer_kernel<<<cuda_gridsize(n), BLOCK>>>(n, layer.w, layer.h, layer.c, net.input_gpu, layer.output_gpu);
-    yield_gpu_with_remark("forward_avgpool_layer_kernel");
-
+        forward_avgpool_layer_kernel<<<cuda_gridsize(n), BLOCK>>>(n, layer.w, layer.h, layer.c, net.input_gpu, layer.output_gpu);
     check_error(cudaPeekAtLastError());
 }
 
@@ -58,9 +55,7 @@ extern "C" void backward_avgpool_layer_gpu(avgpool_layer layer, network net)
 {
     size_t n = layer.c*layer.batch;
 
-    request_gpu();
-    backward_avgpool_layer_kernel<<<cuda_gridsize(n), BLOCK>>>(n, layer.w, layer.h, layer.c, net.delta_gpu, layer.delta_gpu);
-    yield_gpu_with_remark("forward_avgpool_layer_kernel");
+        backward_avgpool_layer_kernel<<<cuda_gridsize(n), BLOCK>>>(n, layer.w, layer.h, layer.c, net.delta_gpu, layer.delta_gpu);
 
     check_error(cudaPeekAtLastError());
 }
diff --git a/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/blas_kernels.cu b/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/blas_kernels.cu
index 95c61fd3..0ad326d9 100644
--- a/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/blas_kernels.cu
+++ b/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/blas_kernels.cu
@@ -23,9 +23,7 @@ void scale_bias_gpu(float *output, float *biases, int batch, int n, int size)
     dim3 dimGrid((size-1)/BLOCK + 1, n, batch);
     dim3 dimBlock(BLOCK, 1, 1);
 
-    request_gpu();
-    scale_bias_kernel<<<dimGrid, dimBlock>>>(output, biases, n, size);
-    yield_gpu_with_remark("scale_bias_kernel");
+        scale_bias_kernel<<<dimGrid, dimBlock>>>(output, biases, n, size);
 
     check_error(cudaPeekAtLastError());
 }
@@ -52,9 +50,7 @@ __global__ void backward_scale_kernel(float *x_norm, float *delta, int batch, in
 
 void backward_scale_gpu(float *x_norm, float *delta, int batch, int n, int size, float *scale_updates)
 {
-    request_gpu();
-    backward_scale_kernel<<<n, BLOCK>>>(x_norm, delta, batch, n, size, scale_updates);
-    yield_gpu_with_remark("backward_scale_kernel");
+        backward_scale_kernel<<<n, BLOCK>>>(x_norm, delta, batch, n, size, scale_updates);
     
     check_error(cudaPeekAtLastError());
 }
@@ -76,9 +72,7 @@ void add_bias_gpu(float *output, float *biases, int batch, int n, int size)
 {
     int num = n*size*batch;
 
-    request_gpu();
-    add_bias_kernel<<<cuda_gridsize(num), BLOCK>>>(output, biases, batch, n, size);
-    yield_gpu_with_remark("add_bias_kernel");
+        add_bias_kernel<<<cuda_gridsize(num), BLOCK>>>(output, biases, batch, n, size);
 
     check_error(cudaPeekAtLastError());
 }
@@ -119,13 +113,9 @@ __global__ void backward_bias_kernel(float *bias_updates, float *delta, int batc
 void backward_bias_gpu(float *bias_updates, float *delta, int batch, int n, int size)
 {
     if(size == 1){
-        request_gpu();
-        backward_bias_conn_kernel<<<cuda_gridsize(n), BLOCK>>>(bias_updates, delta, batch, n);
-        yield_gpu_with_remark("backward_bias_conn_kernel");
+                backward_bias_conn_kernel<<<cuda_gridsize(n), BLOCK>>>(bias_updates, delta, batch, n);
     }else{
-        request_gpu();
-        backward_bias_kernel<<<n, BLOCK>>>(bias_updates, delta, batch, n, size);
-        yield_gpu_with_remark("backward_bias_kernel");
+                backward_bias_kernel<<<n, BLOCK>>>(bias_updates, delta, batch, n, size);
     }
     check_error(cudaPeekAtLastError());
 }
@@ -186,9 +176,7 @@ __global__ void adam_kernel(int N, float *x, float *m, float *v, float B1, float
 
 extern "C" void adam_gpu(int n, float *x, float *m, float *v, float B1, float B2, float rate, float eps, int t)
 {
-    request_gpu();
-    adam_kernel<<<cuda_gridsize(n), BLOCK>>>(n, x, m, v, B1, B2, rate, eps, t);
-    yield_gpu_with_remark("adam_kernel");
+        adam_kernel<<<cuda_gridsize(n), BLOCK>>>(n, x, m, v, B1, B2, rate, eps, t);
     
     check_error(cudaPeekAtLastError());
 }
@@ -229,9 +217,7 @@ extern "C" void normalize_delta_gpu(float *x, float *mean, float *variance, floa
 {
     size_t N = batch*filters*spatial;
 
-    request_gpu();
-    normalize_delta_kernel<<<cuda_gridsize(N), BLOCK>>>(N, x, mean, variance, mean_delta, variance_delta, batch, filters, spatial, delta);
-    yield_gpu_with_remark("normalize_delta_kernel");
+        normalize_delta_kernel<<<cuda_gridsize(N), BLOCK>>>(N, x, mean, variance, mean_delta, variance_delta, batch, filters, spatial, delta);
 
     check_error(cudaPeekAtLastError());
 }
@@ -339,27 +325,21 @@ __global__ void mean_delta_kernel(float *delta, float *variance, int batch, int
 
 extern "C" void mean_delta_gpu(float *delta, float *variance, int batch, int filters, int spatial, float *mean_delta)
 {
-    request_gpu();
-    mean_delta_kernel<<<cuda_gridsize(filters), BLOCK>>>(delta, variance, batch, filters, spatial, mean_delta);
-    yield_gpu_with_remark("mean_delta_kernel");
+        mean_delta_kernel<<<cuda_gridsize(filters), BLOCK>>>(delta, variance, batch, filters, spatial, mean_delta);
 
     check_error(cudaPeekAtLastError());
 }
 
 extern "C" void fast_mean_delta_gpu(float *delta, float *variance, int batch, int filters, int spatial, float *mean_delta)
 {
-    request_gpu();
-    fast_mean_delta_kernel<<<filters, BLOCK>>>(delta, variance, batch, filters, spatial, mean_delta);
-    yield_gpu_with_remark("fast_mean_delta_kernel");
+        fast_mean_delta_kernel<<<filters, BLOCK>>>(delta, variance, batch, filters, spatial, mean_delta);
 
     check_error(cudaPeekAtLastError());
 }
 
 extern "C" void fast_variance_delta_gpu(float *x, float *delta, float *mean, float *variance, int batch, int filters, int spatial, float *variance_delta)
 {
-    request_gpu();
-    fast_variance_delta_kernel<<<filters, BLOCK>>>(x, delta, mean, variance, batch, filters, spatial, variance_delta);
-    yield_gpu_with_remark("fast_variance_delta_kernel");
+        fast_variance_delta_kernel<<<filters, BLOCK>>>(x, delta, mean, variance, batch, filters, spatial, variance_delta);
 
     check_error(cudaPeekAtLastError());
 }
@@ -495,9 +475,7 @@ extern "C" void normalize_gpu(float *x, float *mean, float *variance, int batch,
 {
     size_t N = batch*filters*spatial;
 
-    request_gpu();
-    normalize_kernel<<<cuda_gridsize(N), BLOCK>>>(N, x, mean, variance, batch, filters, spatial);
-    yield_gpu_with_remark("normalize_kernel");
+        normalize_kernel<<<cuda_gridsize(N), BLOCK>>>(N, x, mean, variance, batch, filters, spatial);
 
     check_error(cudaPeekAtLastError());
 }
@@ -528,9 +506,7 @@ extern "C" void l2normalize_gpu(float *x, float *dx, int batch, int filters, int
 {
     size_t N = batch*spatial;
 
-    request_gpu();
-    l2norm_kernel<<<cuda_gridsize(N), BLOCK>>>(N, x, dx, batch, filters, spatial);
-    yield_gpu_with_remark("l2norm_kernel");
+        l2norm_kernel<<<cuda_gridsize(N), BLOCK>>>(N, x, dx, batch, filters, spatial);
 
     check_error(cudaPeekAtLastError());
 }
@@ -596,18 +572,14 @@ __global__ void  fast_variance_kernel(float *x, float *mean, int batch, int filt
 
 extern "C" void fast_mean_gpu(float *x, int batch, int filters, int spatial, float *mean)
 {
-    request_gpu();
-    fast_mean_kernel<<<filters, BLOCK>>>(x, batch, filters, spatial, mean);
-    yield_gpu_with_remark("fast_mean_kernel");
+        fast_mean_kernel<<<filters, BLOCK>>>(x, batch, filters, spatial, mean);
     
     check_error(cudaPeekAtLastError());
 }
 
 extern "C" void fast_variance_gpu(float *x, float *mean, int batch, int filters, int spatial, float *variance)
 {
-    request_gpu();
-    fast_variance_kernel<<<filters, BLOCK>>>(x, mean, batch, filters, spatial, variance);
-    yield_gpu_with_remark("fast_mean_kernel");
+        fast_variance_kernel<<<filters, BLOCK>>>(x, mean, batch, filters, spatial, variance);
 
     check_error(cudaPeekAtLastError());
 }
@@ -615,18 +587,14 @@ extern "C" void fast_variance_gpu(float *x, float *mean, int batch, int filters,
 
 extern "C" void mean_gpu(float *x, int batch, int filters, int spatial, float *mean)
 {
-    request_gpu();
-    mean_kernel<<<cuda_gridsize(filters), BLOCK>>>(x, batch, filters, spatial, mean);
-    yield_gpu_with_remark("mean_kernel");
+        mean_kernel<<<cuda_gridsize(filters), BLOCK>>>(x, batch, filters, spatial, mean);
 
     check_error(cudaPeekAtLastError());
 }
 
 extern "C" void variance_gpu(float *x, float *mean, int batch, int filters, int spatial, float *variance)
 {
-    request_gpu();
-    variance_kernel<<<cuda_gridsize(filters), BLOCK>>>(x, mean, batch, filters, spatial, variance);
-    yield_gpu_with_remark("variance_kernel");
+        variance_kernel<<<cuda_gridsize(filters), BLOCK>>>(x, mean, batch, filters, spatial, variance);
 
     check_error(cudaPeekAtLastError());
 }
@@ -638,18 +606,14 @@ extern "C" void axpy_gpu(int N, float ALPHA, float * X, int INCX, float * Y, int
 
 extern "C" void pow_gpu(int N, float ALPHA, float * X, int INCX, float * Y, int INCY)
 {
-    request_gpu();
-    pow_kernel<<<cuda_gridsize(N), BLOCK>>>(N, ALPHA, X, INCX, Y, INCY);
-    yield_gpu_with_remark("pow_kernel");
+        pow_kernel<<<cuda_gridsize(N), BLOCK>>>(N, ALPHA, X, INCX, Y, INCY);
 
     check_error(cudaPeekAtLastError());
 }
 
 extern "C" void axpy_gpu_offset(int N, float ALPHA, float * X, int OFFX, int INCX, float * Y, int OFFY, int INCY)
 {
-    request_gpu();
-    axpy_kernel<<<cuda_gridsize(N), BLOCK>>>(N, ALPHA, X, OFFX, INCX, Y, OFFY, INCY);
-    yield_gpu_with_remark("pow_kernel");
+        axpy_kernel<<<cuda_gridsize(N), BLOCK>>>(N, ALPHA, X, OFFX, INCX, Y, OFFY, INCY);
 
     check_error(cudaPeekAtLastError());
 }
@@ -661,18 +625,14 @@ extern "C" void copy_gpu(int N, float * X, int INCX, float * Y, int INCY)
 
 extern "C" void mul_gpu(int N, float * X, int INCX, float * Y, int INCY)
 {
-    request_gpu();
-    mul_kernel<<<cuda_gridsize(N), BLOCK>>>(N, X, INCX, Y, INCY);
-    yield_gpu_with_remark("mul_kernel");
+        mul_kernel<<<cuda_gridsize(N), BLOCK>>>(N, X, INCX, Y, INCY);
 
     check_error(cudaPeekAtLastError());
 }
 
 extern "C" void copy_gpu_offset(int N, float * X, int OFFX, int INCX, float * Y, int OFFY, int INCY)
 {
-    request_gpu();
-    copy_kernel<<<cuda_gridsize(N), BLOCK>>>(N, X, OFFX, INCX, Y, OFFY, INCY);
-    yield_gpu_with_remark("copy_kernel");
+        copy_kernel<<<cuda_gridsize(N), BLOCK>>>(N, X, OFFX, INCX, Y, OFFY, INCY);
 
     check_error(cudaPeekAtLastError());
 }
@@ -698,9 +658,7 @@ extern "C" void flatten_gpu(float *x, int spatial, int layers, int batch, int fo
 {
     int size = spatial*batch*layers;
 
-    request_gpu();
-    flatten_kernel<<<cuda_gridsize(size), BLOCK>>>(size, x, spatial, layers, batch, forward, out);
-    yield_gpu_with_remark("flatten_kernel");
+        flatten_kernel<<<cuda_gridsize(size), BLOCK>>>(size, x, spatial, layers, batch, forward, out);
 
     check_error(cudaPeekAtLastError());
 }
@@ -709,9 +667,7 @@ extern "C" void reorg_gpu(float *x, int w, int h, int c, int batch, int stride,
 {
     int size = w*h*c*batch;
 
-    request_gpu();
-    reorg_kernel<<<cuda_gridsize(size), BLOCK>>>(size, x, w, h, c, batch, stride, forward, out);
-    yield_gpu_with_remark("reorg_kernel");
+        reorg_kernel<<<cuda_gridsize(size), BLOCK>>>(size, x, w, h, c, batch, stride, forward, out);
 
     check_error(cudaPeekAtLastError());
 }
@@ -724,9 +680,7 @@ __global__ void mask_kernel(int n,  float *x, float mask_num, float *mask, float
 
 extern "C" void mask_gpu(int N, float * X, float mask_num, float * mask, float val)
 {
-    request_gpu();
-    mask_kernel<<<cuda_gridsize(N), BLOCK>>>(N, X, mask_num, mask, val);
-    yield_gpu_with_remark("mask_kernel");
+        mask_kernel<<<cuda_gridsize(N), BLOCK>>>(N, X, mask_num, mask, val);
 
     check_error(cudaPeekAtLastError());
 }
@@ -739,27 +693,21 @@ __global__ void scale_mask_kernel(int n,  float *x, float mask_num, float *mask,
 
 extern "C" void scale_mask_gpu(int N, float * X, float mask_num, float * mask, float scale)
 {
-    request_gpu();
-    scale_mask_kernel<<<cuda_gridsize(N), BLOCK>>>(N, X, mask_num, mask, scale);
-    yield_gpu_with_remark("scale_mask_kernel");
+        scale_mask_kernel<<<cuda_gridsize(N), BLOCK>>>(N, X, mask_num, mask, scale);
 
     check_error(cudaPeekAtLastError());
 }
 
 extern "C" void const_gpu(int N, float ALPHA, float * X, int INCX)
 {
-    request_gpu();
-    const_kernel<<<cuda_gridsize(N), BLOCK>>>(N, ALPHA, X, INCX);
-    yield_gpu_with_remark("const_kernel");
+        const_kernel<<<cuda_gridsize(N), BLOCK>>>(N, ALPHA, X, INCX);
 
     check_error(cudaPeekAtLastError());
 }
 
 extern "C" void constrain_gpu(int N, float ALPHA, float * X, int INCX)
 {
-    request_gpu();
-    constrain_kernel<<<cuda_gridsize(N), BLOCK>>>(N, ALPHA, X, INCX);
-    yield_gpu_with_remark("constrain_kernel");
+        constrain_kernel<<<cuda_gridsize(N), BLOCK>>>(N, ALPHA, X, INCX);
 
     check_error(cudaPeekAtLastError());
 }
@@ -767,36 +715,28 @@ extern "C" void constrain_gpu(int N, float ALPHA, float * X, int INCX)
 
 extern "C" void add_gpu(int N, float ALPHA, float * X, int INCX)
 {
-    request_gpu();
-    add_kernel<<<cuda_gridsize(N), BLOCK>>>(N, ALPHA, X, INCX);
-    yield_gpu_with_remark("add_kernel");
+        add_kernel<<<cuda_gridsize(N), BLOCK>>>(N, ALPHA, X, INCX);
 
     check_error(cudaPeekAtLastError());
 }
 
 extern "C" void scal_gpu(int N, float ALPHA, float * X, int INCX)
 {
-    request_gpu();
-    scal_kernel<<<cuda_gridsize(N), BLOCK>>>(N, ALPHA, X, INCX);
-    yield_gpu_with_remark("scal_kernel");
+        scal_kernel<<<cuda_gridsize(N), BLOCK>>>(N, ALPHA, X, INCX);
 
     check_error(cudaPeekAtLastError());
 }
 
 extern "C" void supp_gpu(int N, float ALPHA, float * X, int INCX)
 {
-    request_gpu();
-    supp_kernel<<<cuda_gridsize(N), BLOCK>>>(N, ALPHA, X, INCX);
-    yield_gpu_with_remark("supp_kernel");
+        supp_kernel<<<cuda_gridsize(N), BLOCK>>>(N, ALPHA, X, INCX);
 
     check_error(cudaPeekAtLastError());
 }
 
 extern "C" void fill_gpu(int N, float ALPHA, float * X, int INCX)
 {
-    request_gpu();
-    fill_kernel<<<cuda_gridsize(N), BLOCK>>>(N, ALPHA, X, INCX);
-    yield_gpu_with_remark("fill_kernel");
+        fill_kernel<<<cuda_gridsize(N), BLOCK>>>(N, ALPHA, X, INCX);
 
     check_error(cudaPeekAtLastError());
 }
@@ -834,9 +774,7 @@ extern "C" void shortcut_gpu(int batch, int w1, int h1, int c1, float *add, int
 
     int size = batch * minw * minh * minc;
     
-    request_gpu();
-    shortcut_kernel<<<cuda_gridsize(size), BLOCK>>>(size, minw, minh, minc, stride, sample, batch, w1, h1, c1, add, w2, h2, c2, s1, s2, out);
-    yield_gpu_with_remark("shortcut_kernel");
+        shortcut_kernel<<<cuda_gridsize(size), BLOCK>>>(size, minw, minh, minc, stride, sample, batch, w1, h1, c1, add, w2, h2, c2, s1, s2, out);
 
     check_error(cudaPeekAtLastError());
 }
@@ -860,9 +798,7 @@ __global__ void smooth_l1_kernel(int n, float *pred, float *truth, float *delta,
 
 extern "C" void smooth_l1_gpu(int n, float *pred, float *truth, float *delta, float *error)
 {
-    request_gpu();
-    smooth_l1_kernel<<<cuda_gridsize(n), BLOCK>>>(n, pred, truth, delta, error);
-    yield_gpu_with_remark("smooth_l1_kernel");
+        smooth_l1_kernel<<<cuda_gridsize(n), BLOCK>>>(n, pred, truth, delta, error);
 
     check_error(cudaPeekAtLastError());
 }
@@ -880,9 +816,7 @@ __global__ void softmax_x_ent_kernel(int n, float *pred, float *truth, float *de
 
 extern "C" void softmax_x_ent_gpu(int n, float *pred, float *truth, float *delta, float *error)
 {
-    request_gpu();
-    softmax_x_ent_kernel<<<cuda_gridsize(n), BLOCK>>>(n, pred, truth, delta, error);
-    yield_gpu_with_remark("softmax_x_ent_kernel");
+        softmax_x_ent_kernel<<<cuda_gridsize(n), BLOCK>>>(n, pred, truth, delta, error);
     
     check_error(cudaPeekAtLastError());
 }
@@ -900,9 +834,7 @@ __global__ void logistic_x_ent_kernel(int n, float *pred, float *truth, float *d
 
 extern "C" void logistic_x_ent_gpu(int n, float *pred, float *truth, float *delta, float *error)
 {
-    request_gpu();
-    logistic_x_ent_kernel<<<cuda_gridsize(n), BLOCK>>>(n, pred, truth, delta, error);
-    yield_gpu_with_remark("logistic_x_ent_kernel");
+        logistic_x_ent_kernel<<<cuda_gridsize(n), BLOCK>>>(n, pred, truth, delta, error);
 
     check_error(cudaPeekAtLastError());
 }
@@ -919,9 +851,7 @@ __global__ void l2_kernel(int n, float *pred, float *truth, float *delta, float
 
 extern "C" void l2_gpu(int n, float *pred, float *truth, float *delta, float *error)
 {
-    request_gpu();
-    l2_kernel<<<cuda_gridsize(n), BLOCK>>>(n, pred, truth, delta, error);
-    yield_gpu_with_remark("l2_kernel");
+        l2_kernel<<<cuda_gridsize(n), BLOCK>>>(n, pred, truth, delta, error);
 
     check_error(cudaPeekAtLastError());
 }
@@ -938,9 +868,7 @@ __global__ void l1_kernel(int n, float *pred, float *truth, float *delta, float
 
 extern "C" void l1_gpu(int n, float *pred, float *truth, float *delta, float *error)
 {
-    request_gpu();
-    l1_kernel<<<cuda_gridsize(n), BLOCK>>>(n, pred, truth, delta, error);
-    yield_gpu_with_remark("l1_kernel");
+        l1_kernel<<<cuda_gridsize(n), BLOCK>>>(n, pred, truth, delta, error);
 
     check_error(cudaPeekAtLastError());
 }
@@ -956,9 +884,7 @@ __global__ void wgan_kernel(int n, float *pred, float *truth, float *delta, floa
 
 extern "C" void wgan_gpu(int n, float *pred, float *truth, float *delta, float *error)
 {
-    request_gpu();
-    wgan_kernel<<<cuda_gridsize(n), BLOCK>>>(n, pred, truth, delta, error);
-    yield_gpu_with_remark("wgan_kernel");
+        wgan_kernel<<<cuda_gridsize(n), BLOCK>>>(n, pred, truth, delta, error);
 
     check_error(cudaPeekAtLastError());
 }
@@ -990,9 +916,7 @@ __global__ void deinter_kernel(int NX, float *X, int NY, float *Y, int B, float
 
 extern "C" void deinter_gpu(int NX, float *X, int NY, float *Y, int B, float *OUT)
 {
-    request_gpu();
-    deinter_kernel<<<cuda_gridsize((NX+NY)*B), BLOCK>>>(NX, X, NY, Y, B, OUT);
-    yield_gpu_with_remark("deinter_kernel");
+        deinter_kernel<<<cuda_gridsize((NX+NY)*B), BLOCK>>>(NX, X, NY, Y, B, OUT);
 
     check_error(cudaPeekAtLastError());
 }
@@ -1013,18 +937,14 @@ __global__ void inter_kernel(int NX, float *X, int NY, float *Y, int B, float *O
 
 extern "C" void inter_gpu(int NX, float *X, int NY, float *Y, int B, float *OUT)
 {
-    request_gpu();
-    inter_kernel<<<cuda_gridsize((NX+NY)*B), BLOCK>>>(NX, X, NY, Y, B, OUT);
-    yield_gpu_with_remark("inter_kernel");
+        inter_kernel<<<cuda_gridsize((NX+NY)*B), BLOCK>>>(NX, X, NY, Y, B, OUT);
 
     check_error(cudaPeekAtLastError());
 }
 
 extern "C" void weighted_sum_gpu(float *a, float *b, float *s, int num, float *c)
 {
-    request_gpu();
-    weighted_sum_kernel<<<cuda_gridsize(num), BLOCK>>>(num, a, b, s, c);
-    yield_gpu_with_remark("weighted_sum_kernel");
+        weighted_sum_kernel<<<cuda_gridsize(num), BLOCK>>>(num, a, b, s, c);
 
     check_error(cudaPeekAtLastError());
 }
@@ -1041,9 +961,7 @@ __global__ void weighted_delta_kernel(int n, float *a, float *b, float *s, float
 
 extern "C" void weighted_delta_gpu(float *a, float *b, float *s, float *da, float *db, float *ds, int num, float *dc)
 {
-    request_gpu();
-    weighted_delta_kernel<<<cuda_gridsize(num), BLOCK>>>(num, a, b, s, da, db, ds, dc);
-    yield_gpu_with_remark("weighted_delta_kernel");
+        weighted_delta_kernel<<<cuda_gridsize(num), BLOCK>>>(num, a, b, s, da, db, ds, dc);
 
     check_error(cudaPeekAtLastError());
 }
@@ -1058,9 +976,7 @@ __global__ void mult_add_into_kernel(int n, float *a, float *b, float *c)
 
 extern "C" void mult_add_into_gpu(int num, float *a, float *b, float *c)
 {
-    request_gpu();
-    mult_add_into_kernel<<<cuda_gridsize(num), BLOCK>>>(num, a, b, c);
-    yield_gpu_with_remark("mult_add_into_kernel");
+        mult_add_into_kernel<<<cuda_gridsize(num), BLOCK>>>(num, a, b, c);
 
     check_error(cudaPeekAtLastError());
 }
@@ -1113,9 +1029,7 @@ extern "C" void softmax_tree(float *input, int spatial, int batch, int stride, f
      */
     int num = spatial*batch*hier.groups;
 
-    request_gpu();
-    softmax_tree_kernel<<<cuda_gridsize(num), BLOCK>>>(input, spatial, batch, stride, temp, output, hier.groups, tree_groups_size, tree_groups_offset);
-    yield_gpu_with_remark("softmax_tree_kernel");
+        softmax_tree_kernel<<<cuda_gridsize(num), BLOCK>>>(input, spatial, batch, stride, temp, output, hier.groups, tree_groups_size, tree_groups_offset);
 
     check_error(cudaPeekAtLastError());
     cuda_free((float *)tree_groups_size);
@@ -1133,9 +1047,7 @@ __global__ void softmax_kernel(float *input, int n, int batch, int batch_offset,
 
 extern "C" void softmax_gpu(float *input, int n, int batch, int batch_offset, int groups, int group_offset, int stride, float temp, float *output)
 {
-    request_gpu();
-    softmax_kernel<<<cuda_gridsize(batch*groups), BLOCK>>>(input, n, batch, batch_offset, groups, group_offset, stride, temp, output);
-    yield_gpu_with_remark("softmax_tree_kernel");
+        softmax_kernel<<<cuda_gridsize(batch*groups), BLOCK>>>(input, n, batch, batch_offset, groups, group_offset, stride, temp, output);
 
     check_error(cudaPeekAtLastError());
 }
@@ -1168,9 +1080,7 @@ extern "C" void upsample_gpu(float *in, int w, int h, int c, int batch, int stri
 {
     size_t size = w*h*c*batch*stride*stride;
 
-    request_gpu();
-    upsample_kernel<<<cuda_gridsize(size), BLOCK>>>(size, in, w, h, c, batch, stride, forward, scale, out);
-    yield_gpu_with_remark("upsample_kernel");
+        upsample_kernel<<<cuda_gridsize(size), BLOCK>>>(size, in, w, h, c, batch, stride, forward, scale, out);
 
     check_error(cudaPeekAtLastError());
 }
diff --git a/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/col2im_kernels.cu b/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/col2im_kernels.cu
index ad00edde..64a35528 100644
--- a/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/col2im_kernels.cu
+++ b/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/col2im_kernels.cu
@@ -50,12 +50,10 @@ void col2im_gpu(float *data_col,
     int width_col = (width + 2 * pad - ksize) / stride + 1;
     int num_kernels = channels * height * width;
     
-    request_gpu();
-    col2im_gpu_kernel<<<(num_kernels+BLOCK-1)/BLOCK,
+        col2im_gpu_kernel<<<(num_kernels+BLOCK-1)/BLOCK,
         BLOCK>>>(
                 num_kernels, data_col, height, width, ksize, pad,
                 stride, height_col,
                 width_col, data_im);
-    yield_gpu_with_remark("col2im_gpu_kernel");
 }
 
diff --git a/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/convolutional_kernels.cu b/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/convolutional_kernels.cu
index 7792dc81..95f07477 100644
--- a/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/convolutional_kernels.cu
+++ b/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/convolutional_kernels.cu
@@ -22,9 +22,7 @@ __global__ void binarize_kernel(float *x, int n, float *binary)
 
 void binarize_gpu(float *x, int n, float *binary)
 {
-    request_gpu();
-    binarize_kernel<<<cuda_gridsize(n), BLOCK>>>(x, n, binary);
-    yield_gpu_with_remark("binarize_kernel");
+        binarize_kernel<<<cuda_gridsize(n), BLOCK>>>(x, n, binary);
 
     check_error(cudaPeekAtLastError());
 }
@@ -46,9 +44,7 @@ __global__ void binarize_input_kernel(float *input, int n, int size, float *bina
 
 void binarize_input_gpu(float *input, int n, int size, float *binary)
 {
-    request_gpu();
-    binarize_input_kernel<<<cuda_gridsize(size), BLOCK>>>(input, n, size, binary);
-    yield_gpu_with_remark("binarize_input_kernel");
+        binarize_input_kernel<<<cuda_gridsize(size), BLOCK>>>(input, n, size, binary);
 
     check_error(cudaPeekAtLastError());
 }
@@ -72,9 +68,7 @@ __global__ void binarize_weights_kernel(float *weights, int n, int size, float *
 
 void binarize_weights_gpu(float *weights, int n, int size, float *binary)
 {
-    request_gpu();
-    binarize_weights_kernel<<<cuda_gridsize(n), BLOCK>>>(weights, n, size, binary);
-    yield_gpu_with_remark("binarize_weights_kernel");
+        binarize_weights_kernel<<<cuda_gridsize(n), BLOCK>>>(weights, n, size, binary);
 
     check_error(cudaPeekAtLastError());
 }
@@ -177,9 +171,7 @@ extern "C" void smooth_layer(layer l, int size, float rate)
 
     size_t n = h*w*c*l.batch;
 
-    request_gpu();
-    smooth_kernel<<<cuda_gridsize(n), BLOCK>>>(l.output_gpu, n, l.w, l.h, l.c, size, rate, l.delta_gpu);
-    yield_gpu_with_remark("smooth_kernel");
+        smooth_kernel<<<cuda_gridsize(n), BLOCK>>>(l.output_gpu, n, l.w, l.h, l.c, size, rate, l.delta_gpu);
     
     check_error(cudaPeekAtLastError());
 }
diff --git a/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/crop_layer_kernels.cu b/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/crop_layer_kernels.cu
index d75e257d..539cfdba 100644
--- a/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/crop_layer_kernels.cu
+++ b/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/crop_layer_kernels.cu
@@ -195,17 +195,13 @@ extern "C" void forward_crop_layer_gpu(crop_layer layer, network net)
 
     int size = layer.batch * layer.w * layer.h;
 
-    request_gpu();
-    levels_image_kernel<<<cuda_gridsize(size), BLOCK>>>(net.input_gpu, layer.rand_gpu, layer.batch, layer.w, layer.h, net.train, layer.saturation, layer.exposure, translate, scale, layer.shift);
-    yield_gpu_with_remark("levels_image_kernel");
+        levels_image_kernel<<<cuda_gridsize(size), BLOCK>>>(net.input_gpu, layer.rand_gpu, layer.batch, layer.w, layer.h, net.train, layer.saturation, layer.exposure, translate, scale, layer.shift);
 
     check_error(cudaPeekAtLastError());
 
     size = layer.batch*layer.c*layer.out_w*layer.out_h;
 
-    request_gpu();
-    forward_crop_layer_kernel<<<cuda_gridsize(size), BLOCK>>>(net.input_gpu, layer.rand_gpu, size, layer.c, layer.h, layer.w, layer.out_h, layer.out_w, net.train, layer.flip, radians, layer.output_gpu);
-    yield_gpu_with_remark("forward_crop_layer_kernel");
+        forward_crop_layer_kernel<<<cuda_gridsize(size), BLOCK>>>(net.input_gpu, layer.rand_gpu, size, layer.c, layer.h, layer.w, layer.out_h, layer.out_w, net.train, layer.flip, radians, layer.output_gpu);
 
     check_error(cudaPeekAtLastError());
 
diff --git a/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/cuda.c b/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/cuda.c
index a9da26f1..5c1bfc0d 100644
--- a/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/cuda.c
+++ b/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/cuda.c
@@ -92,15 +92,11 @@ float *cuda_make_array(float *x, size_t n)
     float *x_gpu;
     size_t size = sizeof(float)*n;
     
-    request_gpu();
-    cudaError_t status = cudaMalloc((void **)&x_gpu, size);
-    yield_gpu_with_remark("cudaMalloc");
+        cudaError_t status = cudaMalloc((void **)&x_gpu, size);
 
     check_error(status);
     if(x){
-        request_gpu();
-        status = cudaMemcpy(x_gpu, x, size, cudaMemcpyHostToDevice);
-        yield_gpu_with_remark("cuda_make_array");
+                status = cudaMemcpy(x_gpu, x, size, cudaMemcpyHostToDevice);
         check_error(status);
     } else {
         fill_gpu(n, 0, x_gpu, 1);
@@ -114,25 +110,17 @@ void cuda_random(float *x_gpu, size_t n)
     static curandGenerator_t gen[16];
     static int init[16] = {0};
 
-    request_gpu();
-    int i = cuda_get_device();
-    yield_gpu_with_remark("cuda_get_device");
+        int i = cuda_get_device();
 
     if(!init[i]){
-        request_gpu();
-        curandCreateGenerator(&gen[i], CURAND_RNG_PSEUDO_DEFAULT);
-        yield_gpu_with_remark("curandCreateGenerator");
+                curandCreateGenerator(&gen[i], CURAND_RNG_PSEUDO_DEFAULT);
 
-        request_gpu();
-        curandSetPseudoRandomGeneratorSeed(gen[i], time(0));
-        yield_gpu_with_remark("curandSetPseudoRandomGeneratorSeed");
+                curandSetPseudoRandomGeneratorSeed(gen[i], time(0));
 
         init[i] = 1;
     }
 
-    request_gpu();
-    curandGenerateUniform(gen[i], x_gpu, n);
-    yield_gpu_with_remark("curandGenerateUniform");
+        curandGenerateUniform(gen[i], x_gpu, n);
 
     check_error(cudaPeekAtLastError());
 }
@@ -155,15 +143,11 @@ int *cuda_make_int_array(int *x, size_t n)
     int *x_gpu;
     size_t size = sizeof(int)*n;
 
-    request_gpu();
-    cudaError_t status = cudaMalloc((void **)&x_gpu, size);
-    yield_gpu_with_remark("cudaMalloc");
+        cudaError_t status = cudaMalloc((void **)&x_gpu, size);
 
     check_error(status);
     if(x){
-        request_gpu();
-        status = cudaMemcpy(x_gpu, x, size, cudaMemcpyHostToDevice);
-        yield_gpu_with_remark("cuda_make_int_array");
+                status = cudaMemcpy(x_gpu, x, size, cudaMemcpyHostToDevice);
 
         check_error(status);
     }
@@ -173,9 +157,7 @@ int *cuda_make_int_array(int *x, size_t n)
 
 void cuda_free(float *x_gpu)
 {
-    request_gpu();
-    cudaError_t status = cudaFree(x_gpu);
-    yield_gpu_with_remark("free");
+        cudaError_t status = cudaFree(x_gpu);
 
     check_error(status);
 }
@@ -183,9 +165,7 @@ void cuda_free(float *x_gpu)
 void cuda_push_array(float *x_gpu, float *x, size_t n)
 {
     size_t size = sizeof(float)*n;
-    request_gpu();
-    cudaError_t status = cudaMemcpy(x_gpu, x, size, cudaMemcpyHostToDevice);
-    yield_gpu_with_remark("cuda_push_array");
+        cudaError_t status = cudaMemcpy(x_gpu, x, size, cudaMemcpyHostToDevice);
 
     check_error(status);
 }
@@ -194,9 +174,7 @@ void cuda_pull_array(float *x_gpu, float *x, size_t n)
 {
     size_t size = sizeof(float)*n;
 
-    request_gpu();
-    cudaError_t status = cudaMemcpy(x, x_gpu, size, cudaMemcpyDeviceToHost);
-    yield_gpu_with_remark("cuda_pull_array");
+        cudaError_t status = cudaMemcpy(x, x_gpu, size, cudaMemcpyDeviceToHost);
 
     check_error(status);
 }
diff --git a/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/dropout_layer_kernels.cu b/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/dropout_layer_kernels.cu
index ad24b679..c6774fa7 100644
--- a/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/dropout_layer_kernels.cu
+++ b/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/dropout_layer_kernels.cu
@@ -27,9 +27,7 @@ void forward_dropout_layer_gpu(dropout_layer layer, network net)
     cuda_push_array(layer.rand_gpu, layer.rand, size);
     */
 
-    request_gpu();
-    yoloswag420blazeit360noscope<<<cuda_gridsize(size), BLOCK>>>(net.input_gpu, size, layer.rand_gpu, layer.probability, layer.scale);
-    yield_gpu_with_remark("yoloswag420blazeit360noscope_forward");
+        yoloswag420blazeit360noscope<<<cuda_gridsize(size), BLOCK>>>(net.input_gpu, size, layer.rand_gpu, layer.probability, layer.scale);
 
     check_error(cudaPeekAtLastError());
 }
@@ -39,9 +37,7 @@ void backward_dropout_layer_gpu(dropout_layer layer, network net)
     if(!net.delta_gpu) return;
     int size = layer.inputs*layer.batch;
 
-    request_gpu();
-    yoloswag420blazeit360noscope<<<cuda_gridsize(size), BLOCK>>>(net.delta_gpu, size, layer.rand_gpu, layer.probability, layer.scale);
-    yield_gpu_with_remark("yoloswag420blazeit360noscope_backward");
+        yoloswag420blazeit360noscope<<<cuda_gridsize(size), BLOCK>>>(net.delta_gpu, size, layer.rand_gpu, layer.probability, layer.scale);
 
     check_error(cudaPeekAtLastError());
 }
diff --git a/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/im2col_kernels.cu b/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/im2col_kernels.cu
index 0a73ec88..d2ccbdee 100644
--- a/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/im2col_kernels.cu
+++ b/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/im2col_kernels.cu
@@ -54,11 +54,9 @@ void im2col_gpu(float *im,
     int width_col = (width + 2 * pad - ksize) / stride + 1;
     int num_kernels = channels * height_col * width_col;
 
-    request_gpu();
-    im2col_gpu_kernel<<<(num_kernels+BLOCK-1)/BLOCK,
+        im2col_gpu_kernel<<<(num_kernels+BLOCK-1)/BLOCK,
         BLOCK>>>(
                 num_kernels, im, height, width, ksize, pad,
                 stride, height_col,
                 width_col, data_col);
-    yield_gpu_with_remark("im2col_gpu_kernel");
 }
diff --git a/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/maxpool_layer_kernels.cu b/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/maxpool_layer_kernels.cu
index 285ae322..12d920ee 100644
--- a/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/maxpool_layer_kernels.cu
+++ b/autoware.ai/src/autoware/core_perception/vision_darknet_detect/darknet/src/maxpool_layer_kernels.cu
@@ -92,9 +92,7 @@ extern "C" void forward_maxpool_layer_gpu(maxpool_layer layer, network net)
 
     size_t n = h*w*c*layer.batch;
 
-    request_gpu();
-    forward_maxpool_layer_kernel<<<cuda_gridsize(n), BLOCK>>>(n, layer.h, layer.w, layer.c, layer.stride, layer.size, layer.pad, net.input_gpu, layer.output_gpu, layer.indexes_gpu);
-    yield_gpu_with_remark("im2col_gpu_kernel");
+        forward_maxpool_layer_kernel<<<cuda_gridsize(n), BLOCK>>>(n, layer.h, layer.w, layer.c, layer.stride, layer.size, layer.pad, net.input_gpu, layer.output_gpu, layer.indexes_gpu);
 
     check_error(cudaPeekAtLastError());
 }
@@ -103,9 +101,7 @@ extern "C" void backward_maxpool_layer_gpu(maxpool_layer layer, network net)
 {
     size_t n = layer.h*layer.w*layer.c*layer.batch;
 
-    request_gpu();
-    backward_maxpool_layer_kernel<<<cuda_gridsize(n), BLOCK>>>(n, layer.h, layer.w, layer.c, layer.stride, layer.size, layer.pad, layer.delta_gpu, net.delta_gpu, layer.indexes_gpu);
-    yield_gpu_with_remark("im2col_gpu_kernel");
+        backward_maxpool_layer_kernel<<<cuda_gridsize(n), BLOCK>>>(n, layer.h, layer.w, layer.c, layer.stride, layer.size, layer.pad, layer.delta_gpu, net.delta_gpu, layer.indexes_gpu);
 
     check_error(cudaPeekAtLastError());
 }
diff --git a/autoware.ai/src/autoware/core_perception/vision_darknet_detect/src/vision_darknet_detect.cpp b/autoware.ai/src/autoware/core_perception/vision_darknet_detect/src/vision_darknet_detect.cpp
index 133eaf33..7bc19835 100644
--- a/autoware.ai/src/autoware/core_perception/vision_darknet_detect/src/vision_darknet_detect.cpp
+++ b/autoware.ai/src/autoware/core_perception/vision_darknet_detect/src/vision_darknet_detect.cpp
@@ -282,12 +282,6 @@ void Yolo3DetectorNode::image_callback(const sensor_msgs::ImageConstPtr& in_imag
 
     free(darknet_image_.data);
     
-    if(is_task_ready_ == TASK_NOT_READY){
-        init_task();
-        if(gpu_profiling_flag_) start_gpu_profiling();
-    }
-    
-    task_state_ = TASK_STATE_DONE;
 }
 
 void Yolo3DetectorNode::config_cb(const autoware_config_msgs::ConfigSSD::ConstPtr& param)
@@ -327,52 +321,22 @@ void Yolo3DetectorNode::Run()
     int key_id = 2;
 
     // Scheduling Setup
-    int task_scheduling_flag;
-    int task_profiling_flag;
     std::string task_response_time_filename_str;
     int rate;
     double task_minimum_inter_release_time;
     double task_execution_time;
     double task_relative_deadline;
 
-    int gpu_scheduling_flag;
-    int gpu_profiling_flag;
-    std::string gpu_execution_time_filename_str;
-    std::string gpu_response_time_filename_str;
-    std::string gpu_deadline_filename_str;
-
-    private_node_handle.param<int>("/vision_darknet_detect/task_scheduling_flag", task_scheduling_flag, 0);
-    private_node_handle.param<int>("/vision_darknet_detect/task_profiling_flag", task_profiling_flag, 0);
     private_node_handle.param<std::string>("/vision_darknet_detect/task_response_time_filename", task_response_time_filename_str, "~/Documents/profiling/response_time/vision_darknet_detect.csv");
     private_node_handle.param<int>("/vision_darknet_detect/rate", rate, 10);
     private_node_handle.param("/vision_darknet_detect/task_minimum_inter_release_time", task_minimum_inter_release_time, (double)10);
     private_node_handle.param("/vision_darknet_detect/task_execution_time", task_execution_time, (double)10);
     private_node_handle.param("/vision_darknet_detect/task_relative_deadline", task_relative_deadline, (double)10);
-    private_node_handle.param("/vision_darknet_detect/gpu_scheduling_flag", gpu_scheduling_flag, 0);
-    private_node_handle.param("/vision_darknet_detect/gpu_profiling_flag", gpu_profiling_flag, 0);
-    private_node_handle.param<std::string>("/vision_darknet_detect/gpu_execution_time_filename", gpu_execution_time_filename_str, "~/Documents/gpu_profiling/test_yolo_execution_time.csv");
-    private_node_handle.param<std::string>("/vision_darknet_detect/gpu_response_time_filename", gpu_response_time_filename_str, "~/Documents/gpu_profiling/test_yolo_response_time.csv");
-    private_node_handle.param<std::string>("/vision_darknet_detect/gpu_deadline_filename", gpu_deadline_filename_str, "~/Documents/gpu_deadline/yolo_gpu_deadline.csv");
-
-    
-
     
     char* task_response_time_filename = strdup(task_response_time_filename_str.c_str());
-    char* gpu_execution_time_filename = strdup(gpu_execution_time_filename_str.c_str());
-    char* gpu_response_time_filename = strdup(gpu_response_time_filename_str.c_str());
-    char* gpu_deadline_filename = strdup(gpu_deadline_filename_str.c_str());
-
-    if(task_profiling_flag) init_task_profiling(task_response_time_filename);
-    if(gpu_profiling_flag) init_gpu_profiling(gpu_execution_time_filename, gpu_response_time_filename);
-
-    if(gpu_scheduling_flag){
-        init_gpu_scheduling("/tmp/yolo", gpu_deadline_filename, key_id);
-    }else if(gpu_scheduling_flag){
-        ROS_ERROR("GPU scheduling flag is true but type doesn't set to GPU!");
-        exit(1);
-    }
-    
-    
+
+    init_task_profiling(task_response_time_filename);
+
     //RECEIVE IMAGE TOPIC NAME
     std::string image_raw_topic_str;
     if (private_node_handle.getParam("image_raw_node", image_raw_topic_str))
@@ -449,39 +413,17 @@ void Yolo3DetectorNode::Run()
 
     ROS_INFO_STREAM( __APP_NAME__ << "" );
 
-    if(!task_scheduling_flag && !task_profiling_flag){
-        ros::spin();
-    }
-    else{
-        ros::Rate r(rate);
-        // Initialize task ( Wait until first necessary topic is published )
-        while(ros::ok()){
-            if(is_task_ready_) break;
-            ros::spinOnce();
-            r.sleep();      
-        }
+    ros::Rate r(rate);
 
-        // Executing task
-        while(ros::ok()){
-            if(task_profiling_flag) start_task_profiling();          
-            if(task_state_ == TASK_STATE_READY){
-                if(task_scheduling_flag) request_task_scheduling(task_minimum_inter_release_time, task_execution_time, task_relative_deadline); 
-                if(gpu_profiling_flag || gpu_scheduling_flag) start_job();
-                task_state_ = TASK_STATE_RUNNING;     
-            }
+    // Executing task
+    while(ros::ok()){
+        start_task_profiling();          
 
-            ros::spinOnce();
+        ros::spinOnce();
 
-            if(task_profiling_flag) stop_task_profiling(0, task_state_);
+        stop_task_profiling(0, 0);
 
-            if(task_state_ == TASK_STATE_DONE){
-                if(gpu_profiling_flag || gpu_scheduling_flag) finish_job();
-                if(task_scheduling_flag) yield_task_scheduling();
-                task_state_ = TASK_STATE_READY;
-            }
-            
-            r.sleep();
-        }
+        r.sleep();
     }
     ROS_INFO("END Yolo");
 
diff --git a/autoware.ai/src/autoware/core_planning/op_global_planner/nodes/op_global_planner_core.cpp b/autoware.ai/src/autoware/core_planning/op_global_planner/nodes/op_global_planner_core.cpp
index 67a65d23..9517d002 100644
--- a/autoware.ai/src/autoware/core_planning/op_global_planner/nodes/op_global_planner_core.cpp
+++ b/autoware.ai/src/autoware/core_planning/op_global_planner/nodes/op_global_planner_core.cpp
@@ -240,7 +240,6 @@ void GlobalPlanner::callbackGetVehicleStatus(const geometry_msgs::TwistStampedCo
     m_VehicleState.steer = atan(2.7 * msg->twist.angular.z/msg->twist.linear.x);
   UtilityHNS::UtilityH::GetTickCount(m_VehicleState.tStamp);
 
-  if(rubis::sched::is_task_ready_ == TASK_NOT_READY) rubis::sched::init_task();
 }
 
 void GlobalPlanner::callbackGetCANInfo(const autoware_can_msgs::CANInfoConstPtr &msg)
@@ -447,8 +446,6 @@ void GlobalPlanner::MainLoop()
   ros::NodeHandle private_nh("~");
 
   // Scheduling Setup
-  int task_scheduling_flag;
-  int task_profiling_flag;
   std::string task_response_time_filename;
   int rate;
   double task_minimum_inter_release_time;
@@ -458,8 +455,6 @@ void GlobalPlanner::MainLoop()
   double multilap_replanning_distance;
   int planning_fail_cnt;
 
-  private_nh.param<int>("/op_global_planner/task_scheduling_flag", task_scheduling_flag, 0);
-  private_nh.param<int>("/op_global_planner/task_profiling_flag", task_profiling_flag, 0);
   private_nh.param<std::string>("/op_global_planner/task_response_time_filename", task_response_time_filename, "~/Documents/profiling/response_time/op_global_planner.csv");
   private_nh.param<int>("/op_global_planner/rate", rate, 10);
   private_nh.param("/op_global_planner/task_minimum_inter_release_time", task_minimum_inter_release_time, (double)10);
@@ -468,24 +463,16 @@ void GlobalPlanner::MainLoop()
   private_nh.param("/op_global_planner/multilap_flag", multilap_flag, 0);
   private_nh.param("/op_global_planner/multilap_replanning_distance", multilap_replanning_distance, (double)50);
 
-  if(task_profiling_flag) rubis::sched::init_task_profiling(task_response_time_filename);
+  rubis::init_task_profiling(task_response_time_filename);
 
   timespec animation_timer;
   UtilityHNS::UtilityH::GetTickCount(animation_timer);
 
   ros::Rate loop_rate(rate);
-  if(!task_scheduling_flag && !task_profiling_flag) loop_rate = ros::Rate(25);
-  
-
 
   while (ros::ok())
   {
-    if(task_profiling_flag) rubis::sched::start_task_profiling();
-
-    if(rubis::sched::is_task_ready_ == TASK_READY && rubis::sched::task_state_ == TASK_STATE_READY){
-      if(task_scheduling_flag) rubis::sched::request_task_scheduling(task_minimum_inter_release_time, task_execution_time, task_relative_deadline); 
-      rubis::sched::task_state_ = TASK_STATE_RUNNING;     
-    }
+    rubis::start_task_profiling();
 
     ros::spinOnce();
     bool bMakeNewPlan = false;
@@ -618,14 +605,10 @@ void GlobalPlanner::MainLoop()
       VisualizeDestinations(m_GoalsPos, m_iCurrentGoalIndex);
     }
 
-    rubis::sched::task_state_ = TASK_STATE_DONE;
+    
 
-    if(task_profiling_flag) rubis::sched::stop_task_profiling(0, rubis::sched::task_state_);
+    rubis::stop_task_profiling(0, 0);
 
-    if(rubis::sched::is_task_ready_ == TASK_READY && rubis::sched::task_state_ == TASK_STATE_DONE){
-      if(task_scheduling_flag) rubis::sched::yield_task_scheduling();
-      rubis::sched::task_state_ = TASK_STATE_READY;
-    }
     loop_rate.sleep();
   }
 }
diff --git a/autoware.ai/src/autoware/core_planning/op_local_planner/include/op_behavior_selector_core.h b/autoware.ai/src/autoware/core_planning/op_local_planner/include/op_behavior_selector_core.h
index 708301ff..ee2efa6d 100644
--- a/autoware.ai/src/autoware/core_planning/op_local_planner/include/op_behavior_selector_core.h
+++ b/autoware.ai/src/autoware/core_planning/op_local_planner/include/op_behavior_selector_core.h
@@ -61,12 +61,17 @@
 #include <visualization_msgs/Marker.h>
 #include <tf/transform_listener.h>
 
+#include "rubis_msgs/LaneArrayWithPoseTwist.h"
+#include "rubis_msgs/LaneWithPoseTwist.h"
+
 
 namespace BehaviorGeneratorNS
 {
 
 class BehaviorGen
 {
+public:
+  const rubis_msgs::LaneArrayWithPoseTwist lane_array_with_pose_twist_msg_;
 protected: //Planning Related variables
   double PI = 3.14159265;
 
@@ -120,12 +125,14 @@ protected: //Planning Related variables
   double m_sprintSpeed;
   bool m_sprintSwitch;
   double m_obstacleWaitingTimeinIntersection;
+  double distance_to_pdestrian_;
 
   //ROS messages (topics)
   ros::NodeHandle nh;
 
   //define publishers
   ros::Publisher pub_LocalPath;
+  ros::Publisher pub_LocalPathWithPosePub;
   ros::Publisher pub_LocalBasePath;
   ros::Publisher pub_ClosestIndex;
   ros::Publisher pub_BehaviorState;
@@ -159,15 +166,18 @@ protected: //Planning Related variables
   ros::Subscriber sub_SprintSwitch;
   ros::Subscriber sub_IntersectionCondition;
 
+  // Others
+  timespec planningTimer;
+  std_msgs::Bool emergency_stop_msg;
+
   // Callback function for subscriber.
-  void callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr& msg);
-  void callbackGetVehicleStatus(const geometry_msgs::TwistStampedConstPtr& msg);
   void callbackGetCANInfo(const autoware_can_msgs::CANInfoConstPtr &msg);
   void callbackGetRobotOdom(const nav_msgs::OdometryConstPtr& msg);
   void callbackGetGlobalPlannerPath(const autoware_msgs::LaneArrayConstPtr& msg);
-  void callbackGetLocalPlannerPath(const autoware_msgs::LaneArrayConstPtr& msg);
+  void callbackGetLocalPlannerPath(const rubis_msgs::LaneArrayWithPoseTwistConstPtr& msg);
   void callbackGetLocalTrajectoryCost(const autoware_msgs::LaneConstPtr& msg);
   void callbackDistanceToPedestrian(const std_msgs::Float64& msg);
+  void _callbackDistanceToPedestrian();
   void callbackIntersectionCondition(const autoware_msgs::IntersectionCondition& msg);
 
   void callbackGetV2XTrafficLightSignals(const autoware_msgs::RUBISTrafficSignalArray& msg);
@@ -179,7 +189,7 @@ protected: //Planning Related variables
 
   //Helper Functions
   void UpdatePlanningParams(ros::NodeHandle& _nh);
-  void SendLocalPlanningTopics();
+  void SendLocalPlanningTopics(const rubis_msgs::LaneArrayWithPoseTwistConstPtr& msg);
   void VisualizeLocalPlanner();
   void LogLocalPlanningInfo(double dt);
   bool GetBaseMapTF();  
diff --git a/autoware.ai/src/autoware/core_planning/op_local_planner/include/op_motion_predictor_core.h b/autoware.ai/src/autoware/core_planning/op_local_planner/include/op_motion_predictor_core.h
index 3890c27d..d1bf4bb6 100644
--- a/autoware.ai/src/autoware/core_planning/op_local_planner/include/op_motion_predictor_core.h
+++ b/autoware.ai/src/autoware/core_planning/op_local_planner/include/op_motion_predictor_core.h
@@ -125,9 +125,12 @@ protected:
   ros::Subscriber sub_can_info      ;
   ros::Subscriber sub_StepSignal;
 
+  rubis_msgs::DetectedObjectArray objects_msgs_;
+
   // Callback function for subscriber.
   void callbackGetTrackedObjects(const autoware_msgs::DetectedObjectArrayConstPtr& msg);
   void callbackGetRubisTrackedObjects(const rubis_msgs::DetectedObjectArrayConstPtr& msg);
+  void _callbackGetRubisTrackedObjects(rubis_msgs::DetectedObjectArray& objects_msg);
   void callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr& msg);
   void callbackGetVehicleStatus(const geometry_msgs::TwistStampedConstPtr& msg);
   void callbackGetCANInfo(const autoware_can_msgs::CANInfoConstPtr &msg);
diff --git a/autoware.ai/src/autoware/core_planning/op_local_planner/include/op_trajectory_evaluator_core.h b/autoware.ai/src/autoware/core_planning/op_local_planner/include/op_trajectory_evaluator_core.h
index f2c4576d..a0324e44 100644
--- a/autoware.ai/src/autoware/core_planning/op_local_planner/include/op_trajectory_evaluator_core.h
+++ b/autoware.ai/src/autoware/core_planning/op_local_planner/include/op_trajectory_evaluator_core.h
@@ -37,6 +37,7 @@
 #include <std_msgs/Float64.h>
 #include <std_msgs/Int32.h>
 #include <std_msgs/Bool.h>
+#include "rubis_msgs/LaneArrayWithPoseTwist.h"
 
 #include "op_planner/PlannerCommonDef.h"
 #include "op_planner/TrajectoryDynamicCosts.h"
@@ -50,6 +51,7 @@ namespace TrajectoryEvaluatorNS
 class TrajectoryEval
 {
 protected:
+  bool is_objects_updated_;
 
   PlannerHNS::TrajectoryDynamicCosts m_TrajectoryCostsCalculator;
   bool m_bUseMoveingObjectsPrediction;
@@ -101,6 +103,7 @@ protected:
   ros::Publisher pub_CollisionPointsRviz;
   ros::Publisher pub_LocalWeightedTrajectoriesRviz;
   ros::Publisher pub_LocalWeightedTrajectories;
+  ros::Publisher pub_LocalWeightedTrajectoriesWithPoseTwist;
   ros::Publisher pub_TrajectoryCost;
   ros::Publisher pub_SafetyBorderRviz;
   ros::Publisher pub_DistanceToPedestrian;
@@ -128,6 +131,9 @@ protected:
   tf::StampedTransform  m_velodyne_to_base_link;
   tf::StampedTransform  m_velodyne_to_map;
 
+  // Others
+  std::vector<PlannerHNS::Crossing> intersection_list_;
+  autoware_msgs::DetectedObjectArray object_msg_;
 
   // Callback function for subscriber.
   void callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr& msg);
@@ -135,8 +141,9 @@ protected:
   void callbackGetCANInfo(const autoware_can_msgs::CANInfoConstPtr &msg);
   void callbackGetRobotOdom(const nav_msgs::OdometryConstPtr& msg);
   void callbackGetGlobalPlannerPath(const autoware_msgs::LaneArrayConstPtr& msg);
-  void callbackGetLocalPlannerPath(const autoware_msgs::LaneArrayConstPtr& msg);
-  void callbackGetPredictedObjects(const autoware_msgs::DetectedObjectArrayConstPtr& msg);
+  void callbackGetLocalPlannerPath(const rubis_msgs::LaneArrayWithPoseTwistConstPtr& msg);
+  void callbackGetPredictedObjects(const rubis_msgs::DetectedObjectArrayConstPtr& msg);
+  void _callbackGetPredictedObjects(const autoware_msgs::DetectedObjectArray& objects);
   void callbackGetRubisPredictedObjects(const rubis_msgs::DetectedObjectArrayConstPtr& msg);
   void callbackGetBehaviorState(const geometry_msgs::TwistStampedConstPtr & msg);
   void callbackGetCurrentState(const std_msgs::Int32 & msg);
diff --git a/autoware.ai/src/autoware/core_planning/op_local_planner/include/op_trajectory_generator_core.h b/autoware.ai/src/autoware/core_planning/op_local_planner/include/op_trajectory_generator_core.h
index f7dddce1..c47e5c2e 100644
--- a/autoware.ai/src/autoware/core_planning/op_local_planner/include/op_trajectory_generator_core.h
+++ b/autoware.ai/src/autoware/core_planning/op_local_planner/include/op_trajectory_generator_core.h
@@ -30,12 +30,18 @@
 #include "op_planner/PlannerH.h"
 #include "op_planner/PlannerCommonDef.h"
 
+#include "rubis_msgs/PoseTwistStamped.h"
+#include "rubis_msgs/LaneArrayWithPoseTwist.h"
+
 namespace TrajectoryGeneratorNS
 {
 
 class TrajectoryGen
 {
 protected:
+  geometry_msgs::PoseStamped current_pose_;
+  geometry_msgs::TwistStamped current_twist_;
+
   PlannerHNS::PlannerH m_Planner;
   geometry_msgs::Pose m_OriginPos;
   PlannerHNS::WayPoint m_InitPos;
@@ -59,11 +65,12 @@ protected:
     PlannerHNS::CAR_BASIC_INFO m_CarInfo;
 
 
-    //ROS messages (topics)
+  //ROS messages (topics)
   ros::NodeHandle nh;
 
   //define publishers
   ros::Publisher pub_LocalTrajectories;
+  ros::Publisher pub_LocalTrajectoriesWithPoseTwist;
   ros::Publisher pub_LocalTrajectoriesRviz;
 
   // define subscribers.
@@ -73,16 +80,22 @@ protected:
   ros::Subscriber sub_robot_odom;
   ros::Subscriber sub_can_info;
   ros::Subscriber sub_GlobalPlannerPaths;
+  ros::Subscriber sub_pose_twist;
 
+  // Others
+  
 
   // Callback function for subscriber.
   void callbackGetInitPose(const geometry_msgs::PoseWithCovarianceStampedConstPtr &input);
-  void callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr& msg);
+  // void callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr& msg);
+
+  void callbackGetCurrentPoseTwist(const rubis_msgs::PoseTwistStampedPtr& msg);
   void callbackGetVehicleStatus(const geometry_msgs::TwistStampedConstPtr& msg);
   void callbackGetCANInfo(const autoware_can_msgs::CANInfoConstPtr &msg);
   void callbackGetRobotOdom(const nav_msgs::OdometryConstPtr& msg);
   void callbackGetGlobalPlannerPath(const autoware_msgs::LaneArrayConstPtr& msg);
 
+
   //Helper Functions
   void UpdatePlanningParams(ros::NodeHandle& _nh);
 
diff --git a/autoware.ai/src/autoware/core_planning/op_local_planner/launch/op_behavior_selector.launch b/autoware.ai/src/autoware/core_planning/op_local_planner/launch/op_behavior_selector.launch
index 0e794331..69cb1a60 100644
--- a/autoware.ai/src/autoware/core_planning/op_local_planner/launch/op_behavior_selector.launch
+++ b/autoware.ai/src/autoware/core_planning/op_local_planner/launch/op_behavior_selector.launch
@@ -12,7 +12,7 @@
   <!-- <arg name="intersectionFile" default="crossing_test/crossing_intersection.yaml" /> -->
   
       
-  <node pkg="op_local_planner" type="op_behavior_selector" name="op_behavior_selector">
+  <node pkg="op_local_planner" type="op_behavior_selector" name="op_behavior_selector" ouptut="screen">
     <rosparam command="load" file="$(find rubis_pkg)/cfg/$(arg trafficLightFile)"/>
     <rosparam command="load" file="$(find rubis_pkg)/cfg/$(arg stopLineFile)"/>
     <!-- <rosparam command="load" file="$(find rubis_pkg)/cfg/$(arg intersectionFile)"/> -->
diff --git a/autoware.ai/src/autoware/core_planning/op_local_planner/launch/op_behavior_selector_parameter.launch b/autoware.ai/src/autoware/core_planning/op_local_planner/launch/op_behavior_selector_parameter.launch
index 7899250e..7c0bf9ac 100644
--- a/autoware.ai/src/autoware/core_planning/op_local_planner/launch/op_behavior_selector_parameter.launch
+++ b/autoware.ai/src/autoware/core_planning/op_local_planner/launch/op_behavior_selector_parameter.launch
@@ -8,7 +8,7 @@
   <!-- <arg name="intersectionFile" default="crossing_test/crossing_intersection.yaml" /> -->
   
       
-  <node pkg="op_local_planner" type="op_behavior_selector" name="op_behavior_selector">
+  <node pkg="op_local_planner" type="op_behavior_selector" name="op_behavior_selector" output="screen">
     <rosparam command="load" file="$(find rubis_pkg)/cfg/$(arg trafficLightFile)"/>
     <rosparam command="load" file="$(find rubis_pkg)/cfg/$(arg stopLineFile)"/>
     <!-- <rosparam command="load" file="$(find rubis_pkg)/cfg/$(arg intersectionFile)"/> -->
diff --git a/autoware.ai/src/autoware/core_planning/op_local_planner/launch/op_trajectory_evaluator.launch b/autoware.ai/src/autoware/core_planning/op_local_planner/launch/op_trajectory_evaluator.launch
index 37026b00..ef56b671 100644
--- a/autoware.ai/src/autoware/core_planning/op_local_planner/launch/op_trajectory_evaluator.launch
+++ b/autoware.ai/src/autoware/core_planning/op_local_planner/launch/op_trajectory_evaluator.launch
@@ -1,6 +1,8 @@
 <launch>
   <!-- Trajectory Evaluation Specific Parameters -->
   
+  <arg name="enableDebug"      default="0" />
+
   <arg name="enablePrediction"       default="false" />                
   <arg name="horizontalSafetyDistance"   default="1.2" />
   <arg name="verticalSafetyDistance"     default="0.8" />
@@ -11,6 +13,10 @@
   <arg name="weightLat"     default="5" />
   <arg name="LateralSkipDistance"   default="5.0" />
 
+  <arg name="lateralBlockingThreshold"           default="1.5" />
+  <arg name="frontLongitudinalBlockingThreshold"      default="30" />
+  <arg name="rearLongitudinalBlockingThreshold"      default="-5" />
+
   <arg name="ImageWidth" default="1920" />
   <arg name="ImageHeight" default="1080" />
   <arg name="PedestrianRightThreshold" default="7.0" />
@@ -25,7 +31,8 @@
       
   <node pkg="op_local_planner" type="op_trajectory_evaluator" name="op_trajectory_evaluator" output="screen">
     <rosparam command="load" file="$(find rubis_pkg)/cfg/$(arg intersectionFile)"/>
-  
+    
+    <param name="enableDebug"       value="$(arg enableDebug)" />
     <param name="enablePrediction"       value="$(arg enablePrediction)" />            
     <param name="horizontalSafetyDistance"   value="$(arg horizontalSafetyDistance)" />
     <param name="verticalSafetyDistance"   value="$(arg verticalSafetyDistance)" />    
@@ -34,7 +41,11 @@
     <param name="weightTransition"       value="$(arg weightTransition)" />            
     <param name="weightLong"       value="$(arg weightLong)" />            
     <param name="weightLat"       value="$(arg weightLat)" />            
-    <param name="LateralSkipDistance"       value="$(arg LateralSkipDistance)" />                
+    <param name="LateralSkipDistance"       value="$(arg LateralSkipDistance)" />    
+
+    <param name="lateralBlockingThreshold"   value="$(arg lateralBlockingThreshold)" />
+    <param name="frontLongitudinalBlockingThreshold"   value="$(arg frontLongitudinalBlockingThreshold)" />    
+    <param name="rearLongitudinalBlockingThreshold"       value="$(arg rearLongitudinalBlockingThreshold)" />              
 
     <!-- For detecting person and vehicle -->
     <param name="ImageWidth" value="$(arg ImageWidth)" />
diff --git a/autoware.ai/src/autoware/core_planning/op_local_planner/launch/op_trajectory_evaluator_parameter.launch b/autoware.ai/src/autoware/core_planning/op_local_planner/launch/op_trajectory_evaluator_parameter.launch
index 5b4c21ac..c1a16cfc 100644
--- a/autoware.ai/src/autoware/core_planning/op_local_planner/launch/op_trajectory_evaluator_parameter.launch
+++ b/autoware.ai/src/autoware/core_planning/op_local_planner/launch/op_trajectory_evaluator_parameter.launch
@@ -1,10 +1,15 @@
 <launch>
   <!-- Trajectory Evaluation Specific Parameters -->
+  <arg name="enableDebug"      default="0" />
   
   <arg name="enablePrediction"       default="false" />                
   <arg name="horizontalSafetyDistance"   default="1.2" />
   <arg name="verticalSafetyDistance"     default="0.8" />
   <arg name="LateralSkipDistance"   default="5.0" />
+  
+  <arg name="lateralBlockingThreshold"           default="1.5" />
+  <arg name="frontLongitudinalBlockingThreshold"      default="30" />
+  <arg name="rearLongitudinalBlockingThreshold"      default="-5" />
 
   <arg name="SprintDecisionTime" default="9999.0" /> 
 
@@ -12,11 +17,17 @@
       
   <node pkg="op_local_planner" type="op_trajectory_evaluator" name="op_trajectory_evaluator" output="screen">
     <rosparam command="load" file="$(find rubis_pkg)/cfg/$(arg intersectionFile)"/>
+
+    <param name="enableDebug"       value="$(arg enableDebug)" />
   
     <param name="enablePrediction"       value="$(arg enablePrediction)" />            
     <param name="horizontalSafetyDistance"   value="$(arg horizontalSafetyDistance)" />
     <param name="verticalSafetyDistance"   value="$(arg verticalSafetyDistance)" />    
-    <param name="LateralSkipDistance"       value="$(arg LateralSkipDistance)" />                
+    <param name="LateralSkipDistance"       value="$(arg LateralSkipDistance)" />
+
+    <param name="lateralBlockingThreshold"   value="$(arg lateralBlockingThreshold)" />
+    <param name="frontLongitudinalBlockingThreshold"   value="$(arg frontLongitudinalBlockingThreshold)" />    
+    <param name="rearLongitudinalBlockingThreshold"       value="$(arg rearLongitudinalBlockingThreshold)" />                
 
     <!-- For detecting person and vehicle -->
     <param name="SprintDecisionTime" value="$(arg SprintDecisionTime)" />
diff --git a/autoware.ai/src/autoware/core_planning/op_local_planner/nodes/op_behavior_selector/op_behavior_selector_core.cpp b/autoware.ai/src/autoware/core_planning/op_local_planner/nodes/op_behavior_selector/op_behavior_selector_core.cpp
index 9d824cfd..3c22305d 100644
--- a/autoware.ai/src/autoware/core_planning/op_local_planner/nodes/op_behavior_selector/op_behavior_selector_core.cpp
+++ b/autoware.ai/src/autoware/core_planning/op_local_planner/nodes/op_behavior_selector/op_behavior_selector_core.cpp
@@ -34,6 +34,8 @@ BehaviorGen::BehaviorGen()
   bBestCost = false;
   bMap = false;
   bRollOuts = false;
+  UtilityHNS::UtilityH::GetTickCount(planningTimer);
+  distance_to_pdestrian_ = 1000.0;
 
   ros::NodeHandle _nh;
   UpdatePlanningParams(_nh);
@@ -50,6 +52,7 @@ BehaviorGen::BehaviorGen()
   m_OriginPos.position.z  = transform.getOrigin().z();
 
   pub_LocalPath = nh.advertise<autoware_msgs::Lane>("final_waypoints", 1,true);
+  pub_LocalPathWithPosePub = nh.advertise<rubis_msgs::LaneWithPoseTwist>("final_waypoints_with_pose_twist", 1,true);
   pub_LocalBasePath = nh.advertise<autoware_msgs::Lane>("base_waypoints", 1,true);
   pub_ClosestIndex = nh.advertise<std_msgs::Int32>("closest_waypoint", 1,true);
   pub_BehaviorState = nh.advertise<geometry_msgs::TwistStamped>("current_behavior", 1);
@@ -61,36 +64,19 @@ BehaviorGen::BehaviorGen()
   pub_turnMarker = nh.advertise<visualization_msgs::MarkerArray>("turn_marker", 1);
   pub_currentState = nh.advertise<std_msgs::Int32>("current_state", 1);
 
-  sub_current_pose = nh.subscribe("/current_pose", 10,  &BehaviorGen::callbackGetCurrentPose, this); 
-
-  int bVelSource = 1;
-  _nh.getParam("/op_trajectory_evaluator/velocitySource", bVelSource);
-  if(bVelSource == 0)
-    sub_robot_odom = nh.subscribe("/odom", 10, &BehaviorGen::callbackGetRobotOdom, this);
-  else if(bVelSource == 1)
-    sub_current_velocity = nh.subscribe("/current_velocity", 10, &BehaviorGen::callbackGetVehicleStatus, this);
-  else if(bVelSource == 2)
-    sub_can_info = nh.subscribe("/can_info", 10, &BehaviorGen::callbackGetCANInfo, this);
-  
-  /*  RT Scheduling setup  */
-  // sub_current_pose = nh.subscribe("/current_pose", 1,  &BehaviorGen::callbackGetCurrentPose, this); //origin 10
-
   // int bVelSource = 1;
   // _nh.getParam("/op_trajectory_evaluator/velocitySource", bVelSource);
   // if(bVelSource == 0)
-  //   sub_robot_odom = nh.subscribe("/odom", 1, &BehaviorGen::callbackGetRobotOdom, this); //origin 10
-  // else if(bVelSource == 1)
-  //   sub_current_velocity = nh.subscribe("/current_velocity", 1, &BehaviorGen::callbackGetVehicleStatus, this); //origin 10
+  //   sub_robot_odom = nh.subscribe("/odom", 10, &BehaviorGen::callbackGetRobotOdom, this);
   // else if(bVelSource == 2)
-  //   sub_can_info = nh.subscribe("/can_info", 1, &BehaviorGen::callbackGetCANInfo, this); //origin 10
+  //   sub_can_info = nh.subscribe("/can_info", 10, &BehaviorGen::callbackGetCANInfo, this);
 
   sub_GlobalPlannerPaths = nh.subscribe("/lane_waypoints_array", 1, &BehaviorGen::callbackGetGlobalPlannerPath, this);
-  sub_LocalPlannerPaths = nh.subscribe("/local_weighted_trajectories", 1, &BehaviorGen::callbackGetLocalPlannerPath, this);
+  sub_LocalPlannerPaths = nh.subscribe("/local_weighted_trajectories_with_pose_twist", 1, &BehaviorGen::callbackGetLocalPlannerPath, this);
   // sub_TrafficLightStatus = nh.subscribe("/light_color", 1, &BehaviorGen::callbackGetTrafficLightStatus, this);
   // sub_TrafficLightSignals  = nh.subscribe("/roi_signal", 1, &BehaviorGen::callbackGetTrafficLightSignals, this);
   sub_Trajectory_Cost = nh.subscribe("/local_trajectory_cost", 1, &BehaviorGen::callbackGetLocalTrajectoryCost, this);
-
-  sub_TrafficLightSignals  = nh.subscribe("/v2x_traffic_signal", 1, &BehaviorGen::callbackGetV2XTrafficLightSignals, this);
+  // sub_TrafficLightSignals  = nh.subscribe("/v2x_traffic_signal", 1, &BehaviorGen::callbackGetV2XTrafficLightSignals, this);
 
   sub_twist_raw = nh.subscribe("/twist_raw", 1, &BehaviorGen::callbackGetTwistRaw, this);
   sub_twist_cmd = nh.subscribe("/twist_cmd", 1, &BehaviorGen::callbackGetTwistCMD, this);
@@ -206,9 +192,8 @@ void BehaviorGen::UpdatePlanningParams(ros::NodeHandle& _nh)
   m_BehaviorGenerator.m_obstacleWaitingTimeinIntersection = m_obstacleWaitingTimeinIntersection;
 }
 
-void BehaviorGen::callbackDistanceToPedestrian(const std_msgs::Float64& msg){
-  double distance = msg.data;
-  if(distance < m_distanceToPedestrianThreshold){
+void BehaviorGen::_callbackDistanceToPedestrian(){
+  if(distance_to_pdestrian_ < m_distanceToPedestrianThreshold){
     m_PlanningParams.pedestrianAppearence = true;
   }
   else
@@ -216,7 +201,10 @@ void BehaviorGen::callbackDistanceToPedestrian(const std_msgs::Float64& msg){
     m_PlanningParams.pedestrianAppearence = false;
   }
   m_BehaviorGenerator.UpdatePedestrianAppearence(m_PlanningParams.pedestrianAppearence);
-  // m_BehaviorGenerator.printPedestrianAppearence();
+}
+
+void BehaviorGen::callbackDistanceToPedestrian(const std_msgs::Float64& msg){
+  distance_to_pdestrian_ = msg.data;
 }
 
 void BehaviorGen::callbackIntersectionCondition(const autoware_msgs::IntersectionCondition& msg){
@@ -245,24 +233,6 @@ void BehaviorGen::callbackGetCommandCMD(const autoware_msgs::ControlCommandConst
   m_Ctrl_cmd = *msg;
 }
 
-void BehaviorGen::callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr& msg)
-{
-  m_CurrentPos = PlannerHNS::WayPoint(msg->pose.position.x, msg->pose.position.y, msg->pose.position.z, tf::getYaw(msg->pose.orientation));
-  bNewCurrentPos = true;
-}
-
-void BehaviorGen::callbackGetVehicleStatus(const geometry_msgs::TwistStampedConstPtr& msg)
-{
-  m_VehicleStatus.speed = msg->twist.linear.x;
-  m_CurrentPos.v = m_VehicleStatus.speed;
-  if(fabs(msg->twist.linear.x) > 0.25)
-    m_VehicleStatus.steer = atan(m_CarInfo.wheel_base * msg->twist.angular.z/msg->twist.linear.x);
-  UtilityHNS::UtilityH::GetTickCount(m_VehicleStatus.tStamp);
-  bVehicleStatus = true;
-
-  if(rubis::sched::is_task_ready_ == TASK_NOT_READY) rubis::sched::init_task();
-}
-
 void BehaviorGen::callbackGetCANInfo(const autoware_can_msgs::CANInfoConstPtr &msg)
 {
   m_VehicleStatus.speed = msg->speed/3.6;
@@ -373,17 +343,46 @@ void BehaviorGen::callbackGetLocalTrajectoryCost(const autoware_msgs::LaneConstP
   m_TrajectoryBestCost.closest_obj_velocity = msg->closest_object_velocity;
 }
 
-void BehaviorGen::callbackGetLocalPlannerPath(const autoware_msgs::LaneArrayConstPtr& msg)
+void BehaviorGen::callbackGetLocalPlannerPath(const rubis_msgs::LaneArrayWithPoseTwistConstPtr& msg)
 {
-  if(msg->lanes.size() > 0)
+  // Before spinOnce
+  rubis::start_task_profiling();
+  rubis::instance_ = msg->instance;
+  rubis::obj_instance_ = msg->obj_instance;
+
+  // Callback for distance to pedestrian
+  _callbackDistanceToPedestrian();
+
+  static double prev_x = 0.0, prev_y = 0.0, prev_speed = 0.0;
+  // Callback for current velocity
+  if(prev_speed != msg->twist.twist.linear.x){
+    m_VehicleStatus.speed = msg->twist.twist.linear.x;
+    m_CurrentPos.v = m_VehicleStatus.speed;
+    if(fabs(msg->twist.twist.linear.x) > 0.25)
+      m_VehicleStatus.steer = atan(m_CarInfo.wheel_base * msg->twist.twist.angular.z/msg->twist.twist.linear.x);
+    UtilityHNS::UtilityH::GetTickCount(m_VehicleStatus.tStamp);
+    bVehicleStatus = true;
+    prev_speed = msg->twist.twist.linear.x;
+  }
+
+  // Callback for current pose
+  if(prev_x != msg->pose.pose.position.x || prev_y != msg->pose.pose.position.y){
+    m_CurrentPos = PlannerHNS::WayPoint(msg->pose.pose.position.x, msg->pose.pose.position.y, msg->pose.pose.position.z, tf::getYaw(msg->pose.pose.orientation));
+    bNewCurrentPos = true;
+    prev_x = msg->pose.pose.position.x;
+    prev_y = msg->pose.pose.position.y;
+  }
+
+  // Callback for local planner path
+  if(msg->lane_array.lanes.size() > 0)
   {
     m_RollOuts.clear();
     int globalPathId_roll_outs = -1;
 
-    for(unsigned int i = 0 ; i < msg->lanes.size(); i++)
+    for(unsigned int i = 0 ; i < msg->lane_array.lanes.size(); i++)
     {
       std::vector<PlannerHNS::WayPoint> path;
-      PlannerHNS::ROSHelpers::ConvertFromAutowareLaneToLocalLane(msg->lanes.at(i), path);
+      PlannerHNS::ROSHelpers::ConvertFromAutowareLaneToLocalLane(msg->lane_array.lanes.at(i), path);
       m_RollOuts.push_back(path);
 
       if(path.size() > 0)
@@ -410,6 +409,143 @@ void BehaviorGen::callbackGetLocalPlannerPath(const autoware_msgs::LaneArrayCons
     m_BehaviorGenerator.m_RollOuts = m_RollOuts;
     bRollOuts = true;
   }
+
+  // Main Loop
+  // Check Pedestrian is Appeared
+  double dt  = UtilityHNS::UtilityH::GetTimeDiffNow(planningTimer);
+  UtilityHNS::UtilityH::GetTickCount(planningTimer);
+
+  if(m_MapType == PlannerHNS::MAP_KML_FILE && !bMap)
+  {
+    bMap = true;
+    PlannerHNS::MappingHelpers::LoadKML(m_MapPath, m_Map);
+  }
+  else if (m_MapType == PlannerHNS::MAP_FOLDER && !bMap)
+  {
+    bMap = true;
+    PlannerHNS::MappingHelpers::ConstructRoadNetworkFromDataFiles(m_MapPath, m_Map, true);
+
+  }
+  else if (m_MapType == PlannerHNS::MAP_AUTOWARE && !bMap)
+  {
+    std::vector<UtilityHNS::AisanDataConnFileReader::DataConn> conn_data;;
+
+    if(m_MapRaw.GetVersion()==2)
+    {
+      PlannerHNS::MappingHelpers::ConstructRoadNetworkFromROSMessageV2(m_MapRaw.pLanes->m_data_list, m_MapRaw.pPoints->m_data_list,
+          m_MapRaw.pCenterLines->m_data_list, m_MapRaw.pIntersections->m_data_list,m_MapRaw.pAreas->m_data_list,
+          m_MapRaw.pLines->m_data_list, m_MapRaw.pStopLines->m_data_list,  m_MapRaw.pSignals->m_data_list,
+          m_MapRaw.pVectors->m_data_list, m_MapRaw.pCurbs->m_data_list, m_MapRaw.pRoadedges->m_data_list, m_MapRaw.pWayAreas->m_data_list,
+          m_MapRaw.pCrossWalks->m_data_list, m_MapRaw.pNodes->m_data_list, conn_data,
+          m_MapRaw.pLanes, m_MapRaw.pPoints, m_MapRaw.pNodes, m_MapRaw.pLines, PlannerHNS::GPSPoint(), m_Map, true, m_PlanningParams.enableLaneChange, false);
+
+      try{
+        // Add Traffic Signal Info from yaml file
+        XmlRpc::XmlRpcValue traffic_light_list;
+        nh.getParam("/op_behavior_selector/traffic_light_list", traffic_light_list);
+
+        // Add Stop Line Info from yaml file
+        XmlRpc::XmlRpcValue stop_line_list;
+        nh.getParam("/op_behavior_selector/stop_line_list", stop_line_list);
+
+        // Add Crossing Info from yaml file
+        // XmlRpc::XmlRpcValue intersection_list;
+        // nh.getParam("/op_behavior_selector/intersection_list", intersection_list);
+
+        PlannerHNS::MappingHelpers::ConstructRoadNetwork_RUBIS(m_Map, traffic_light_list, stop_line_list);
+      }
+      catch(XmlRpc::XmlRpcException& e){
+        ROS_ERROR("[XmlRpc Error] %s", e.getMessage().c_str());
+        exit(1);
+      }
+
+      m_BehaviorGenerator.m_Map = m_Map;
+
+      if(m_Map.roadSegments.size() > 0)
+      {
+        bMap = true;
+        std::cout << " ******* Map V2 Is Loaded successfully from the Behavior Selector !! " << std::endl;
+      }
+    }
+    else if(m_MapRaw.GetVersion()==1)
+    {
+      PlannerHNS::MappingHelpers::ConstructRoadNetworkFromROSMessage(m_MapRaw.pLanes->m_data_list, m_MapRaw.pPoints->m_data_list,
+          m_MapRaw.pCenterLines->m_data_list, m_MapRaw.pIntersections->m_data_list,m_MapRaw.pAreas->m_data_list,
+          m_MapRaw.pLines->m_data_list, m_MapRaw.pStopLines->m_data_list,  m_MapRaw.pSignals->m_data_list,
+          m_MapRaw.pVectors->m_data_list, m_MapRaw.pCurbs->m_data_list, m_MapRaw.pRoadedges->m_data_list, m_MapRaw.pWayAreas->m_data_list,
+          m_MapRaw.pCrossWalks->m_data_list, m_MapRaw.pNodes->m_data_list, conn_data,  PlannerHNS::GPSPoint(), m_Map, true, m_PlanningParams.enableLaneChange, false);
+
+      if(m_Map.roadSegments.size() > 0)
+      {
+        bMap = true;
+        std::cout << " ******* Map V1 Is Loaded successfully from the Behavior Selector !! " << std::endl;
+      }
+    }
+  }
+
+  if(bNewCurrentPos && m_GlobalPaths.size()>0)
+  {
+    if(bNewLightSignal)
+    {
+      m_PrevTrafficLight = m_CurrTrafficLight;
+      bNewLightSignal = false;
+    }
+
+    if(bNewLightStatus)
+    {
+      bNewLightStatus = false;
+      for(unsigned int itls = 0 ; itls < m_PrevTrafficLight.size() ; itls++)
+        m_PrevTrafficLight.at(itls).lightState = m_CurrLightStatus;
+    }
+    
+    m_BehaviorGenerator.m_sprintSwitch = m_sprintSwitch;
+    m_CurrentBehavior = m_BehaviorGenerator.DoOneStep(dt, m_CurrentPos, m_VehicleStatus, 1, m_CurrTrafficLight, m_TrajectoryBestCost, 0);
+    std_msgs::Int32 curr_state_msg;
+    curr_state_msg.data = m_CurrentBehavior.state;
+
+    pub_currentState.publish(curr_state_msg);
+
+    CalculateTurnAngle(m_BehaviorGenerator.m_turnWaypoint);
+    m_BehaviorGenerator.m_turnAngle = m_turnAngle;
+
+    std_msgs::Float64 turn_angle_msg;
+    turn_angle_msg.data = m_turnAngle;
+    pub_turnAngle.publish(turn_angle_msg);
+
+    emergency_stop_msg.data = false;
+    if(m_CurrentBehavior.maxVelocity == -1)//Emergency Stop!
+      emergency_stop_msg.data = true;
+    pub_EmergencyStop.publish(emergency_stop_msg);
+
+    SendLocalPlanningTopics(msg);
+    VisualizeLocalPlanner();
+    LogLocalPlanningInfo(dt);
+
+    // Publish turn_marker
+    visualization_msgs::MarkerArray turn_marker;
+    visualization_msgs::Marker marker;
+    marker.header.frame_id = "map";
+    marker.type = 2;
+    marker.pose.position.x = m_BehaviorGenerator.m_turnWaypoint.pos.x;
+    marker.pose.position.y = m_BehaviorGenerator.m_turnWaypoint.pos.y;
+    marker.pose.position.z = m_BehaviorGenerator.m_turnWaypoint.pos.z;
+    marker.scale.x = 3;
+    marker.scale.y = 3;
+    marker.scale.z = 3;
+    marker.color.r = 0.0f;
+    marker.color.g = 1.0f;
+    marker.color.b = 0.0f;
+    marker.color.a = 1.0f;
+    marker.header.stamp = ros::Time::now();
+    marker.header.frame_id = "map";
+    turn_marker.markers.push_back(marker);
+
+    pub_turnMarker.publish(turn_marker);
+  }
+  else
+    sub_GlobalPlannerPaths = nh.subscribe("/lane_waypoints_array",   1,    &BehaviorGen::callbackGetGlobalPlannerPath,   this);
+
+  rubis::stop_task_profiling(rubis::instance_, 0);
 }
 
 void BehaviorGen::callbackGetV2XTrafficLightSignals(const autoware_msgs::RUBISTrafficSignalArray& msg)
@@ -481,7 +617,7 @@ void BehaviorGen::VisualizeLocalPlanner()
 //  pub_SelectedPathRviz.publish(selected_path);
 }
 
-void BehaviorGen::SendLocalPlanningTopics()
+void BehaviorGen::SendLocalPlanningTopics(const rubis_msgs::LaneArrayWithPoseTwistConstPtr& msg)
 {
   //Send Behavior State
   geometry_msgs::Twist t;
@@ -523,13 +659,23 @@ void BehaviorGen::SendLocalPlanningTopics()
   PlannerHNS::RelativeInfo info;
   PlannerHNS::PlanningHelpers::GetRelativeInfo(m_BehaviorGenerator.m_Path, m_BehaviorGenerator.state, info);
   PlannerHNS::ROSHelpers::ConvertFromLocalLaneToAutowareLane(m_BehaviorGenerator.m_Path, m_CurrentTrajectoryToSend, info.iBack);
-  //std::cout << "Path Size: " << m_BehaviorGenerator.m_Path.size() << ", Send Size: " << m_CurrentTrajectoryToSend << std::endl;
+  //std::cout << "Path Size: " << m_BehaviorGenerator.m_Path.size() << ", Send Size: " << m_CurrentTrajectoryToSend << std::endl;  
 
   closest_waypoint.data = 1;
   pub_ClosestIndex.publish(closest_waypoint);
   pub_LocalBasePath.publish(m_CurrentTrajectoryToSend);
+
+  rubis_msgs::LaneWithPoseTwist final_waypoints_with_pose_twist_msg;
+  final_waypoints_with_pose_twist_msg.instance = rubis::instance_;
+  final_waypoints_with_pose_twist_msg.obj_instance = rubis::obj_instance_;
+  final_waypoints_with_pose_twist_msg.lane = m_CurrentTrajectoryToSend;  
+  final_waypoints_with_pose_twist_msg.pose = msg->pose;
+  final_waypoints_with_pose_twist_msg.twist = msg->twist;
+
+  pub_LocalPathWithPosePub.publish(final_waypoints_with_pose_twist_msg);
   pub_LocalPath.publish(m_CurrentTrajectoryToSend);
-  rubis::sched::task_state_ = TASK_STATE_DONE;
+
+  
 }
 
 void BehaviorGen::LogLocalPlanningInfo(double dt)
@@ -606,195 +752,32 @@ void BehaviorGen::MainLoop()
 {
   ros::NodeHandle private_nh("~");
 
-  timespec planningTimer;
-  UtilityHNS::UtilityH::GetTickCount(planningTimer);
-  std_msgs::Bool emergency_stop_msg;
-
-  // Scheduling Setup
-  int task_scheduling_flag;
-  int task_profiling_flag;
-  std::string task_response_time_filename;
-  int rate;
-  double task_minimum_inter_release_time;
-  double task_execution_time;
-  double task_relative_deadline; 
-
   m_BehaviorGenerator.m_turnThreshold = m_turnThreshold;
-
-m_sprintSwitch = false;
-
-  private_nh.param<int>("/op_behavior_selector/task_scheduling_flag", task_scheduling_flag, 0);
-  private_nh.param<int>("/op_behavior_selector/task_profiling_flag", task_profiling_flag, 0);
-  private_nh.param<std::string>("/op_behavior_selector/task_response_time_filename", task_response_time_filename, "~/Documents/profiling/response_time/op_behavior_selector.csv");
-  private_nh.param<int>("/op_behavior_selector/rate", rate, 10);
-  private_nh.param("/op_behavior_selector/task_minimum_inter_release_time", task_minimum_inter_release_time, (double)10);
-  private_nh.param("/op_behavior_selector/task_execution_time", task_execution_time, (double)10);
-  private_nh.param("/op_behavior_selector/task_relative_deadline", task_relative_deadline, (double)10);
-
-  /* For Task scheduling */
-  if(task_profiling_flag) rubis::sched::init_task_profiling(task_response_time_filename);
-
-  ros::Rate loop_rate(rate);  
-  if(!task_scheduling_flag && !task_profiling_flag) loop_rate = ros::Rate(25);
-
-  struct timespec start_time, end_time;
-
   m_sprintSwitch = false;
 
-  while (ros::ok())
-  {
-    if(task_profiling_flag) rubis::sched::start_task_profiling();
-
-    if(rubis::sched::is_task_ready_ == TASK_READY && rubis::sched::task_state_ == TASK_STATE_READY){
-      if(task_scheduling_flag) rubis::sched::request_task_scheduling(task_minimum_inter_release_time, task_execution_time, task_relative_deadline); 
-      rubis::sched::task_state_ = TASK_STATE_RUNNING;     
-    }
-
-    ros::spinOnce();
-
-    // Check Pedestrian is Appeared
-    double dt  = UtilityHNS::UtilityH::GetTimeDiffNow(planningTimer);
-    UtilityHNS::UtilityH::GetTickCount(planningTimer);
-
-    if(m_MapType == PlannerHNS::MAP_KML_FILE && !bMap)
-    {
-      bMap = true;
-      PlannerHNS::MappingHelpers::LoadKML(m_MapPath, m_Map);
-    }
-    else if (m_MapType == PlannerHNS::MAP_FOLDER && !bMap)
-    {
-      bMap = true;
-      PlannerHNS::MappingHelpers::ConstructRoadNetworkFromDataFiles(m_MapPath, m_Map, true);
-
-    }
-    else if (m_MapType == PlannerHNS::MAP_AUTOWARE && !bMap)
-    {
-      std::vector<UtilityHNS::AisanDataConnFileReader::DataConn> conn_data;;
-
-      if(m_MapRaw.GetVersion()==2)
-      {
-        PlannerHNS::MappingHelpers::ConstructRoadNetworkFromROSMessageV2(m_MapRaw.pLanes->m_data_list, m_MapRaw.pPoints->m_data_list,
-            m_MapRaw.pCenterLines->m_data_list, m_MapRaw.pIntersections->m_data_list,m_MapRaw.pAreas->m_data_list,
-            m_MapRaw.pLines->m_data_list, m_MapRaw.pStopLines->m_data_list,  m_MapRaw.pSignals->m_data_list,
-            m_MapRaw.pVectors->m_data_list, m_MapRaw.pCurbs->m_data_list, m_MapRaw.pRoadedges->m_data_list, m_MapRaw.pWayAreas->m_data_list,
-            m_MapRaw.pCrossWalks->m_data_list, m_MapRaw.pNodes->m_data_list, conn_data,
-            m_MapRaw.pLanes, m_MapRaw.pPoints, m_MapRaw.pNodes, m_MapRaw.pLines, PlannerHNS::GPSPoint(), m_Map, true, m_PlanningParams.enableLaneChange, false);
-
-        try{
-          // Add Traffic Signal Info from yaml file
-          XmlRpc::XmlRpcValue traffic_light_list;
-          nh.getParam("/op_behavior_selector/traffic_light_list", traffic_light_list);
-
-          // Add Stop Line Info from yaml file
-          XmlRpc::XmlRpcValue stop_line_list;
-          nh.getParam("/op_behavior_selector/stop_line_list", stop_line_list);
-
-          // Add Crossing Info from yaml file
-          // XmlRpc::XmlRpcValue intersection_list;
-          // nh.getParam("/op_behavior_selector/intersection_list", intersection_list);
-
-          PlannerHNS::MappingHelpers::ConstructRoadNetwork_RUBIS(m_Map, traffic_light_list, stop_line_list);
-        }
-        catch(XmlRpc::XmlRpcException& e){
-          ROS_ERROR("[XmlRpc Error] %s", e.getMessage().c_str());
-          exit(1);
-        }
-
-        m_BehaviorGenerator.m_Map = m_Map;
-
-        if(m_Map.roadSegments.size() > 0)
-        {
-          bMap = true;
-          std::cout << " ******* Map V2 Is Loaded successfully from the Behavior Selector !! " << std::endl;
-        }
-      }
-      else if(m_MapRaw.GetVersion()==1)
-      {
-        PlannerHNS::MappingHelpers::ConstructRoadNetworkFromROSMessage(m_MapRaw.pLanes->m_data_list, m_MapRaw.pPoints->m_data_list,
-            m_MapRaw.pCenterLines->m_data_list, m_MapRaw.pIntersections->m_data_list,m_MapRaw.pAreas->m_data_list,
-            m_MapRaw.pLines->m_data_list, m_MapRaw.pStopLines->m_data_list,  m_MapRaw.pSignals->m_data_list,
-            m_MapRaw.pVectors->m_data_list, m_MapRaw.pCurbs->m_data_list, m_MapRaw.pRoadedges->m_data_list, m_MapRaw.pWayAreas->m_data_list,
-            m_MapRaw.pCrossWalks->m_data_list, m_MapRaw.pNodes->m_data_list, conn_data,  PlannerHNS::GPSPoint(), m_Map, true, m_PlanningParams.enableLaneChange, false);
-
-        if(m_Map.roadSegments.size() > 0)
-        {
-          bMap = true;
-          std::cout << " ******* Map V1 Is Loaded successfully from the Behavior Selector !! " << std::endl;
-        }
-      }
-    }
-
-    if(bNewCurrentPos && m_GlobalPaths.size()>0)
-    {
-      if(bNewLightSignal)
-      {
-        m_PrevTrafficLight = m_CurrTrafficLight;
-        bNewLightSignal = false;
-      }
-
-      if(bNewLightStatus)
-      {
-        bNewLightStatus = false;
-        for(unsigned int itls = 0 ; itls < m_PrevTrafficLight.size() ; itls++)
-          m_PrevTrafficLight.at(itls).lightState = m_CurrLightStatus;
-      }
-      
-      m_BehaviorGenerator.m_sprintSwitch = m_sprintSwitch;
-      m_CurrentBehavior = m_BehaviorGenerator.DoOneStep(dt, m_CurrentPos, m_VehicleStatus, 1, m_CurrTrafficLight, m_TrajectoryBestCost, 0);
-      std_msgs::Int32 curr_state_msg;
-      curr_state_msg.data = m_CurrentBehavior.state;
-
-      pub_currentState.publish(curr_state_msg);
-
-      CalculateTurnAngle(m_BehaviorGenerator.m_turnWaypoint);
-      m_BehaviorGenerator.m_turnAngle = m_turnAngle;
-
-      std_msgs::Float64 turn_angle_msg;
-      turn_angle_msg.data = m_turnAngle;
-      pub_turnAngle.publish(turn_angle_msg);
-
-      emergency_stop_msg.data = false;
-      if(m_CurrentBehavior.maxVelocity == -1)//Emergency Stop!
-        emergency_stop_msg.data = true;
-      pub_EmergencyStop.publish(emergency_stop_msg);
-
-      SendLocalPlanningTopics();
-      VisualizeLocalPlanner();
-      LogLocalPlanningInfo(dt);
-
-      // Publish turn_marker
-      visualization_msgs::MarkerArray turn_marker;
-      visualization_msgs::Marker marker;
-      marker.header.frame_id = "map";
-      marker.type = 2;
-      marker.pose.position.x = m_BehaviorGenerator.m_turnWaypoint.pos.x;
-      marker.pose.position.y = m_BehaviorGenerator.m_turnWaypoint.pos.y;
-      marker.pose.position.z = m_BehaviorGenerator.m_turnWaypoint.pos.z;
-      marker.scale.x = 3;
-      marker.scale.y = 3;
-      marker.scale.z = 3;
-      marker.color.r = 0.0f;
-      marker.color.g = 1.0f;
-      marker.color.b = 0.0f;
-      marker.color.a = 1.0f;
-      marker.header.stamp = ros::Time::now();
-      marker.header.frame_id = "map";
-      turn_marker.markers.push_back(marker);
-
-      pub_turnMarker.publish(turn_marker);
-    }
-    else
-      sub_GlobalPlannerPaths = nh.subscribe("/lane_waypoints_array",   1,    &BehaviorGen::callbackGetGlobalPlannerPath,   this);
-
-    if(task_profiling_flag) rubis::sched::stop_task_profiling(0, rubis::sched::task_state_);
-
-    if(rubis::sched::is_task_ready_ == TASK_READY && rubis::sched::task_state_ == TASK_STATE_DONE){
-      if(task_scheduling_flag) rubis::sched::yield_task_scheduling();
-      rubis::sched::task_state_ = TASK_STATE_READY;
-    }
+  // Scheduling & Profiling Setup
+  std::string node_name = ros::this_node::getName();
+  std::string task_response_time_filename;
+  private_nh.param<std::string>(node_name+"/task_response_time_filename", task_response_time_filename, "~/Documents/profiling/response_time/op_behavior_selector.csv");
 
-    loop_rate.sleep();
-  }
+  int rate;
+  private_nh.param<int>(node_name+"/rate", rate, 10);
+
+  struct rubis::sched_attr attr;
+  std::string policy;
+  int priority, exec_time ,deadline, period;
+    
+  private_nh.param(node_name+"/task_scheduling_configs/policy", policy, std::string("NONE"));    
+  private_nh.param(node_name+"/task_scheduling_configs/priority", priority, 99);
+  private_nh.param(node_name+"/task_scheduling_configs/exec_time", exec_time, 0);
+  private_nh.param(node_name+"/task_scheduling_configs/deadline", deadline, 0);
+  private_nh.param(node_name+"/task_scheduling_configs/period", period, 0);
+  attr = rubis::create_sched_attr(priority, exec_time, deadline, period);    
+  rubis::init_task_scheduling(policy, attr);
+
+  rubis::init_task_profiling(task_response_time_filename);
+
+  ros::spin();
 }
 
 bool BehaviorGen::GetBaseMapTF(){
diff --git a/autoware.ai/src/autoware/core_planning/op_local_planner/nodes/op_behavior_selector/op_behavior_selector_core.mainloop.cpp b/autoware.ai/src/autoware/core_planning/op_local_planner/nodes/op_behavior_selector/op_behavior_selector_core.mainloop.cpp
new file mode 100644
index 00000000..250edb07
--- /dev/null
+++ b/autoware.ai/src/autoware/core_planning/op_local_planner/nodes/op_behavior_selector/op_behavior_selector_core.mainloop.cpp
@@ -0,0 +1,905 @@
+/*
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "op_behavior_selector_core.h"
+#include "op_ros_helpers/op_ROSHelpers.h"
+#include "op_planner/MappingHelpers.h"
+#include <rubis_lib/sched.hpp>
+
+namespace BehaviorGeneratorNS
+{
+
+BehaviorGen::BehaviorGen()
+{
+  sleep(2);
+  bNewCurrentPos = false;
+  bVehicleStatus = false;
+  bWayGlobalPath = false;
+  bWayGlobalPathLogs = false;
+  bNewLightStatus = false;
+  bNewLightSignal = false;
+  bBestCost = false;
+  bMap = false;
+  bRollOuts = false;
+  UtilityHNS::UtilityH::GetTickCount(planningTimer);
+
+  ros::NodeHandle _nh;
+  UpdatePlanningParams(_nh);
+
+  // RUBIS driving parameter
+  nh.getParam("/op_behavior_selector/distanceToPedestrianThreshold", m_distanceToPedestrianThreshold);
+  nh.param("/op_behavior_selector/turnThreshold", m_turnThreshold, 20.0);
+
+
+  tf::StampedTransform transform;
+  PlannerHNS::ROSHelpers::GetTransformFromTF("map", "world", transform);
+  m_OriginPos.position.x  = transform.getOrigin().x();
+  m_OriginPos.position.y  = transform.getOrigin().y();
+  m_OriginPos.position.z  = transform.getOrigin().z();
+
+  pub_LocalPath = nh.advertise<autoware_msgs::Lane>("final_waypoints", 1,true);
+  pub_LocalPathWithPosePub = nh.advertise<rubis_msgs::LaneWithPoseTwist>("final_waypoints_with_pose_twist", 1,true);
+  pub_LocalBasePath = nh.advertise<autoware_msgs::Lane>("base_waypoints", 1,true);
+  pub_ClosestIndex = nh.advertise<std_msgs::Int32>("closest_waypoint", 1,true);
+  pub_BehaviorState = nh.advertise<geometry_msgs::TwistStamped>("current_behavior", 1);
+  pub_SimuBoxPose    = nh.advertise<geometry_msgs::PoseArray>("sim_box_pose_ego", 1);
+  pub_BehaviorStateRviz = nh.advertise<visualization_msgs::MarkerArray>("behavior_state", 1);
+  pub_SelectedPathRviz = nh.advertise<visualization_msgs::MarkerArray>("local_selected_trajectory_rviz", 1);
+  pub_EmergencyStop = nh.advertise<std_msgs::Bool>("emergency_stop", 1);
+  pub_turnAngle = nh.advertise<std_msgs::Float64>("turn_angle", 1);
+  pub_turnMarker = nh.advertise<visualization_msgs::MarkerArray>("turn_marker", 1);
+  pub_currentState = nh.advertise<std_msgs::Int32>("current_state", 1);
+
+  int bVelSource = 1;
+  _nh.getParam("/op_trajectory_evaluator/velocitySource", bVelSource);
+  if(bVelSource == 0)
+    sub_robot_odom = nh.subscribe("/odom", 10, &BehaviorGen::callbackGetRobotOdom, this);
+  else if(bVelSource == 2)
+    sub_can_info = nh.subscribe("/can_info", 10, &BehaviorGen::callbackGetCANInfo, this);
+
+  sub_GlobalPlannerPaths = nh.subscribe("/lane_waypoints_array", 1, &BehaviorGen::callbackGetGlobalPlannerPath, this);
+  sub_LocalPlannerPaths = nh.subscribe("/local_weighted_trajectories_with_pose_twist", 1, &BehaviorGen::callbackGetLocalPlannerPath, this);
+  // sub_TrafficLightStatus = nh.subscribe("/light_color", 1, &BehaviorGen::callbackGetTrafficLightStatus, this);
+  // sub_TrafficLightSignals  = nh.subscribe("/roi_signal", 1, &BehaviorGen::callbackGetTrafficLightSignals, this);
+  sub_Trajectory_Cost = nh.subscribe("/local_trajectory_cost", 1, &BehaviorGen::callbackGetLocalTrajectoryCost, this);
+
+  sub_TrafficLightSignals  = nh.subscribe("/v2x_traffic_signal", 1, &BehaviorGen::callbackGetV2XTrafficLightSignals, this);
+
+  sub_twist_raw = nh.subscribe("/twist_raw", 1, &BehaviorGen::callbackGetTwistRaw, this);
+  sub_twist_cmd = nh.subscribe("/twist_cmd", 1, &BehaviorGen::callbackGetTwistCMD, this);
+  //sub_ctrl_cmd = nh.subscribe("/ctrl_cmd", 1, &BehaviorGen::callbackGetCommandCMD, this);
+  sub_DistanceToPedestrian = nh.subscribe("/distance_to_pedestrian", 1, &BehaviorGen::callbackDistanceToPedestrian, this);
+  sub_IntersectionCondition = nh.subscribe("/intersection_condition", 1, &BehaviorGen::callbackIntersectionCondition, this);
+  sub_SprintSwitch = nh.subscribe("/sprint_switch", 1, &BehaviorGen::callbackSprintSwitch, this);
+
+  //Mapping Section
+  sub_lanes = nh.subscribe("/vector_map_info/lane", 1, &BehaviorGen::callbackGetVMLanes,  this);
+  sub_points = nh.subscribe("/vector_map_info/point", 1, &BehaviorGen::callbackGetVMPoints,  this);
+  sub_dt_lanes = nh.subscribe("/vector_map_info/dtlane", 1, &BehaviorGen::callbackGetVMdtLanes,  this);
+  sub_intersect = nh.subscribe("/vector_map_info/cross_road", 1, &BehaviorGen::callbackGetVMIntersections,  this);
+  sup_area = nh.subscribe("/vector_map_info/area", 1, &BehaviorGen::callbackGetVMAreas,  this);
+  sub_lines = nh.subscribe("/vector_map_info/line", 1, &BehaviorGen::callbackGetVMLines,  this);
+  sub_stop_line = nh.subscribe("/vector_map_info/stop_line", 1, &BehaviorGen::callbackGetVMStopLines,  this);
+  sub_signals = nh.subscribe("/vector_map_info/signal", 1, &BehaviorGen::callbackGetVMSignal,  this);
+  sub_vectors = nh.subscribe("/vector_map_info/vector", 1, &BehaviorGen::callbackGetVMVectors,  this);
+  sub_curbs = nh.subscribe("/vector_map_info/curb", 1, &BehaviorGen::callbackGetVMCurbs,  this);
+  sub_edges = nh.subscribe("/vector_map_info/road_edge", 1, &BehaviorGen::callbackGetVMRoadEdges,  this);
+  sub_way_areas = nh.subscribe("/vector_map_info/way_area", 1, &BehaviorGen::callbackGetVMWayAreas,  this);
+  sub_cross_walk = nh.subscribe("/vector_map_info/cross_walk", 1, &BehaviorGen::callbackGetVMCrossWalks,  this);
+  sub_nodes = nh.subscribe("/vector_map_info/node", 1, &BehaviorGen::callbackGetVMNodes,  this);
+}
+
+BehaviorGen::~BehaviorGen()
+{
+  UtilityHNS::DataRW::WriteLogData(UtilityHNS::UtilityH::GetHomeDirectory()+UtilityHNS::DataRW::LoggingMainfolderName+UtilityHNS::DataRW::StatesLogFolderName, "MainLog",
+        "time,dt, Behavior_i, Behavior_str, RollOuts_n, Blocked_i, Central_i, Selected_i, StopSign_id, Light_id, Stop_Dist, Follow_Dist, Follow_Vel,"
+        "Target_Vel, PID_Vel, T_cmd_Vel, C_cmd_Vel, Vel, Steer, X, Y, Z, Theta,"
+        , m_LogData);
+}
+
+void BehaviorGen::UpdatePlanningParams(ros::NodeHandle& _nh)
+{
+  _nh.getParam("/op_common_params/enableSwerving", m_PlanningParams.enableSwerving);
+  if(m_PlanningParams.enableSwerving)
+    m_PlanningParams.enableFollowing = true;
+  else
+    _nh.getParam("/op_common_params/enableFollowing", m_PlanningParams.enableFollowing);
+
+  _nh.getParam("/op_common_params/enableTrafficLightBehavior", m_PlanningParams.enableTrafficLightBehavior);
+  _nh.getParam("/op_common_params/enableStopSignBehavior", m_PlanningParams.enableStopSignBehavior);
+
+  _nh.getParam("/op_common_params/maxVelocity", m_PlanningParams.maxSpeed);
+  _nh.getParam("/op_common_params/minVelocity", m_PlanningParams.minSpeed);
+  _nh.getParam("/op_common_params/maxLocalPlanDistance", m_PlanningParams.microPlanDistance);
+
+  _nh.getParam("/op_common_params/pathDensity", m_PlanningParams.pathDensity);
+
+  _nh.getParam("/op_common_params/rollOutDensity", m_PlanningParams.rollOutDensity);
+  if(m_PlanningParams.enableSwerving)
+    _nh.getParam("/op_common_params/rollOutsNumber", m_PlanningParams.rollOutNumber);
+  else
+    m_PlanningParams.rollOutNumber = 0;
+
+  _nh.getParam("/op_common_params/horizonDistance", m_PlanningParams.horizonDistance);
+  _nh.getParam("/op_common_params/minFollowingDistance", m_PlanningParams.minFollowingDistance);
+  _nh.getParam("/op_common_params/minDistanceToAvoid", m_PlanningParams.minDistanceToAvoid);
+  _nh.getParam("/op_common_params/maxDistanceToAvoid", m_PlanningParams.maxDistanceToAvoid);
+  _nh.getParam("/op_common_params/speedProfileFactor", m_PlanningParams.speedProfileFactor);
+
+  _nh.getParam("/op_trajectory_evaluator/horizontalSafetyDistance", m_PlanningParams.horizontalSafetyDistancel);
+  _nh.getParam("/op_trajectory_evaluator/verticalSafetyDistance", m_PlanningParams.verticalSafetyDistance);
+
+  _nh.getParam("/op_common_params/enableLaneChange", m_PlanningParams.enableLaneChange);
+
+  _nh.getParam("/op_common_params/width", m_CarInfo.width);
+  _nh.getParam("/op_common_params/length", m_CarInfo.length);
+  _nh.getParam("/op_common_params/wheelBaseLength", m_CarInfo.wheel_base);
+  _nh.getParam("/op_common_params/turningRadius", m_CarInfo.turning_radius);
+  _nh.getParam("/op_common_params/maxSteerAngle", m_CarInfo.max_steer_angle);
+  _nh.getParam("/op_common_params/maxAcceleration", m_CarInfo.max_acceleration);
+  _nh.getParam("/op_common_params/maxDeceleration", m_CarInfo.max_deceleration);
+  m_CarInfo.max_speed_forward = m_PlanningParams.maxSpeed;
+  m_CarInfo.min_speed_forward = m_PlanningParams.minSpeed;
+
+  _nh.getParam("/op_common_params/stopLineMargin", m_PlanningParams.stopLineMargin);
+  _nh.getParam("/op_common_params/stopLineDetectionDistance", m_PlanningParams.stopLineDetectionDistance);
+
+  PlannerHNS::ControllerParams controlParams;
+  controlParams.Steering_Gain = PlannerHNS::PID_CONST(0.07, 0.02, 0.01);
+  controlParams.Velocity_Gain = PlannerHNS::PID_CONST(0.1, 0.005, 0.1);
+  nh.getParam("/op_common_params/steeringDelay", controlParams.SteeringDelay);
+  nh.getParam("/op_common_params/minPursuiteDistance", controlParams.minPursuiteDistance );
+  nh.getParam("/op_common_params/additionalBrakingDistance", m_PlanningParams.additionalBrakingDistance );
+  nh.getParam("/op_common_params/giveUpDistance", m_PlanningParams.giveUpDistance );
+  nh.getParam("/op_common_params/enableSlowDownOnCurve", m_PlanningParams.enableSlowDownOnCurve );
+  nh.getParam("/op_common_params/curveVelocityRatio", m_PlanningParams.curveVelocityRatio );
+
+  int iSource = 0;
+  _nh.getParam("/op_common_params/mapSource" , iSource);
+  if(iSource == 0)
+    m_MapType = PlannerHNS::MAP_AUTOWARE;
+  else if (iSource == 1)
+    m_MapType = PlannerHNS::MAP_FOLDER;
+  else if(iSource == 2)
+    m_MapType = PlannerHNS::MAP_KML_FILE;
+
+  _nh.getParam("/op_common_params/mapFileName" , m_MapPath);
+
+  _nh.getParam("/op_behavior_selector/evidence_tust_number", m_PlanningParams.nReliableCount);
+
+  //std::cout << "nReliableCount: " << m_PlanningParams.nReliableCount << std::endl;
+  
+  _nh.param("/op_behavior_selector/sprintSpeed", m_sprintSpeed, 13.5);
+  _nh.param("/op_behavior_selector/obstacleWaitingTimeinIntersection", m_obstacleWaitingTimeinIntersection, 1.0);
+
+  m_BehaviorGenerator.Init(controlParams, m_PlanningParams, m_CarInfo, m_sprintSpeed);  
+
+  m_BehaviorGenerator.m_pCurrentBehaviorState->m_Behavior = PlannerHNS::INITIAL_STATE;
+  
+  m_BehaviorGenerator.m_obstacleWaitingTimeinIntersection = m_obstacleWaitingTimeinIntersection;
+}
+
+void BehaviorGen::callbackDistanceToPedestrian(const std_msgs::Float64& msg){
+  double distance = msg.data;
+  if(distance < m_distanceToPedestrianThreshold){
+    m_PlanningParams.pedestrianAppearence = true;
+  }
+  else
+  {
+    m_PlanningParams.pedestrianAppearence = false;
+  }
+  m_BehaviorGenerator.UpdatePedestrianAppearence(m_PlanningParams.pedestrianAppearence);
+  // m_BehaviorGenerator.printPedestrianAppearence();
+}
+
+void BehaviorGen::callbackIntersectionCondition(const autoware_msgs::IntersectionCondition& msg){
+  m_BehaviorGenerator.m_isInsideIntersection = msg.isIntersection;
+  m_BehaviorGenerator.m_closestIntersectionDistance = msg.intersectionDistance;
+  m_BehaviorGenerator.m_riskyLeft = msg.riskyLeftTurn;
+  m_BehaviorGenerator.m_riskyRight = msg.riskyRightTurn;
+}
+
+void BehaviorGen::callbackSprintSwitch(const std_msgs::Bool& msg){
+  m_sprintSwitch = msg.data;
+}
+
+void BehaviorGen::callbackGetTwistRaw(const geometry_msgs::TwistStampedConstPtr& msg)
+{
+  m_Twist_raw = *msg;
+}
+
+void BehaviorGen::callbackGetTwistCMD(const geometry_msgs::TwistStampedConstPtr& msg)
+{
+  m_Twist_cmd = *msg;
+}
+
+void BehaviorGen::callbackGetCommandCMD(const autoware_msgs::ControlCommandConstPtr& msg)
+{
+  m_Ctrl_cmd = *msg;
+}
+
+void BehaviorGen::callbackGetCANInfo(const autoware_can_msgs::CANInfoConstPtr &msg)
+{
+  m_VehicleStatus.speed = msg->speed/3.6;
+  m_CurrentPos.v = m_VehicleStatus.speed;
+  m_VehicleStatus.steer = msg->angle * m_CarInfo.max_steer_angle / m_CarInfo.max_steer_value;
+  UtilityHNS::UtilityH::GetTickCount(m_VehicleStatus.tStamp);
+  bVehicleStatus = true;
+}
+
+void BehaviorGen::callbackGetRobotOdom(const nav_msgs::OdometryConstPtr& msg)
+{
+  m_VehicleStatus.speed = msg->twist.twist.linear.x;
+  m_CurrentPos.v = m_VehicleStatus.speed ;
+  if(msg->twist.twist.linear.x != 0)
+    m_VehicleStatus.steer += atan(m_CarInfo.wheel_base * msg->twist.twist.angular.z/msg->twist.twist.linear.x);
+  UtilityHNS::UtilityH::GetTickCount(m_VehicleStatus.tStamp);
+  bVehicleStatus = true;
+}
+
+void BehaviorGen::callbackGetGlobalPlannerPath(const autoware_msgs::LaneArrayConstPtr& msg)
+{
+  if(msg->lanes.size() > 0 && bMap)
+  {
+
+    bool bOldGlobalPath = m_GlobalPaths.size() == msg->lanes.size();
+
+    m_GlobalPaths.clear();
+
+    for(unsigned int i = 0 ; i < msg->lanes.size(); i++)
+    {
+      PlannerHNS::ROSHelpers::ConvertFromAutowareLaneToLocalLane(msg->lanes.at(i), m_temp_path);
+      PlannerHNS::Lane* pPrevValid = 0;
+      for(unsigned int j = 0 ; j < m_temp_path.size(); j++)
+      {
+        PlannerHNS::Lane* pLane = 0;
+        pLane = PlannerHNS::MappingHelpers::GetLaneById(m_temp_path.at(j).laneId, m_Map);
+        if(!pLane)
+        {
+          pLane = PlannerHNS::MappingHelpers::GetClosestLaneFromMapDirectionBased(m_temp_path.at(j), m_Map, 1);
+
+          if(!pLane && !pPrevValid)
+          {
+            ROS_ERROR("Map inconsistency between Global Path and Local Planer Map, Can't identify current lane.");
+            return;
+          }
+
+          if(!pLane)
+            m_temp_path.at(j).pLane = pPrevValid;
+          else
+          {
+            m_temp_path.at(j).pLane = pLane;
+            pPrevValid = pLane ;
+          }
+
+          m_temp_path.at(j).laneId = m_temp_path.at(j).pLane->id;
+        }
+        else
+          m_temp_path.at(j).pLane = pLane;
+
+
+        //std::cout << "StopLineInGlobalPath: " << m_temp_path.at(j).stopLineID << std::endl;
+      }
+
+      PlannerHNS::PlanningHelpers::CalcAngleAndCost(m_temp_path);
+      m_GlobalPaths.push_back(m_temp_path);
+
+      if(bOldGlobalPath)
+      {
+        bOldGlobalPath = PlannerHNS::PlanningHelpers::CompareTrajectories(m_temp_path, m_GlobalPaths.at(i));
+      }
+    }
+
+    if(!bOldGlobalPath)
+    {
+      bWayGlobalPath = true;
+      bWayGlobalPathLogs = true;
+      for(unsigned int i = 0; i < m_GlobalPaths.size(); i++)
+      {
+        PlannerHNS::PlanningHelpers::FixPathDensity(m_GlobalPaths.at(i), m_PlanningParams.pathDensity);
+        PlannerHNS::PlanningHelpers::SmoothPath(m_GlobalPaths.at(i), 0.35, 0.4, 0.05);
+
+        PlannerHNS::PlanningHelpers::GenerateRecommendedSpeed(m_GlobalPaths.at(i), m_CarInfo.max_speed_forward, m_PlanningParams.speedProfileFactor);
+        m_GlobalPaths.at(i).at(m_GlobalPaths.at(i).size()-1).v = 0;
+      }
+
+      std::cout << "Received New Global Path Selector! " << std::endl;
+    }
+    else
+    {
+      m_GlobalPaths.clear();
+    }
+  }
+}
+
+void BehaviorGen::callbackGetLocalTrajectoryCost(const autoware_msgs::LaneConstPtr& msg)
+{
+  if(m_BehaviorGenerator.m_pCurrentBehaviorState->m_Behavior == PlannerHNS::INTERSECTION_STATE){
+    bBestCost = true;
+    m_TrajectoryBestCost.closest_obj_distance = msg->closest_object_distance;
+    m_TrajectoryBestCost.closest_obj_velocity = msg->closest_object_velocity;
+    return;
+  }
+  bBestCost = true;
+  m_TrajectoryBestCost.bBlocked = msg->is_blocked;
+  m_TrajectoryBestCost.index = msg->lane_index;
+  m_TrajectoryBestCost.cost = msg->cost;
+  m_TrajectoryBestCost.closest_obj_distance = msg->closest_object_distance;
+  m_TrajectoryBestCost.closest_obj_velocity = msg->closest_object_velocity;
+}
+
+void BehaviorGen::callbackGetLocalPlannerPath(const rubis_msgs::LaneArrayWithPoseTwistConstPtr& msg)
+{  
+  rubis::instance_ = msg->instance;
+  lane_array_with_pose_twist_msg_ = msg;
+
+  // Callback
+  m_VehicleStatus.speed = msg->twist.twist.linear.x;
+  m_CurrentPos.v = m_VehicleStatus.speed;
+  if(fabs(msg->twist.twist.linear.x) > 0.25)
+    m_VehicleStatus.steer = atan(m_CarInfo.wheel_base * msg->twist.twist.angular.z/msg->twist.twist.linear.x);
+  UtilityHNS::UtilityH::GetTickCount(m_VehicleStatus.tStamp);
+  bVehicleStatus = true;
+
+  m_CurrentPos = PlannerHNS::WayPoint(msg->pose.pose.position.x, msg->pose.pose.position.y, msg->pose.pose.position.z, tf::getYaw(msg->pose.pose.orientation));
+  bNewCurrentPos = true;
+
+  if(msg->lane_array.lanes.size() > 0)
+  {
+    m_RollOuts.clear();
+    int globalPathId_roll_outs = -1;
+
+    for(unsigned int i = 0 ; i < msg->lane_array.lanes.size(); i++)
+    {
+      std::vector<PlannerHNS::WayPoint> path;
+      PlannerHNS::ROSHelpers::ConvertFromAutowareLaneToLocalLane(msg->lane_array.lanes.at(i), path);
+      m_RollOuts.push_back(path);
+
+      if(path.size() > 0)
+        globalPathId_roll_outs = path.at(0).gid;
+    }
+
+    if(bWayGlobalPath && m_GlobalPaths.size() > 0)
+    {
+      if(m_GlobalPaths.at(0).size() > 0)
+      {
+        int globalPathId = m_GlobalPaths.at(0).at(0).gid;
+        std::cout << "Before Synchronization At Behavior Selector: GlobalID: " <<  globalPathId << ", LocalID: " << globalPathId_roll_outs << std::endl;
+
+        if(globalPathId_roll_outs == globalPathId)
+        {
+          bWayGlobalPath = false;
+          m_GlobalPathsToUse = m_GlobalPaths;
+          m_BehaviorGenerator.SetNewGlobalPath(m_GlobalPathsToUse);
+          std::cout << "Synchronization At Behavior Selector: GlobalID: " <<  globalPathId << ", LocalID: " << globalPathId_roll_outs << std::endl;
+        }
+      }
+    }
+
+    m_BehaviorGenerator.m_RollOuts = m_RollOuts;
+    bRollOuts = true;
+  }
+}
+
+void BehaviorGen::callbackGetV2XTrafficLightSignals(const autoware_msgs::RUBISTrafficSignalArray& msg)
+{
+  bNewLightSignal = true;
+  std::vector<PlannerHNS::TrafficLight> simulatedLights;
+  for(unsigned int i = 0 ; i < msg.signals.size() ; i++)
+  {
+    PlannerHNS::TrafficLight tl;
+    tl.id = msg.signals.at(i).id;
+    tl.remainTime = msg.signals.at(i).time;
+
+    for(unsigned int k = 0; k < m_Map.trafficLights.size(); k++)
+    {
+      if(m_Map.trafficLights.at(k).id == tl.id)
+      {
+        tl.pos = m_Map.trafficLights.at(k).pos;
+        tl.routine = m_Map.trafficLights.at(k).routine;
+        break;
+      }
+    }
+
+    if(msg.signals.at(i).type == 0)
+    {
+      tl.lightState = PlannerHNS::RED_LIGHT;
+    }
+    else if(msg.signals.at(i).type == 1)
+    {
+      tl.lightState = PlannerHNS::YELLOW_LIGHT;
+    }
+    else
+    {
+      tl.lightState = PlannerHNS::GREEN_LIGHT;
+    }
+
+    simulatedLights.push_back(tl);
+  }
+
+  m_CurrTrafficLight = simulatedLights;
+}
+
+void BehaviorGen::VisualizeLocalPlanner()
+{
+  visualization_msgs::Marker behavior_rviz;
+  int iDirection = 0;
+  if(m_BehaviorGenerator.m_pCurrentBehaviorState->GetCalcParams()->iCurrSafeTrajectory > m_BehaviorGenerator.m_pCurrentBehaviorState->GetCalcParams()->iCentralTrajectory)
+    iDirection = 1;
+  else if(m_BehaviorGenerator.m_pCurrentBehaviorState->GetCalcParams()->iCurrSafeTrajectory < m_BehaviorGenerator.m_pCurrentBehaviorState->GetCalcParams()->iCentralTrajectory)
+    iDirection = -1;
+  PlannerHNS::ROSHelpers::VisualizeBehaviorState(m_CurrentPos, m_CurrentBehavior, !m_BehaviorGenerator.m_pCurrentBehaviorState->GetCalcParams()->bTrafficIsRed , iDirection, behavior_rviz, "beh_state");
+  //pub_BehaviorStateRviz.publish(behavior_rviz);
+
+  visualization_msgs::MarkerArray markerArray;
+
+  //PlannerHNS::ROSHelpers::GetIndicatorArrows(m_CurrentPos, m_CarInfo.width, m_CarInfo.length, m_CurrentBehavior.indicator, 0, markerArray);
+
+  markerArray.markers.push_back(behavior_rviz);
+
+  pub_BehaviorStateRviz.publish(markerArray);
+
+  //To Test Synchronization Problem
+//  visualization_msgs::MarkerArray selected_path;
+//  std::vector<std::vector<std::vector<PlannerHNS::WayPoint> > > paths;
+//  paths.push_back(std::vector<std::vector<PlannerHNS::WayPoint> >());
+//  paths.at(0).push_back(m_BehaviorGenerator.m_Path);
+//  paths.push_back(m_GlobalPathsToUse);
+//  paths.push_back(m_RollOuts);
+//  PlannerHNS::ROSHelpers::TrajectoriesToMarkers(paths, selected_path);
+//  pub_SelectedPathRviz.publish(selected_path);
+}
+
+void BehaviorGen::SendLocalPlanningTopics(const rubis_msgs::LaneArrayWithPoseTwistConstPtr& msg)
+{
+  //Send Behavior State
+  geometry_msgs::Twist t;
+  geometry_msgs::TwistStamped behavior;
+  t.linear.x = m_CurrentBehavior.bNewPlan;
+  t.linear.y = m_CurrentBehavior.followDistance;
+  t.linear.z = m_CurrentBehavior.followVelocity;
+  t.angular.x = (int)m_CurrentBehavior.indicator;
+  t.angular.y = (int)m_CurrentBehavior.state;
+  t.angular.z = m_CurrentBehavior.iTrajectory;
+  behavior.twist = t;
+  behavior.header.stamp = ros::Time::now();
+  pub_BehaviorState.publish(behavior);
+
+  //Send Ego Vehicle Simulation Pose Data
+  geometry_msgs::PoseArray sim_data;
+  geometry_msgs::Pose p_id, p_pose, p_box;
+
+  sim_data.header.frame_id = "map";
+  sim_data.header.stamp = ros::Time();
+  p_id.position.x = 0;
+  p_pose.orientation = tf::createQuaternionMsgFromRollPitchYaw(0, 0, UtilityHNS::UtilityH::SplitPositiveAngle(m_BehaviorGenerator.state.pos.a));
+
+  PlannerHNS::WayPoint pose_center = PlannerHNS::PlanningHelpers::GetRealCenter(m_BehaviorGenerator.state, m_CarInfo.wheel_base);
+
+  p_pose.position.x = pose_center.pos.x;
+  p_pose.position.y = pose_center.pos.y;
+  p_pose.position.z = pose_center.pos.z;
+  p_box.position.x = m_BehaviorGenerator.m_CarInfo.width;
+  p_box.position.y = m_BehaviorGenerator.m_CarInfo.length;
+  p_box.position.z = 2.2;
+  sim_data.poses.push_back(p_id);
+  sim_data.poses.push_back(p_pose);
+  sim_data.poses.push_back(p_box);
+  pub_SimuBoxPose.publish(sim_data);
+
+  //Send Trajectory Data to path following nodes
+  std_msgs::Int32 closest_waypoint;
+  PlannerHNS::RelativeInfo info;
+  PlannerHNS::PlanningHelpers::GetRelativeInfo(m_BehaviorGenerator.m_Path, m_BehaviorGenerator.state, info);
+  PlannerHNS::ROSHelpers::ConvertFromLocalLaneToAutowareLane(m_BehaviorGenerator.m_Path, m_CurrentTrajectoryToSend, info.iBack);
+  //std::cout << "Path Size: " << m_BehaviorGenerator.m_Path.size() << ", Send Size: " << m_CurrentTrajectoryToSend << std::endl;  
+
+  closest_waypoint.data = 1;
+  pub_ClosestIndex.publish(closest_waypoint);
+  pub_LocalBasePath.publish(m_CurrentTrajectoryToSend);
+
+  rubis_msgs::LaneWithPoseTwist final_waypoints_with_pose_twist_msg;
+  final_waypoints_with_pose_twist_msg.instance = rubis::instance_;
+  final_waypoints_with_pose_twist_msg.lane = m_CurrentTrajectoryToSend;  
+  final_waypoints_with_pose_twist_msg.pose = msg->pose;
+  final_waypoints_with_pose_twist_msg.twist = msg->twist;
+
+  pub_LocalPathWithPosePub.publish(final_waypoints_with_pose_twist_msg);
+  pub_LocalPath.publish(m_CurrentTrajectoryToSend);
+
+  
+}
+
+void BehaviorGen::LogLocalPlanningInfo(double dt)
+{
+  timespec log_t;
+  UtilityHNS::UtilityH::GetTickCount(log_t);
+  std::ostringstream dataLine;
+  dataLine << UtilityHNS::UtilityH::GetLongTime(log_t) <<"," << dt << "," << m_CurrentBehavior.state << ","<< PlannerHNS::ROSHelpers::GetBehaviorNameFromCode(m_CurrentBehavior.state) << "," <<
+      m_BehaviorGenerator.m_pCurrentBehaviorState->m_pParams->rollOutNumber << "," <<
+      m_BehaviorGenerator.m_pCurrentBehaviorState->GetCalcParams()->bFullyBlock << "," <<
+      m_BehaviorGenerator.m_pCurrentBehaviorState->GetCalcParams()->iCentralTrajectory << "," <<
+      m_BehaviorGenerator.m_pCurrentBehaviorState->GetCalcParams()->iCurrSafeTrajectory << "," <<
+      m_BehaviorGenerator.m_pCurrentBehaviorState->GetCalcParams()->currentStopSignID << "," <<
+      m_BehaviorGenerator.m_pCurrentBehaviorState->GetCalcParams()->currentTrafficLightID << "," <<
+      m_BehaviorGenerator.m_pCurrentBehaviorState->GetCalcParams()->minStoppingDistance << "," <<
+      m_BehaviorGenerator.m_pCurrentBehaviorState->GetCalcParams()->distanceToNext << "," <<
+      m_BehaviorGenerator.m_pCurrentBehaviorState->GetCalcParams()->velocityOfNext << "," <<
+      m_CurrentBehavior.maxVelocity << "," <<
+      m_Twist_raw.twist.linear.x << "," <<
+      m_Twist_cmd.twist.linear.x << "," <<
+      m_Ctrl_cmd.linear_velocity << "," <<
+      m_VehicleStatus.speed << "," <<
+      m_VehicleStatus.steer << "," <<
+      m_BehaviorGenerator.state.pos.x << "," << m_BehaviorGenerator.state.pos.y << "," << m_BehaviorGenerator.state.pos.z << "," << UtilityHNS::UtilityH::SplitPositiveAngle(m_BehaviorGenerator.state.pos.a)+M_PI << ",";
+  m_LogData.push_back(dataLine.str());
+
+
+  if(bWayGlobalPathLogs)
+  {
+    for(unsigned int i=0; i < m_GlobalPaths.size(); i++)
+    {
+      std::ostringstream str_out;
+      str_out << UtilityHNS::UtilityH::GetHomeDirectory();
+      str_out << UtilityHNS::DataRW::LoggingMainfolderName;
+      str_out << UtilityHNS::DataRW::PathLogFolderName;
+      str_out << "Global_Vel";
+      str_out << i;
+      str_out << "_";
+      PlannerHNS::PlanningHelpers::WritePathToFile(str_out.str(), m_GlobalPaths.at(i));
+    }
+    bWayGlobalPathLogs = false;
+  }
+}
+
+void BehaviorGen::CalculateTurnAngle(PlannerHNS::WayPoint turn_point){
+  geometry_msgs::PoseStamped turn_pose;
+
+  if(GetBaseMapTF()){
+    // std::cout<<"BEFORE:"<<turn_point.pos.x<<" "<<turn_point.pos.y<<" "<<turn_point.rot.x<<" "<<turn_point.rot.y<<" "<<turn_point.rot.z<<std::endl;
+    turn_pose.pose.position.x = turn_point.pos.x;
+    turn_pose.pose.position.y = turn_point.pos.y;
+    turn_pose.pose.position.z = turn_point.pos.z;
+    turn_pose.pose.orientation.x = turn_point.rot.x;
+    turn_pose.pose.orientation.y = turn_point.rot.y;
+    turn_pose.pose.orientation.z = turn_point.rot.z;
+    turn_pose.pose.orientation.w = turn_point.rot.w;
+    TransformPose(turn_pose, turn_pose, m_map_base_transform);
+    // std::cout<<"AFTER:"<<turn_pose.pose.position.x<<" "<<turn_pose.pose.position.y<<" "<<turn_pose.pose.orientation.x<<" "<<turn_pose.pose.orientation.y<<" "<<turn_pose.pose.orientation.z<<std::endl;
+
+    double hypot_length = hypot(turn_pose.pose.position.x, turn_pose.pose.position.y);
+
+    if(hypot_length <= 0)
+      m_turnAngle = 0;
+    else
+      m_turnAngle = acos(abs(turn_pose.pose.position.x)/hypot_length)*180.0/PI;
+    if(turn_pose.pose.position.y < 0)
+      m_turnAngle = -1 * m_turnAngle;
+  }
+
+  return;
+}
+
+void BehaviorGen::MainLoop()
+{
+  ros::NodeHandle private_nh("~");
+
+  // Scheduling Setup
+  std::string task_response_time_filename;
+  int rate;
+  double task_minimum_inter_release_time;
+  double task_execution_time;
+  double task_relative_deadline; 
+
+  m_BehaviorGenerator.m_turnThreshold = m_turnThreshold;
+
+  m_sprintSwitch = false;
+
+  private_nh.param<std::string>("/op_behavior_selector/task_response_time_filename", task_response_time_filename, "~/Documents/profiling/response_time/op_behavior_selector.csv");
+  private_nh.param<int>("/op_behavior_selector/rate", rate, 10);
+  private_nh.param("/op_behavior_selector/task_minimum_inter_release_time", task_minimum_inter_release_time, (double)10);
+  private_nh.param("/op_behavior_selector/task_execution_time", task_execution_time, (double)10);
+  private_nh.param("/op_behavior_selector/task_relative_deadline", task_relative_deadline, (double)10);
+
+  /* For Task scheduling */
+  rubis::init_task_profiling(task_response_time_filename);
+
+  m_sprintSwitch = false;
+
+  ros::Rate r(100);
+  while(ros::ok()){
+    rubis::start_task_profiling();
+
+    ros::spinOnce();
+
+    // Check Pedestrian is Appeared
+    double dt  = UtilityHNS::UtilityH::GetTimeDiffNow(planningTimer);
+    UtilityHNS::UtilityH::GetTickCount(planningTimer);
+
+    if(m_MapType == PlannerHNS::MAP_KML_FILE && !bMap)
+    {
+      bMap = true;
+      PlannerHNS::MappingHelpers::LoadKML(m_MapPath, m_Map);
+    }
+    else if (m_MapType == PlannerHNS::MAP_FOLDER && !bMap)
+    {
+      bMap = true;
+      PlannerHNS::MappingHelpers::ConstructRoadNetworkFromDataFiles(m_MapPath, m_Map, true);
+
+    }
+    else if (m_MapType == PlannerHNS::MAP_AUTOWARE && !bMap)
+    {
+      std::vector<UtilityHNS::AisanDataConnFileReader::DataConn> conn_data;;
+
+      if(m_MapRaw.GetVersion()==2)
+      {
+        PlannerHNS::MappingHelpers::ConstructRoadNetworkFromROSMessageV2(m_MapRaw.pLanes->m_data_list, m_MapRaw.pPoints->m_data_list,
+            m_MapRaw.pCenterLines->m_data_list, m_MapRaw.pIntersections->m_data_list,m_MapRaw.pAreas->m_data_list,
+            m_MapRaw.pLines->m_data_list, m_MapRaw.pStopLines->m_data_list,  m_MapRaw.pSignals->m_data_list,
+            m_MapRaw.pVectors->m_data_list, m_MapRaw.pCurbs->m_data_list, m_MapRaw.pRoadedges->m_data_list, m_MapRaw.pWayAreas->m_data_list,
+            m_MapRaw.pCrossWalks->m_data_list, m_MapRaw.pNodes->m_data_list, conn_data,
+            m_MapRaw.pLanes, m_MapRaw.pPoints, m_MapRaw.pNodes, m_MapRaw.pLines, PlannerHNS::GPSPoint(), m_Map, true, m_PlanningParams.enableLaneChange, false);
+
+        try{
+          // Add Traffic Signal Info from yaml file
+          XmlRpc::XmlRpcValue traffic_light_list;
+          nh.getParam("/op_behavior_selector/traffic_light_list", traffic_light_list);
+
+          // Add Stop Line Info from yaml file
+          XmlRpc::XmlRpcValue stop_line_list;
+          nh.getParam("/op_behavior_selector/stop_line_list", stop_line_list);
+
+          // Add Crossing Info from yaml file
+          // XmlRpc::XmlRpcValue intersection_list;
+          // nh.getParam("/op_behavior_selector/intersection_list", intersection_list);
+
+          PlannerHNS::MappingHelpers::ConstructRoadNetwork_RUBIS(m_Map, traffic_light_list, stop_line_list);
+        }
+        catch(XmlRpc::XmlRpcException& e){
+          ROS_ERROR("[XmlRpc Error] %s", e.getMessage().c_str());
+          exit(1);
+        }
+
+        m_BehaviorGenerator.m_Map = m_Map;
+
+        if(m_Map.roadSegments.size() > 0)
+        {
+          bMap = true;
+          std::cout << " ******* Map V2 Is Loaded successfully from the Behavior Selector !! " << std::endl;
+        }
+      }
+      else if(m_MapRaw.GetVersion()==1)
+      {
+        PlannerHNS::MappingHelpers::ConstructRoadNetworkFromROSMessage(m_MapRaw.pLanes->m_data_list, m_MapRaw.pPoints->m_data_list,
+            m_MapRaw.pCenterLines->m_data_list, m_MapRaw.pIntersections->m_data_list,m_MapRaw.pAreas->m_data_list,
+            m_MapRaw.pLines->m_data_list, m_MapRaw.pStopLines->m_data_list,  m_MapRaw.pSignals->m_data_list,
+            m_MapRaw.pVectors->m_data_list, m_MapRaw.pCurbs->m_data_list, m_MapRaw.pRoadedges->m_data_list, m_MapRaw.pWayAreas->m_data_list,
+            m_MapRaw.pCrossWalks->m_data_list, m_MapRaw.pNodes->m_data_list, conn_data,  PlannerHNS::GPSPoint(), m_Map, true, m_PlanningParams.enableLaneChange, false);
+
+        if(m_Map.roadSegments.size() > 0)
+        {
+          bMap = true;
+          std::cout << " ******* Map V1 Is Loaded successfully from the Behavior Selector !! " << std::endl;
+        }
+      }
+    }
+
+    if(bNewCurrentPos && m_GlobalPaths.size()>0)
+    {
+      if(bNewLightSignal)
+      {
+        m_PrevTrafficLight = m_CurrTrafficLight;
+        bNewLightSignal = false;
+      }
+
+      if(bNewLightStatus)
+      {
+        bNewLightStatus = false;
+        for(unsigned int itls = 0 ; itls < m_PrevTrafficLight.size() ; itls++)
+          m_PrevTrafficLight.at(itls).lightState = m_CurrLightStatus;
+      }
+
+      m_BehaviorGenerator.m_sprintSwitch = m_sprintSwitch;
+      m_CurrentBehavior = m_BehaviorGenerator.DoOneStep(dt, m_CurrentPos, m_VehicleStatus, 1, m_CurrTrafficLight, m_TrajectoryBestCost, 0);
+      std_msgs::Int32 curr_state_msg;
+      curr_state_msg.data = m_CurrentBehavior.state;
+
+      pub_currentState.publish(curr_state_msg);
+
+      CalculateTurnAngle(m_BehaviorGenerator.m_turnWaypoint);
+      m_BehaviorGenerator.m_turnAngle = m_turnAngle;
+
+      std_msgs::Float64 turn_angle_msg;
+      turn_angle_msg.data = m_turnAngle;
+      pub_turnAngle.publish(turn_angle_msg);
+
+      emergency_stop_msg.data = false;
+      if(m_CurrentBehavior.maxVelocity == -1)//Emergency Stop!
+        emergency_stop_msg.data = true;
+      pub_EmergencyStop.publish(emergency_stop_msg);
+
+      SendLocalPlanningTopics(lane_array_with_pose_twist_msg_);
+      VisualizeLocalPlanner();
+      LogLocalPlanningInfo(dt);
+
+      // Publish turn_marker
+      visualization_msgs::MarkerArray turn_marker;
+      visualization_msgs::Marker marker;
+      marker.header.frame_id = "map";
+      marker.type = 2;
+      marker.pose.position.x = m_BehaviorGenerator.m_turnWaypoint.pos.x;
+      marker.pose.position.y = m_BehaviorGenerator.m_turnWaypoint.pos.y;
+      marker.pose.position.z = m_BehaviorGenerator.m_turnWaypoint.pos.z;
+      marker.scale.x = 3;
+      marker.scale.y = 3;
+      marker.scale.z = 3;
+      marker.color.r = 0.0f;
+      marker.color.g = 1.0f;
+      marker.color.b = 0.0f;
+      marker.color.a = 1.0f;
+      marker.header.stamp = ros::Time::now();
+      marker.header.frame_id = "map";
+      turn_marker.markers.push_back(marker);
+
+      pub_turnMarker.publish(turn_marker);
+    }
+    else
+      sub_GlobalPlannerPaths = nh.subscribe("/lane_waypoints_array",   1,    &BehaviorGen::callbackGetGlobalPlannerPath,   this);
+
+    rubis::stop_task_profiling(0, 0);    
+    r.sleep();
+  }
+}
+
+bool BehaviorGen::GetBaseMapTF(){
+  
+  try{
+    m_map_base_listener.waitForTransform("base_link", "map", ros::Time(0), ros::Duration(0.001));
+    m_map_base_listener.lookupTransform("base_link", "map", ros::Time(0), m_map_base_transform);
+    return true;
+  }
+  catch(tf::TransformException& ex)
+  {
+    return false;
+  }
+  
+}
+
+void BehaviorGen::TransformPose(const geometry_msgs::PoseStamped &in_pose, geometry_msgs::PoseStamped& out_pose, const tf::StampedTransform &in_transform)
+{
+
+  tf::Vector3 in_pos(in_pose.pose.position.x,
+                     in_pose.pose.position.y,
+                     in_pose.pose.position.z);
+  tf::Quaternion in_quat(in_pose.pose.orientation.x,
+                         in_pose.pose.orientation.y,
+                         in_pose.pose.orientation.w,
+                         in_pose.pose.orientation.z);
+
+  tf::Vector3 in_pos_t = in_transform * in_pos;
+  tf::Quaternion in_quat_t = in_transform * in_quat;
+  
+  out_pose.header = in_pose.header;
+  out_pose.pose.position.x = in_pos_t.x();
+  out_pose.pose.position.y = in_pos_t.y();
+  out_pose.pose.position.z = in_pos_t.z();
+  out_pose.pose.orientation.x = in_quat_t.x();
+  out_pose.pose.orientation.y = in_quat_t.y();
+  out_pose.pose.orientation.z = in_quat_t.z();
+
+  return;
+}
+
+//Mapping Section
+
+void BehaviorGen::callbackGetVMLanes(const vector_map_msgs::LaneArray& msg)
+{
+  std::cout << "Received Lanes" << endl;
+  if(m_MapRaw.pLanes == nullptr)
+    m_MapRaw.pLanes = new UtilityHNS::AisanLanesFileReader(msg);
+}
+
+void BehaviorGen::callbackGetVMPoints(const vector_map_msgs::PointArray& msg)
+{
+  std::cout << "Received Points" << endl;
+  if(m_MapRaw.pPoints  == nullptr)
+    m_MapRaw.pPoints = new UtilityHNS::AisanPointsFileReader(msg);
+}
+
+void BehaviorGen::callbackGetVMdtLanes(const vector_map_msgs::DTLaneArray& msg)
+{
+  std::cout << "Received dtLanes" << endl;
+  if(m_MapRaw.pCenterLines == nullptr)
+    m_MapRaw.pCenterLines = new UtilityHNS::AisanCenterLinesFileReader(msg);
+}
+
+void BehaviorGen::callbackGetVMIntersections(const vector_map_msgs::CrossRoadArray& msg)
+{
+  std::cout << "Received CrossRoads" << endl;
+  if(m_MapRaw.pIntersections == nullptr)
+    m_MapRaw.pIntersections = new UtilityHNS::AisanIntersectionFileReader(msg);
+}
+
+void BehaviorGen::callbackGetVMAreas(const vector_map_msgs::AreaArray& msg)
+{
+  std::cout << "Received Areas" << endl;
+  if(m_MapRaw.pAreas == nullptr)
+    m_MapRaw.pAreas = new UtilityHNS::AisanAreasFileReader(msg);
+}
+
+void BehaviorGen::callbackGetVMLines(const vector_map_msgs::LineArray& msg)
+{
+  std::cout << "Received Lines" << endl;
+  if(m_MapRaw.pLines == nullptr)
+    m_MapRaw.pLines = new UtilityHNS::AisanLinesFileReader(msg);
+}
+
+void BehaviorGen::callbackGetVMStopLines(const vector_map_msgs::StopLineArray& msg)
+{
+  std::cout << "Received StopLines" << endl;
+  if(m_MapRaw.pStopLines == nullptr)
+    m_MapRaw.pStopLines = new UtilityHNS::AisanStopLineFileReader(msg);
+}
+
+void BehaviorGen::callbackGetVMSignal(const vector_map_msgs::SignalArray& msg)
+{
+  std::cout << "Received Signals" << endl;
+  if(m_MapRaw.pSignals  == nullptr)
+    m_MapRaw.pSignals = new UtilityHNS::AisanSignalFileReader(msg);
+}
+
+void BehaviorGen::callbackGetVMVectors(const vector_map_msgs::VectorArray& msg)
+{
+  std::cout << "Received Vectors" << endl;
+  if(m_MapRaw.pVectors  == nullptr)
+    m_MapRaw.pVectors = new UtilityHNS::AisanVectorFileReader(msg);
+}
+
+void BehaviorGen::callbackGetVMCurbs(const vector_map_msgs::CurbArray& msg)
+{
+  std::cout << "Received Curbs" << endl;
+  if(m_MapRaw.pCurbs == nullptr)
+    m_MapRaw.pCurbs = new UtilityHNS::AisanCurbFileReader(msg);
+}
+
+void BehaviorGen::callbackGetVMRoadEdges(const vector_map_msgs::RoadEdgeArray& msg)
+{
+  std::cout << "Received Edges" << endl;
+  if(m_MapRaw.pRoadedges  == nullptr)
+    m_MapRaw.pRoadedges = new UtilityHNS::AisanRoadEdgeFileReader(msg);
+}
+
+void BehaviorGen::callbackGetVMWayAreas(const vector_map_msgs::WayAreaArray& msg)
+{
+  std::cout << "Received Wayareas" << endl;
+  if(m_MapRaw.pWayAreas  == nullptr)
+    m_MapRaw.pWayAreas = new UtilityHNS::AisanWayareaFileReader(msg);
+}
+
+void BehaviorGen::callbackGetVMCrossWalks(const vector_map_msgs::CrossWalkArray& msg)
+{
+  std::cout << "Received CrossWalks" << endl;
+  if(m_MapRaw.pCrossWalks == nullptr)
+    m_MapRaw.pCrossWalks = new UtilityHNS::AisanCrossWalkFileReader(msg);
+}
+
+void BehaviorGen::callbackGetVMNodes(const vector_map_msgs::NodeArray& msg)
+{
+  std::cout << "Received Nodes" << endl;
+  if(m_MapRaw.pNodes == nullptr)
+    m_MapRaw.pNodes = new UtilityHNS::AisanNodesFileReader(msg);
+}
+}
diff --git a/autoware.ai/src/autoware/core_planning/op_local_planner/nodes/op_motion_predictor/op_motion_predictor_core.cpp b/autoware.ai/src/autoware/core_planning/op_local_planner/nodes/op_motion_predictor/op_motion_predictor_core.cpp
index d31d230c..b4b55585 100644
--- a/autoware.ai/src/autoware/core_planning/op_local_planner/nodes/op_motion_predictor/op_motion_predictor_core.cpp
+++ b/autoware.ai/src/autoware/core_planning/op_local_planner/nodes/op_motion_predictor/op_motion_predictor_core.cpp
@@ -76,16 +76,16 @@ MotionPrediction::MotionPrediction()
     object_msg_list_.push_back(msg);
   }
   
-  sub_current_pose   = nh.subscribe("/current_pose", 10,  &MotionPrediction::callbackGetCurrentPose,     this);
+  sub_current_pose   = nh.subscribe("/current_pose", 1,  &MotionPrediction::callbackGetCurrentPose,     this); // Def: 1
 
   int bVelSource = 1;
   _nh.getParam("/op_motion_predictor/velocitySource", bVelSource);
   if(bVelSource == 0)
-    sub_robot_odom = nh.subscribe("/odom", 10, &MotionPrediction::callbackGetRobotOdom, this);
+    sub_robot_odom = nh.subscribe("/odom", 1, &MotionPrediction::callbackGetRobotOdom, this); // Def: 1
   else if(bVelSource == 1)
-    sub_current_velocity = nh.subscribe("/current_velocity", 10, &MotionPrediction::callbackGetVehicleStatus, this);
+    sub_current_velocity = nh.subscribe("/current_velocity", 1, &MotionPrediction::callbackGetVehicleStatus, this); // Def: 1
   else if(bVelSource == 2)
-    sub_can_info = nh.subscribe("/can_info", 10, &MotionPrediction::callbackGetCANInfo, this);
+    sub_can_info = nh.subscribe("/can_info", 1, &MotionPrediction::callbackGetCANInfo, this); // Def: 1
   
   UtilityHNS::UtilityH::GetTickCount(m_VisualizationTimer);
   PlannerHNS::ROSHelpers::InitPredMarkers(100, m_PredictedTrajectoriesDummy);
@@ -245,8 +245,6 @@ void MotionPrediction::callbackGetVehicleStatus(const geometry_msgs::TwistStampe
     m_VehicleStatus.steer = atan(m_CarInfo.wheel_base * msg->twist.angular.z/msg->twist.linear.x);
   UtilityHNS::UtilityH::GetTickCount(m_VehicleStatus.tStamp);
   bVehicleStatus = true;
-
-  if(rubis::sched::is_task_ready_ == TASK_NOT_READY) rubis::sched::init_task();  
 }
 
 void MotionPrediction::callbackGetCANInfo(const autoware_can_msgs::CANInfoConstPtr &msg)
@@ -405,16 +403,77 @@ void MotionPrediction::callbackGetTrackedObjects(const autoware_msgs::DetectedOb
   }
 }
 
-void MotionPrediction::callbackGetRubisTrackedObjects(const rubis_msgs::DetectedObjectArrayConstPtr& in_msg)
+void MotionPrediction::callbackGetRubisTrackedObjects(const rubis_msgs::DetectedObjectArrayConstPtr& in_msg){
+  rubis::start_task_profiling();
+
+  rubis_msgs::DetectedObjectArray msg = *in_msg;
+  _callbackGetRubisTrackedObjects(msg);
+
+  if(m_MapType == PlannerHNS::MAP_KML_FILE && !bMap)
+  {
+    bMap = true;
+    PlannerHNS::MappingHelpers::LoadKML(m_MapPath, m_Map);
+  }
+  else if (m_MapType == PlannerHNS::MAP_FOLDER && !bMap)
+  {
+    bMap = true;
+    PlannerHNS::MappingHelpers::ConstructRoadNetworkFromDataFiles(m_MapPath, m_Map, true);
+  }
+  else if (m_MapType == PlannerHNS::MAP_AUTOWARE && !bMap)
+  {
+    std::vector<UtilityHNS::AisanDataConnFileReader::DataConn> conn_data;;
+
+    if(m_MapRaw.GetVersion()==2)
+    {
+      PlannerHNS::MappingHelpers::ConstructRoadNetworkFromROSMessageV2(m_MapRaw.pLanes->m_data_list, m_MapRaw.pPoints->m_data_list,
+          m_MapRaw.pCenterLines->m_data_list, m_MapRaw.pIntersections->m_data_list,m_MapRaw.pAreas->m_data_list,
+          m_MapRaw.pLines->m_data_list, m_MapRaw.pStopLines->m_data_list,  m_MapRaw.pSignals->m_data_list,
+          m_MapRaw.pVectors->m_data_list, m_MapRaw.pCurbs->m_data_list, m_MapRaw.pRoadedges->m_data_list, m_MapRaw.pWayAreas->m_data_list,
+          m_MapRaw.pCrossWalks->m_data_list, m_MapRaw.pNodes->m_data_list, conn_data,
+          m_MapRaw.pLanes, m_MapRaw.pPoints, m_MapRaw.pNodes, m_MapRaw.pLines, PlannerHNS::GPSPoint(), m_Map, true, m_PlanningParams.enableLaneChange, true);
+
+      if(m_Map.roadSegments.size() > 0)
+      {
+        bMap = true;
+        std::cout << " ******* Map V2 Is Loaded successfully from the Motion Predictor !! " << std::endl;
+      }
+    }
+    else if(m_MapRaw.GetVersion()==1)
+    {
+      PlannerHNS::MappingHelpers::ConstructRoadNetworkFromROSMessage(m_MapRaw.pLanes->m_data_list, m_MapRaw.pPoints->m_data_list,
+          m_MapRaw.pCenterLines->m_data_list, m_MapRaw.pIntersections->m_data_list,m_MapRaw.pAreas->m_data_list,
+          m_MapRaw.pLines->m_data_list, m_MapRaw.pStopLines->m_data_list,  m_MapRaw.pSignals->m_data_list,
+          m_MapRaw.pVectors->m_data_list, m_MapRaw.pCurbs->m_data_list, m_MapRaw.pRoadedges->m_data_list, m_MapRaw.pWayAreas->m_data_list,
+          m_MapRaw.pCrossWalks->m_data_list, m_MapRaw.pNodes->m_data_list, conn_data,  PlannerHNS::GPSPoint(), m_Map, true);
+
+      if(m_Map.roadSegments.size() > 0)
+      {
+        bMap = true;
+        std::cout << " ******* Map V1 Is Loaded successfully from the Motion Predictor !! " << std::endl;
+      }
+    }
+  }
+
+  if(UtilityHNS::UtilityH::GetTimeDiffNow(m_VisualizationTimer) > m_VisualizationTime)
+  {
+    VisualizePrediction();
+    UtilityHNS::UtilityH::GetTickCount(m_VisualizationTimer);
+  }
+
+  rubis::stop_task_profiling(rubis::instance_, 0);
+}
+
+void MotionPrediction::_callbackGetRubisTrackedObjects(rubis_msgs::DetectedObjectArray& objects_msg)
 {
-  rubis::instance_ = in_msg->instance;
+  rubis::instance_ = objects_msg.instance;
+  rubis::obj_instance_ = objects_msg.instance;
 
   UtilityHNS::UtilityH::GetTickCount(m_SensingTimer);
   m_TrackedObjects.clear();
   bTrackedObjects = true;
 
   // Check frame id of the object is valid
-  std::string target_frame = in_msg->object_array.header.frame_id;
+  std::string target_frame = objects_msg.object_array.header.frame_id;
   int obj_idx = getIndex(tf_str_list_, target_frame);
   if(obj_idx == -1){      
     std::cout<<target_frame<<std::endl;
@@ -424,10 +483,10 @@ void MotionPrediction::callbackGetRubisTrackedObjects(const rubis_msgs::Detected
 
   autoware_msgs::DetectedObjectArray msg; 
   if(target_frame != "velodyne"){
-    msg = TrasformObjAryToVeldoyne(in_msg->object_array, transform_list_[obj_idx]);  
+    msg = TrasformObjAryToVeldoyne(objects_msg.object_array, transform_list_[obj_idx]);  
   }
   else{
-    msg = in_msg->object_array;
+    msg = objects_msg.object_array;
   }
   
   
@@ -496,9 +555,10 @@ void MotionPrediction::callbackGetRubisTrackedObjects(const rubis_msgs::Detected
 
     rubis_msgs::DetectedObjectArray output_msg;
     output_msg.instance = rubis::instance_;
+    output_msg.obj_instance = rubis::obj_instance_;
     output_msg.object_array = m_PredictedResultsResults;
     pub_rubis_predicted_objects_trajectories.publish(output_msg);
-    rubis::sched::task_state_ = TASK_STATE_DONE;
+    
   }
 
 }
@@ -643,99 +703,29 @@ void MotionPrediction::MainLoop()
 
   ros::NodeHandle private_nh("~");
 
-  // Scheduling Setup
-  int task_scheduling_flag;
-  int task_profiling_flag;
+  // Scheduling & Profiling Setup
+  std::string node_name = ros::this_node::getName();
   std::string task_response_time_filename;
-  int rate;
-  double task_minimum_inter_release_time;
-  double task_execution_time;
-  double task_relative_deadline; 
-
-  private_nh.param<int>("/op_motion_predictor/task_scheduling_flag", task_scheduling_flag, 0);
-  private_nh.param<int>("/op_motion_predictor/task_profiling_flag", task_profiling_flag, 0);
-  private_nh.param<std::string>("/op_motion_predictor/task_response_time_filename", task_response_time_filename, "~/Documents/profiling/response_time/op_motion_predictor.csv");
-  private_nh.param<int>("/op_motion_predictor/rate", rate, 10);
-  private_nh.param("/op_motion_predictor/task_minimum_inter_release_time", task_minimum_inter_release_time, (double)10);
-  private_nh.param("/op_motion_predictor/task_execution_time", task_execution_time, (double)10);
-  private_nh.param("/op_motion_predictor/task_relative_deadline", task_relative_deadline, (double)10);
-
-  if(task_profiling_flag) rubis::sched::init_task_profiling(task_response_time_filename);
+  private_nh.param<std::string>(node_name+"/task_response_time_filename", task_response_time_filename, "~/Documents/profiling/response_time/op_motion_predictor.csv");
 
-  ros::Rate loop_rate(rate);
-  if(!task_scheduling_flag && !task_profiling_flag) loop_rate = ros::Rate(25);
-
-  while (ros::ok())
-  {
-    if(task_profiling_flag) rubis::sched::start_task_profiling();
-
-    if(rubis::sched::is_task_ready_ == TASK_READY && rubis::sched::task_state_ == TASK_STATE_READY){
-      if(task_scheduling_flag) rubis::sched::request_task_scheduling(task_minimum_inter_release_time, task_execution_time, task_relative_deadline); 
-      rubis::sched::task_state_ = TASK_STATE_RUNNING;     
-    }
-
-    ros::spinOnce();
-
-    if(m_MapType == PlannerHNS::MAP_KML_FILE && !bMap)
-    {
-      bMap = true;
-      PlannerHNS::MappingHelpers::LoadKML(m_MapPath, m_Map);
-    }
-    else if (m_MapType == PlannerHNS::MAP_FOLDER && !bMap)
-    {
-      bMap = true;
-      PlannerHNS::MappingHelpers::ConstructRoadNetworkFromDataFiles(m_MapPath, m_Map, true);
-    }
-    else if (m_MapType == PlannerHNS::MAP_AUTOWARE && !bMap)
-    {
-      std::vector<UtilityHNS::AisanDataConnFileReader::DataConn> conn_data;;
-
-      if(m_MapRaw.GetVersion()==2)
-      {
-        PlannerHNS::MappingHelpers::ConstructRoadNetworkFromROSMessageV2(m_MapRaw.pLanes->m_data_list, m_MapRaw.pPoints->m_data_list,
-            m_MapRaw.pCenterLines->m_data_list, m_MapRaw.pIntersections->m_data_list,m_MapRaw.pAreas->m_data_list,
-            m_MapRaw.pLines->m_data_list, m_MapRaw.pStopLines->m_data_list,  m_MapRaw.pSignals->m_data_list,
-            m_MapRaw.pVectors->m_data_list, m_MapRaw.pCurbs->m_data_list, m_MapRaw.pRoadedges->m_data_list, m_MapRaw.pWayAreas->m_data_list,
-            m_MapRaw.pCrossWalks->m_data_list, m_MapRaw.pNodes->m_data_list, conn_data,
-            m_MapRaw.pLanes, m_MapRaw.pPoints, m_MapRaw.pNodes, m_MapRaw.pLines, PlannerHNS::GPSPoint(), m_Map, true, m_PlanningParams.enableLaneChange, true);
-
-        if(m_Map.roadSegments.size() > 0)
-        {
-          bMap = true;
-          std::cout << " ******* Map V2 Is Loaded successfully from the Motion Predictor !! " << std::endl;
-        }
-      }
-      else if(m_MapRaw.GetVersion()==1)
-      {
-        PlannerHNS::MappingHelpers::ConstructRoadNetworkFromROSMessage(m_MapRaw.pLanes->m_data_list, m_MapRaw.pPoints->m_data_list,
-            m_MapRaw.pCenterLines->m_data_list, m_MapRaw.pIntersections->m_data_list,m_MapRaw.pAreas->m_data_list,
-            m_MapRaw.pLines->m_data_list, m_MapRaw.pStopLines->m_data_list,  m_MapRaw.pSignals->m_data_list,
-            m_MapRaw.pVectors->m_data_list, m_MapRaw.pCurbs->m_data_list, m_MapRaw.pRoadedges->m_data_list, m_MapRaw.pWayAreas->m_data_list,
-            m_MapRaw.pCrossWalks->m_data_list, m_MapRaw.pNodes->m_data_list, conn_data,  PlannerHNS::GPSPoint(), m_Map, true);
-
-        if(m_Map.roadSegments.size() > 0)
-        {
-          bMap = true;
-          std::cout << " ******* Map V1 Is Loaded successfully from the Motion Predictor !! " << std::endl;
-        }
-      }
-    }
-
-    if(UtilityHNS::UtilityH::GetTimeDiffNow(m_VisualizationTimer) > m_VisualizationTime)
-    {
-      VisualizePrediction();
-      UtilityHNS::UtilityH::GetTickCount(m_VisualizationTimer);
-    }
+  int rate;
+  private_nh.param<int>(node_name+"/rate", rate, 10);
 
-    if(task_profiling_flag) rubis::sched::stop_task_profiling(rubis::instance_, rubis::sched::task_state_);
+  struct rubis::sched_attr attr;
+  std::string policy;
+  int priority, exec_time ,deadline, period;
+    
+  private_nh.param(node_name+"/task_scheduling_configs/policy", policy, std::string("NONE"));    
+  private_nh.param(node_name+"/task_scheduling_configs/priority", priority, 99);
+  private_nh.param(node_name+"/task_scheduling_configs/exec_time", exec_time, 0);
+  private_nh.param(node_name+"/task_scheduling_configs/deadline", deadline, 0);
+  private_nh.param(node_name+"/task_scheduling_configs/period", period, 0);
+  attr = rubis::create_sched_attr(priority, exec_time, deadline, period);    
+  rubis::init_task_scheduling(policy, attr);
 
-    if(rubis::sched::is_task_ready_ == TASK_READY && rubis::sched::task_state_ == TASK_STATE_DONE){
-      if(task_scheduling_flag) rubis::sched::yield_task_scheduling();
-      rubis::sched::task_state_ = TASK_STATE_READY;
-    }
+  rubis::init_task_profiling(task_response_time_filename);
 
-    loop_rate.sleep();
-  }
+  ros::spin();
 }
 
 void MotionPrediction::TransformPose(const geometry_msgs::PoseStamped &in_pose, geometry_msgs::PoseStamped& out_pose, const tf::StampedTransform &in_transform)
diff --git a/autoware.ai/src/autoware/core_planning/op_local_planner/nodes/op_trajectory_evaluator/op_trajectory_evaluator_core.cpp b/autoware.ai/src/autoware/core_planning/op_local_planner/nodes/op_trajectory_evaluator/op_trajectory_evaluator_core.cpp
index d73353ad..5ff9be73 100644
--- a/autoware.ai/src/autoware/core_planning/op_local_planner/nodes/op_trajectory_evaluator/op_trajectory_evaluator_core.cpp
+++ b/autoware.ai/src/autoware/core_planning/op_local_planner/nodes/op_trajectory_evaluator/op_trajectory_evaluator_core.cpp
@@ -30,6 +30,7 @@ TrajectoryEval::TrajectoryEval()
   bWayGlobalPathToUse = false;
   m_bUseMoveingObjectsPrediction = false;
   m_noVehicleCnt = 0;
+  is_objects_updated_ = false;
 
   ros::NodeHandle _nh;
   UpdatePlanningParams(_nh);
@@ -42,42 +43,29 @@ TrajectoryEval::TrajectoryEval()
 
   pub_CollisionPointsRviz = nh.advertise<visualization_msgs::MarkerArray>("dynamic_collision_points_rviz", 1);
   pub_LocalWeightedTrajectoriesRviz = nh.advertise<visualization_msgs::MarkerArray>("local_trajectories_eval_rviz", 1);
-  pub_LocalWeightedTrajectories = nh.advertise<autoware_msgs::LaneArray>("local_weighted_trajectories", 1);
+  // pub_LocalWeightedTrajectories = nh.advertise<rubis_msgs::LaneArrayWithPoseTwist>("local_weighted_trajectories", 1);
+  pub_LocalWeightedTrajectoriesWithPoseTwist = nh.advertise<rubis_msgs::LaneArrayWithPoseTwist>("local_weighted_trajectories_with_pose_twist", 1);
   pub_TrajectoryCost = nh.advertise<autoware_msgs::Lane>("local_trajectory_cost", 1);
   pub_SafetyBorderRviz = nh.advertise<visualization_msgs::Marker>("safety_border", 1);
   pub_DistanceToPedestrian = nh.advertise<std_msgs::Float64>("distance_to_pedestrian", 1);
   pub_IntersectionCondition = nh.advertise<autoware_msgs::IntersectionCondition>("intersection_condition", 1);
   pub_SprintSwitch = nh.advertise<std_msgs::Bool>("sprint_switch", 1);
 
-  sub_current_pose = nh.subscribe("/current_pose", 10, &TrajectoryEval::callbackGetCurrentPose, this);
-  sub_current_state = nh.subscribe("/current_state", 10, &TrajectoryEval::callbackGetCurrentState, this);
-
-  int bVelSource = 1;
-  _nh.getParam("/op_trajectory_evaluator/velocitySource", bVelSource);
-  if(bVelSource == 0)
-    sub_robot_odom = nh.subscribe("/odom", 10, &TrajectoryEval::callbackGetRobotOdom, this);
-  else if(bVelSource == 1)
-    sub_current_velocity = nh.subscribe("/current_velocity", 10, &TrajectoryEval::callbackGetVehicleStatus, this);
-  else if(bVelSource == 2)
-    sub_can_info = nh.subscribe("/can_info", 10, &TrajectoryEval::callbackGetCANInfo, this);
-
-  /*  RT Scheduling setup  */
-  // sub_current_pose = nh.subscribe("/current_pose", 1, &TrajectoryEval::callbackGetCurrentPose, this); //origin 10
-  // sub_current_state = nh.subscribe("/current_state", 1, &TrajectoryEval::callbackGetCurrentState, this); //origin 10
+  // sub_current_pose = nh.subscribe("/current_pose", 10, &TrajectoryEval::callbackGetCurrentPose, this);
+  // sub_current_state = nh.subscribe("/current_state", 10, &TrajectoryEval::callbackGetCurrentState, this);
 
   // int bVelSource = 1;
   // _nh.getParam("/op_trajectory_evaluator/velocitySource", bVelSource);
   // if(bVelSource == 0)
-  //   sub_robot_odom = nh.subscribe("/odom", 1, &TrajectoryEval::callbackGetRobotOdom, this); //origin 10
+  //   sub_robot_odom = nh.subscribe("/odom", 10, &TrajectoryEval::callbackGetRobotOdom, this);
   // else if(bVelSource == 1)
-  //   sub_current_velocity = nh.subscribe("/current_velocity", 1, &TrajectoryEval::callbackGetVehicleStatus, this); //origin 10
+  //   sub_current_velocity = nh.subscribe("/current_velocity", 10, &TrajectoryEval::callbackGetVehicleStatus, this);
   // else if(bVelSource == 2)
-  //   sub_can_info = nh.subscribe("/can_info", 1, &TrajectoryEval::callbackGetCANInfo, this); //origin 10
+  //   sub_can_info = nh.subscribe("/can_info", 10, &TrajectoryEval::callbackGetCANInfo, this);
 
   sub_GlobalPlannerPaths = nh.subscribe("/lane_waypoints_array", 1, &TrajectoryEval::callbackGetGlobalPlannerPath, this);
-  sub_LocalPlannerPaths = nh.subscribe("/local_trajectories", 1, &TrajectoryEval::callbackGetLocalPlannerPath, this);
-  // sub_predicted_objects = nh.subscribe("/predicted_objects", 1, &TrajectoryEval::callbackGetPredictedObjects, this);
-  sub_rubis_predicted_objects = nh.subscribe("/rubis_predicted_objects", 1, &TrajectoryEval::callbackGetRubisPredictedObjects, this);
+  sub_LocalPlannerPaths = nh.subscribe("/local_trajectories_with_pose_twist", 1, &TrajectoryEval::callbackGetLocalPlannerPath, this);
+  sub_predicted_objects = nh.subscribe("/rubis_predicted_objects", 1, &TrajectoryEval::callbackGetPredictedObjects, this);
   sub_current_behavior = nh.subscribe("/current_behavior", 1, &TrajectoryEval::callbackGetBehaviorState, this);
 
   PlannerHNS::ROSHelpers::InitCollisionPointsMarkers(50, m_CollisionsDummy);
@@ -155,23 +143,21 @@ void TrajectoryEval::UpdatePlanningParams(ros::NodeHandle& _nh)
 
 }
 
-void TrajectoryEval::callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr& msg)
-{
-  m_CurrentPos = PlannerHNS::WayPoint(msg->pose.position.x, msg->pose.position.y, msg->pose.position.z, tf::getYaw(msg->pose.orientation));
-  bNewCurrentPos = true;
-}
-
-void TrajectoryEval::callbackGetVehicleStatus(const geometry_msgs::TwistStampedConstPtr& msg)
-{
-  m_VehicleStatus.speed = msg->twist.linear.x;
-  m_CurrentPos.v = m_VehicleStatus.speed;
-  if(fabs(msg->twist.linear.x) > 0.25)
-    m_VehicleStatus.steer = atan(m_CarInfo.wheel_base * msg->twist.angular.z/msg->twist.linear.x);
-  UtilityHNS::UtilityH::GetTickCount(m_VehicleStatus.tStamp);
-  bVehicleStatus = true;
-
-  if(rubis::sched::is_task_ready_ == TASK_NOT_READY) rubis::sched::init_task();
-}
+// void TrajectoryEval::callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr& msg)
+// {
+//   m_CurrentPos = PlannerHNS::WayPoint(msg->pose.position.x, msg->pose.position.y, msg->pose.position.z, tf::getYaw(msg->pose.orientation));
+//   bNewCurrentPos = true;
+// }
+
+// void TrajectoryEval::callbackGetVehicleStatus(const geometry_msgs::TwistStampedConstPtr& msg)
+// {
+//   m_VehicleStatus.speed = msg->twist.linear.x;
+//   m_CurrentPos.v = m_VehicleStatus.speed;
+//   if(fabs(msg->twist.linear.x) > 0.25)
+//     m_VehicleStatus.steer = atan(m_CarInfo.wheel_base * msg->twist.angular.z/msg->twist.linear.x);
+//   UtilityHNS::UtilityH::GetTickCount(m_VehicleStatus.tStamp);
+//   bVehicleStatus = true;
+// }
 
 void TrajectoryEval::callbackGetCANInfo(const autoware_can_msgs::CANInfoConstPtr &msg)
 {
@@ -226,17 +212,51 @@ void TrajectoryEval::callbackGetGlobalPlannerPath(const autoware_msgs::LaneArray
   }
 }
 
-void TrajectoryEval::callbackGetLocalPlannerPath(const autoware_msgs::LaneArrayConstPtr& msg)
+void TrajectoryEval::callbackGetLocalPlannerPath(const rubis_msgs::LaneArrayWithPoseTwistConstPtr& msg)
 {
-  if(msg->lanes.size() > 0)
+  rubis::start_task_profiling();
+  // Before spin
+  UpdateMyParams();
+  UpdateTf();
+
+  // callback for objects
+  if(is_objects_updated_){
+    _callbackGetPredictedObjects(object_msg_);
+    is_objects_updated_ = false;
+  }
+
+  static double prev_x = 0.0, prev_y = 0.0, prev_speed = 0.0;
+  
+  // callback for current pose
+  if(prev_x != msg->pose.pose.position.x || prev_y != msg->pose.pose.position.y){
+    m_CurrentPos = PlannerHNS::WayPoint(msg->pose.pose.position.x, msg->pose.pose.position.y, msg->pose.pose.position.z, tf::getYaw(msg->pose.pose.orientation));
+    bNewCurrentPos = true;
+    prev_x = msg->pose.pose.position.x;
+    prev_y = msg->pose.pose.position.y;
+  }
+
+  // callback for vehicle status
+  if(prev_speed != msg->twist.twist.linear.x){
+    m_VehicleStatus.speed = msg->twist.twist.linear.x;
+    m_CurrentPos.v = m_VehicleStatus.speed;
+    if(fabs(msg->twist.twist.linear.x) > 0.25)
+      m_VehicleStatus.steer = atan(m_CarInfo.wheel_base * msg->twist.twist.angular.z/msg->twist.twist.linear.x);
+    UtilityHNS::UtilityH::GetTickCount(m_VehicleStatus.tStamp);
+    bVehicleStatus = true;      
+    prev_speed = msg->twist.twist.linear.x;
+  }
+
+
+  // callback for local planner path
+  if(msg->lane_array.lanes.size() > 0)
   {
     m_GeneratedRollOuts.clear();
     int globalPathId_roll_outs = -1;
 
-    for(unsigned int i = 0 ; i < msg->lanes.size(); i++)
+    for(unsigned int i = 0 ; i < msg->lane_array.lanes.size(); i++)
     {
       std::vector<PlannerHNS::WayPoint> path;
-      PlannerHNS::ROSHelpers::ConvertFromAutowareLaneToLocalLane(msg->lanes.at(i), path);
+      PlannerHNS::ROSHelpers::ConvertFromAutowareLaneToLocalLane(msg->lane_array.lanes.at(i), path);
       m_GeneratedRollOuts.push_back(path);
       if(path.size() > 0)
         globalPathId_roll_outs = path.at(0).gid;
@@ -257,157 +277,140 @@ void TrajectoryEval::callbackGetLocalPlannerPath(const autoware_msgs::LaneArrayC
 
     bRollOuts = true;
   }
-}
-
-void TrajectoryEval::callbackGetPredictedObjects(const autoware_msgs::DetectedObjectArrayConstPtr& msg)
-{  
-  /*
-  m_PredictedObjects.clear();
-  bPredictedObjects = true;
-  double distance_to_pedestrian = 1000;
-  int image_person_detection_range_left = m_ImageWidth/2 - m_ImageWidth*m_PedestrianImageDetectionRange/2;
-  int image_person_detection_range_right = m_ImageWidth/2 + m_ImageWidth*m_PedestrianImageDetectionRange/2;
-  
-  int image_vehicle_detection_range_left = m_ImageWidth/2 - m_ImageWidth*m_VehicleImageDetectionRange/2;
-  int image_vehicle_detection_range_right = m_ImageWidth/2 + m_ImageWidth*m_VehicleImageDetectionRange/2;
 
-  int vehicle_cnt = 0;
+  // After spin
+  PlannerHNS::TrajectoryCost tc;
 
-  PlannerHNS::DetectedObject obj;
-  for(unsigned int i = 0 ; i <msg->objects.size(); i++)
-  {    
-    if(msg->objects.at(i).pose.position.y < -20 || msg->objects.at(i).pose.position.y > 20)
-      continue;    
-      
-    if(msg->objects.at(i).pose.position.z > 1 || msg->objects.at(i).pose.position.z < -1.5)
-      continue;
+  if(bNewCurrentPos && m_GlobalPaths.size()>0)
+  {
+    m_GlobalPathSections.clear();
 
-    autoware_msgs::DetectedObject msg_obj = msg->objects.at(i);     
+    for(unsigned int i = 0; i < m_GlobalPathsToUse.size(); i++)
+    {
+      t_centerTrajectorySmoothed.clear();
+      PlannerHNS::PlanningHelpers::ExtractPartFromPointToDistanceDirectionFast(m_GlobalPathsToUse.at(i), m_CurrentPos, m_PlanningParams.horizonDistance , m_PlanningParams.pathDensity ,t_centerTrajectorySmoothed);
+      m_GlobalPathSections.push_back(t_centerTrajectorySmoothed);
+    }
 
-    // #### Decison making for objects
-    
-    if(msg_obj.id > 0) // If fusion object is detected
+    if(m_GlobalPathSections.size()>0)
     {
-      if(msg_obj.label == "car" || msg_obj.label == "truck" || msg_obj.label == "bus"){
-        vehicle_cnt += 1;
-      }
+      if(m_bUseMoveingObjectsPrediction)
+        tc = m_TrajectoryCostsCalculator.DoOneStepDynamic(m_GeneratedRollOuts, m_GlobalPathSections.at(0), m_CurrentPos,m_PlanningParams,  m_CarInfo,m_VehicleStatus, m_PredictedObjects, m_CurrentBehavior.iTrajectory);
+      else
+        tc = m_TrajectoryCostsCalculator.DoOneStepStatic(m_GeneratedRollOuts, m_GlobalPathSections.at(0), m_CurrentPos,  m_PlanningParams,  m_CarInfo,m_VehicleStatus, m_PredictedObjects, m_CurrentBehavior.state);
+
+      autoware_msgs::Lane l;
+      l.closest_object_distance = tc.closest_obj_distance;
+      l.closest_object_velocity = tc.closest_obj_velocity;
+      l.cost = tc.cost;
+      l.is_blocked = tc.bBlocked;
+      l.lane_index = tc.index;
+      pub_TrajectoryCost.publish(l);
+
+      // hjw added : Check if ego is on intersection and obstacles are in risky area 
+      int intersectionID = -1;
+      double closestIntersectionDistance = -1;
+      bool isInsideIntersection = false;
+      bool riskyLeftTurn = false;
+      bool riskyRightTurn = false;
+
+      PlannerHNS::PlanningHelpers::GetIntersectionCondition(m_CurrentPos, intersection_list_, m_PredictedObjects, intersectionID, closestIntersectionDistance, isInsideIntersection, riskyLeftTurn, riskyRightTurn);
+
+      autoware_msgs::IntersectionCondition ic_msg;
+      ic_msg.intersectionID = intersectionID;
+      ic_msg.intersectionDistance = closestIntersectionDistance;
+      ic_msg.isIntersection = isInsideIntersection;
+      ic_msg.riskyLeftTurn = riskyLeftTurn;
+      ic_msg.riskyRightTurn = riskyRightTurn;
+      
+      pub_IntersectionCondition.publish(ic_msg);
 
-      PlannerHNS::ROSHelpers::ConvertFromAutowareDetectedObjectToOpenPlannerDetectedObject(msg->objects.at(i), obj);
+    }
 
-      // transform center pose into map frame
-      geometry_msgs::PoseStamped pose_in_map;
-      pose_in_map.header = msg_obj.header;
-      pose_in_map.pose = msg_obj.pose;
-      try{
-        m_vtom_listener.transformPose("/map", pose_in_map, pose_in_map);
-      }
-      catch(tf::TransformException& ex)
+    if(m_TrajectoryCostsCalculator.m_TrajectoryCosts.size() == m_GeneratedRollOuts.size())
+    {
+      rubis_msgs::LaneArrayWithPoseTwist local_lanes;
+      for(unsigned int i=0; i < m_GeneratedRollOuts.size(); i++)
       {
-        // ROS_ERROR("Cannot transform object pose: %s", ex.what());
-        continue;
+        autoware_msgs::Lane lane;
+        PlannerHNS::ROSHelpers::ConvertFromLocalLaneToAutowareLane(m_GeneratedRollOuts.at(i), lane);
+        lane.closest_object_distance = m_TrajectoryCostsCalculator.m_TrajectoryCosts.at(i).closest_obj_distance;
+        lane.closest_object_velocity = m_TrajectoryCostsCalculator.m_TrajectoryCosts.at(i).closest_obj_velocity;
+        lane.cost = m_TrajectoryCostsCalculator.m_TrajectoryCosts.at(i).cost;
+        lane.is_blocked = m_TrajectoryCostsCalculator.m_TrajectoryCosts.at(i).bBlocked;
+        lane.lane_index = i;
+        local_lanes.lane_array.lanes.push_back(lane);
       }
-      // msg_obj.header.frame_id = "map";
-      obj.center.pos.x = pose_in_map.pose.position.x;
-      obj.center.pos.y = pose_in_map.pose.position.y;
-      obj.center.pos.z = pose_in_map.pose.position.z;
-
-      // transform contour into map frame
-      for(unsigned int j = 0; j < msg_obj.convex_hull.polygon.points.size(); j++){
-        geometry_msgs::PoseStamped contour_point_in_map;
-        contour_point_in_map.header = msg_obj.header;
-        contour_point_in_map.pose.position.x = msg_obj.convex_hull.polygon.points.at(j).x;
-        contour_point_in_map.pose.position.y = msg_obj.convex_hull.polygon.points.at(j).y;
-        contour_point_in_map.pose.position.z = msg_obj.convex_hull.polygon.points.at(j).z;
-
-        // For resolve TF malform, set orientation w to 1
-        contour_point_in_map.pose.orientation.w = 1;
 
-        try{
-          m_vtom_listener.transformPose("/map", contour_point_in_map, contour_point_in_map);
-        }
-        catch(tf::TransformException& ex){
-          // ROS_ERROR("Cannot transform contour pose: %s", ex.what());
-          continue;
-        }
+      rubis::instance_ = msg->instance;      
+      local_lanes.instance = rubis::instance_;
+      local_lanes.obj_instance = rubis::obj_instance_;
+      local_lanes.pose = msg->pose;
+      local_lanes.twist = msg->twist;
 
-        obj.contour.at(j).x = contour_point_in_map.pose.position.x;
-        obj.contour.at(j).y = contour_point_in_map.pose.position.y;
-        obj.contour.at(j).z = contour_point_in_map.pose.position.z;
-      }
+      pub_LocalWeightedTrajectoriesWithPoseTwist.publish(local_lanes);
+      // pub_LocalWeightedTrajectories.publish(local_lanes.lane_array);
+    }
+    else
+    {
+      ROS_ERROR("m_TrajectoryCosts.size() Not Equal m_GeneratedRollOuts.size()");
+    }
 
-      msg_obj.header.frame_id = "map";
+    if(m_TrajectoryCostsCalculator.m_TrajectoryCosts.size()>0)
+    {
+      visualization_msgs::MarkerArray all_rollOuts;
+      PlannerHNS::ROSHelpers::TrajectoriesToColoredMarkers(m_GeneratedRollOuts, m_TrajectoryCostsCalculator.m_TrajectoryCosts, m_CurrentBehavior.iTrajectory, all_rollOuts);
+      pub_LocalWeightedTrajectoriesRviz.publish(all_rollOuts);
 
-      m_PredictedObjects.push_back(obj);
-    }
+      PlannerHNS::ROSHelpers::ConvertCollisionPointsMarkers(m_TrajectoryCostsCalculator.m_CollisionPoints, m_CollisionsActual, m_CollisionsDummy);
+      pub_CollisionPointsRviz.publish(m_CollisionsActual);
 
-    int image_obj_center_x = msg_obj.x+msg_obj.width/2;
-    int image_obj_center_y = msg_obj.y+msg_obj.height/2;
-    if (msg_obj.label == "person"){// If person is detected only in image
-      
-      // TO ERASE
-      // ROS_WARN("object height:%d // thr: %d\n", msg_obj.height, m_pedestrian_stop_img_height_threshold);
-      printf("center_x %d \n left: %d \n right %d\n\n\n", image_obj_center_x, image_person_detection_range_left, image_person_detection_range_right);
-      if(image_obj_center_x >= image_person_detection_range_left && image_obj_center_x <= image_person_detection_range_right){ 
-        double temp_x_distance = 1000;
-        if(msg_obj.height >= m_pedestrian_stop_img_height_threshold) temp_x_distance = 10;
-        if(abs(temp_x_distance) < abs(distance_to_pedestrian)) distance_to_pedestrian = temp_x_distance;
-      }
+      //Visualize Safety Box
+      visualization_msgs::Marker safety_box;
+      PlannerHNS::ROSHelpers::ConvertFromPlannerHRectangleToAutowareRviz(m_TrajectoryCostsCalculator.m_SafetyBorder.points, safety_box);
+      pub_SafetyBorderRviz.publish(safety_box);
     }
   }
+  else
+    sub_GlobalPlannerPaths = nh.subscribe("/lane_waypoints_array",   1,    &TrajectoryEval::callbackGetGlobalPlannerPath,   this);
 
-  // Publish Sprint Switch
-  std_msgs::Bool sprint_switch_msg;
 
-  if(vehicle_cnt != 0){
-    m_noVehicleCnt = 0;
-    sprint_switch_msg.data = false;
-  }
-  else{ // No vehicle is exist in front of the car
-    if(m_noVehicleCnt < m_SprintDecisionTime*10) {
-      m_noVehicleCnt +=1;
-      sprint_switch_msg.data = false;
-    }
-    else if (m_noVehicleCnt >= 5) sprint_switch_msg.data = true;
-  }  
-  pub_SprintSwitch.publish(sprint_switch_msg);
+  rubis::stop_task_profiling(rubis::instance_, 0);  
+}
 
-  std_msgs::Float64 distanceToPedestrianMsg; 
-  distanceToPedestrianMsg.data = distance_to_pedestrian;
-  pub_DistanceToPedestrian.publish(distanceToPedestrianMsg);
-  */
+void TrajectoryEval::callbackGetPredictedObjects(const rubis_msgs::DetectedObjectArrayConstPtr& msg)
+{  
+  object_msg_ = msg->object_array;
+  rubis::obj_instance_ = msg->obj_instance;
+  is_objects_updated_ = true;
 }
 
-void TrajectoryEval::callbackGetRubisPredictedObjects(const rubis_msgs::DetectedObjectArrayConstPtr& msg)
-{ 
+void TrajectoryEval::_callbackGetPredictedObjects(const autoware_msgs::DetectedObjectArray& objects_msg){
   m_PredictedObjects.clear();
   bPredictedObjects = true;
   double distance_to_pedestrian = 1000;
   int image_person_detection_range_left = m_ImageWidth/2 - m_ImageWidth*m_PedestrianImageDetectionRange/2;
   int image_person_detection_range_right = m_ImageWidth/2 + m_ImageWidth*m_PedestrianImageDetectionRange/2;
-  
   int image_vehicle_detection_range_left = m_ImageWidth/2 - m_ImageWidth*m_VehicleImageDetectionRange/2;
   int image_vehicle_detection_range_right = m_ImageWidth/2 + m_ImageWidth*m_VehicleImageDetectionRange/2;
-
   int vehicle_cnt = 0;
 
   PlannerHNS::DetectedObject obj;  
-
-  for(unsigned int i = 0 ; i <msg->object_array.objects.size(); i++)
+  for(unsigned int i = 0 ; i <objects_msg.objects.size(); i++)
   {    
-    if(msg->object_array.objects.at(i).pose.position.y < -20 || msg->object_array.objects.at(i).pose.position.y > 20)
+    if(objects_msg.objects.at(i).pose.position.y < -20 || objects_msg.objects.at(i).pose.position.y > 20)
       continue;    
       
-    if(msg->object_array.objects.at(i).pose.position.z > 1 || msg->object_array.objects.at(i).pose.position.z < -1.5)
+    if(objects_msg.objects.at(i).pose.position.z > 1 || objects_msg.objects.at(i).pose.position.z < -1.5)
       continue;
 
-    autoware_msgs::DetectedObject msg_obj = msg->object_array.objects.at(i);     
+    autoware_msgs::DetectedObject msg_obj = objects_msg.objects.at(i);     
 
     if(msg_obj.label == "car" || msg_obj.label == "truck" || msg_obj.label == "bus"){
       vehicle_cnt += 1;
     }
 
-    PlannerHNS::ROSHelpers::ConvertFromAutowareDetectedObjectToOpenPlannerDetectedObject(msg->object_array.objects.at(i), obj);
-
+    PlannerHNS::ROSHelpers::ConvertFromAutowareDetectedObjectToOpenPlannerDetectedObject(objects_msg.objects.at(i), obj);
     geometry_msgs::PoseStamped pose_in_map;
     pose_in_map.header = msg_obj.header;
     pose_in_map.pose = msg_obj.pose;
@@ -468,7 +471,6 @@ void TrajectoryEval::callbackGetRubisPredictedObjects(const rubis_msgs::Detected
         if(abs(temp_x_distance) < abs(distance_to_pedestrian)) distance_to_pedestrian = temp_x_distance;
       }
     }
-    
   }
 
   // Publish Sprint Switch
@@ -485,6 +487,7 @@ void TrajectoryEval::callbackGetRubisPredictedObjects(const rubis_msgs::Detected
     }
     else if (m_noVehicleCnt >= 5) sprint_switch_msg.data = true;
   }  
+
   pub_SprintSwitch.publish(sprint_switch_msg);
 
   std_msgs::Float64 distanceToPedestrianMsg; 
@@ -510,6 +513,11 @@ void TrajectoryEval::UpdateMyParams()
   _nh.getParam("/op_trajectory_evaluator/weightLong", m_PlanningParams.weightLong);
   _nh.getParam("/op_trajectory_evaluator/weightLat", m_PlanningParams.weightLat);
   _nh.getParam("/op_trajectory_evaluator/LateralSkipDistance", m_PlanningParams.LateralSkipDistance);
+
+  _nh.getParam("/op_trajectory_evaluator/lateralBlockingThreshold", m_PlanningParams.lateralBlockingThreshold);
+  _nh.getParam("/op_trajectory_evaluator/frontLongitudinalBlockingThreshold", m_PlanningParams.frontLongitudinalBlockingThreshold);
+  _nh.getParam("/op_trajectory_evaluator/rearLongitudinalBlockingThreshold", m_PlanningParams.rearLongitudinalBlockingThreshold);
+  _nh.getParam("/op_trajectory_evaluator/enableDebug", m_PlanningParams.enableDebug);
 }
 
 bool TrajectoryEval::UpdateTf()
@@ -533,150 +541,35 @@ void TrajectoryEval::MainLoop()
 {
   ros::NodeHandle private_nh("~");
 
-  // Scheduling Setup
-  int task_scheduling_flag;
-  int task_profiling_flag;
+  // Scheduling & Profiling Setup
+  std::string node_name = ros::this_node::getName();
   std::string task_response_time_filename;
+  private_nh.param<std::string>(node_name+"/task_response_time_filename", task_response_time_filename, "~/Documents/profiling/response_time/op_trajectory_evaluator.csv");
+
   int rate;
-  double task_minimum_inter_release_time;
-  double task_execution_time;
-  double task_relative_deadline; 
+  private_nh.param<int>(node_name+"/rate", rate, 10);
 
-  private_nh.param<int>("/op_trajectory_evaluator/task_scheduling_flag", task_scheduling_flag, 0);
-  private_nh.param<int>("/op_trajectory_evaluator/task_profiling_flag", task_profiling_flag, 0);
-  private_nh.param<std::string>("/op_trajectory_evaluator/task_response_time_filename", task_response_time_filename, "~/Documents/profiling/response_time/op_trajectory_evaluator.csv");
-  private_nh.param<int>("/op_trajectory_evaluator/rate", rate, 10);
-  private_nh.param("/op_trajectory_evaluator/task_minimum_inter_release_time", task_minimum_inter_release_time, (double)10);
-  private_nh.param("/op_trajectory_evaluator/task_execution_time", task_execution_time, (double)10);
-  private_nh.param("/op_trajectory_evaluator/task_relative_deadline", task_relative_deadline, (double)10);  
+  struct rubis::sched_attr attr;
+  std::string policy;
+  int priority, exec_time ,deadline, period;
+    
+  private_nh.param(node_name+"/task_scheduling_configs/policy", policy, std::string("NONE"));    
+  private_nh.param(node_name+"/task_scheduling_configs/priority", priority, 99);
+  private_nh.param(node_name+"/task_scheduling_configs/exec_time", exec_time, 0);
+  private_nh.param(node_name+"/task_scheduling_configs/deadline", deadline, 0);
+  private_nh.param(node_name+"/task_scheduling_configs/period", period, 0);
+  attr = rubis::create_sched_attr(priority, exec_time, deadline, period);    
+  rubis::init_task_scheduling(policy, attr);
 
-  if(task_profiling_flag) rubis::sched::init_task_profiling(task_response_time_filename);
+  rubis::init_task_profiling(task_response_time_filename);
 
   PlannerHNS::WayPoint prevState, state_change;
 
   // Add Crossing Info from yaml file
-  XmlRpc::XmlRpcValue intersection_xml;
-  std::vector<PlannerHNS::Crossing> intersection_list;
+  XmlRpc::XmlRpcValue intersection_xml;  
   nh.getParam("/op_trajectory_evaluator/intersection_list", intersection_xml);
-  PlannerHNS::MappingHelpers::ConstructIntersection_RUBIS(intersection_list, intersection_xml);
-
-  
-
-  ros::Rate loop_rate(rate);
-  if(!task_scheduling_flag && !task_profiling_flag) loop_rate = ros::Rate(100);
+  PlannerHNS::MappingHelpers::ConstructIntersection_RUBIS(intersection_list_, intersection_xml);
 
-  struct timespec start_time, end_time;
-
-  while (ros::ok())
-  {
-    if(task_profiling_flag) rubis::sched::start_task_profiling();
-
-    if(rubis::sched::is_task_ready_ == TASK_READY && rubis::sched::task_state_ == TASK_STATE_READY){
-      if(task_scheduling_flag) rubis::sched::request_task_scheduling(task_minimum_inter_release_time, task_execution_time, task_relative_deadline); 
-      rubis::sched::task_state_ = TASK_STATE_RUNNING;     
-    }
-
-    UpdateMyParams();
-    UpdateTf();
-    
-    ros::spinOnce();
-    PlannerHNS::TrajectoryCost tc;
-
-    if(bNewCurrentPos && m_GlobalPaths.size()>0)
-    {
-      m_GlobalPathSections.clear();
-
-      for(unsigned int i = 0; i < m_GlobalPathsToUse.size(); i++)
-      {
-        t_centerTrajectorySmoothed.clear();
-        PlannerHNS::PlanningHelpers::ExtractPartFromPointToDistanceDirectionFast(m_GlobalPathsToUse.at(i), m_CurrentPos, m_PlanningParams.horizonDistance , m_PlanningParams.pathDensity ,t_centerTrajectorySmoothed);
-        m_GlobalPathSections.push_back(t_centerTrajectorySmoothed);
-      }
-
-      if(m_GlobalPathSections.size()>0)
-      {
-        if(m_bUseMoveingObjectsPrediction)
-          tc = m_TrajectoryCostsCalculator.DoOneStepDynamic(m_GeneratedRollOuts, m_GlobalPathSections.at(0), m_CurrentPos,m_PlanningParams,  m_CarInfo,m_VehicleStatus, m_PredictedObjects, m_CurrentBehavior.iTrajectory);
-        else
-          tc = m_TrajectoryCostsCalculator.DoOneStepStatic(m_GeneratedRollOuts, m_GlobalPathSections.at(0), m_CurrentPos,  m_PlanningParams,  m_CarInfo,m_VehicleStatus, m_PredictedObjects, m_CurrentBehavior.state);
-
-        autoware_msgs::Lane l;
-        l.closest_object_distance = tc.closest_obj_distance;
-        l.closest_object_velocity = tc.closest_obj_velocity;
-        l.cost = tc.cost;
-        l.is_blocked = tc.bBlocked;
-        l.lane_index = tc.index;
-        pub_TrajectoryCost.publish(l);
-
-        // hjw added : Check if ego is on intersection and obstacles are in risky area 
-        int intersectionID = -1;
-        double closestIntersectionDistance = -1;
-        bool isInsideIntersection = false;
-        bool riskyLeftTurn = false;
-        bool riskyRightTurn = false;
-
-        PlannerHNS::PlanningHelpers::GetIntersectionCondition(m_CurrentPos, intersection_list, m_PredictedObjects, intersectionID, closestIntersectionDistance, isInsideIntersection, riskyLeftTurn, riskyRightTurn);
-
-        autoware_msgs::IntersectionCondition ic_msg;
-        ic_msg.intersectionID = intersectionID;
-        ic_msg.intersectionDistance = closestIntersectionDistance;
-        ic_msg.isIntersection = isInsideIntersection;
-        ic_msg.riskyLeftTurn = riskyLeftTurn;
-        ic_msg.riskyRightTurn = riskyRightTurn;
-        
-        pub_IntersectionCondition.publish(ic_msg);
-
-      }
-
-      if(m_TrajectoryCostsCalculator.m_TrajectoryCosts.size() == m_GeneratedRollOuts.size())
-      {
-        autoware_msgs::LaneArray local_lanes;
-        for(unsigned int i=0; i < m_GeneratedRollOuts.size(); i++)
-        {
-          autoware_msgs::Lane lane;
-          PlannerHNS::ROSHelpers::ConvertFromLocalLaneToAutowareLane(m_GeneratedRollOuts.at(i), lane);
-          lane.closest_object_distance = m_TrajectoryCostsCalculator.m_TrajectoryCosts.at(i).closest_obj_distance;
-          lane.closest_object_velocity = m_TrajectoryCostsCalculator.m_TrajectoryCosts.at(i).closest_obj_velocity;
-          lane.cost = m_TrajectoryCostsCalculator.m_TrajectoryCosts.at(i).cost;
-          lane.is_blocked = m_TrajectoryCostsCalculator.m_TrajectoryCosts.at(i).bBlocked;
-          lane.lane_index = i;
-          local_lanes.lanes.push_back(lane);
-        }
-
-        pub_LocalWeightedTrajectories.publish(local_lanes);
-        rubis::sched::task_state_ = TASK_STATE_DONE;
-      }
-      else
-      {
-        ROS_ERROR("m_TrajectoryCosts.size() Not Equal m_GeneratedRollOuts.size()");
-      }
-
-      if(m_TrajectoryCostsCalculator.m_TrajectoryCosts.size()>0)
-      {
-        visualization_msgs::MarkerArray all_rollOuts;
-        PlannerHNS::ROSHelpers::TrajectoriesToColoredMarkers(m_GeneratedRollOuts, m_TrajectoryCostsCalculator.m_TrajectoryCosts, m_CurrentBehavior.iTrajectory, all_rollOuts);
-        pub_LocalWeightedTrajectoriesRviz.publish(all_rollOuts);
-
-        PlannerHNS::ROSHelpers::ConvertCollisionPointsMarkers(m_TrajectoryCostsCalculator.m_CollisionPoints, m_CollisionsActual, m_CollisionsDummy);
-        pub_CollisionPointsRviz.publish(m_CollisionsActual);
-
-        //Visualize Safety Box
-        visualization_msgs::Marker safety_box;
-        PlannerHNS::ROSHelpers::ConvertFromPlannerHRectangleToAutowareRviz(m_TrajectoryCostsCalculator.m_SafetyBorder.points, safety_box);
-        pub_SafetyBorderRviz.publish(safety_box);
-      }
-    }
-    else
-      sub_GlobalPlannerPaths = nh.subscribe("/lane_waypoints_array",   1,    &TrajectoryEval::callbackGetGlobalPlannerPath,   this);
-
-    if(task_profiling_flag) rubis::sched::stop_task_profiling(0, rubis::sched::task_state_);
-
-    if(rubis::sched::is_task_ready_ == TASK_READY && rubis::sched::task_state_ == TASK_STATE_DONE){
-      if(task_scheduling_flag) rubis::sched::yield_task_scheduling();
-      rubis::sched::task_state_ = TASK_STATE_READY;
-    }
-    loop_rate.sleep();
-  }
+  ros::spin();
 }
-
 }
diff --git a/autoware.ai/src/autoware/core_planning/op_local_planner/nodes/op_trajectory_evaluator/op_trajectory_evaluator_core.mainloop.cpp b/autoware.ai/src/autoware/core_planning/op_local_planner/nodes/op_trajectory_evaluator/op_trajectory_evaluator_core.mainloop.cpp
new file mode 100644
index 00000000..a1ce5e83
--- /dev/null
+++ b/autoware.ai/src/autoware/core_planning/op_local_planner/nodes/op_trajectory_evaluator/op_trajectory_evaluator_core.mainloop.cpp
@@ -0,0 +1,596 @@
+/*
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "op_trajectory_evaluator_core.h"
+#include "op_ros_helpers/op_ROSHelpers.h"
+#include "op_planner/MappingHelpers.h"
+#include <rubis_lib/sched.hpp>
+
+namespace TrajectoryEvaluatorNS
+{
+
+TrajectoryEval::TrajectoryEval()
+{
+  bNewCurrentPos = false;
+  bVehicleStatus = false;
+  bWayGlobalPath = false;
+  bWayGlobalPathToUse = false;
+  m_bUseMoveingObjectsPrediction = false;
+  m_noVehicleCnt = 0;
+
+  ros::NodeHandle _nh;
+  UpdatePlanningParams(_nh);
+
+  tf::StampedTransform transform;
+  PlannerHNS::ROSHelpers::GetTransformFromTF("map", "world", transform);
+  m_OriginPos.position.x  = transform.getOrigin().x();
+  m_OriginPos.position.y  = transform.getOrigin().y();
+  m_OriginPos.position.z  = transform.getOrigin().z();
+
+  pub_CollisionPointsRviz = nh.advertise<visualization_msgs::MarkerArray>("dynamic_collision_points_rviz", 1);
+  pub_LocalWeightedTrajectoriesRviz = nh.advertise<visualization_msgs::MarkerArray>("local_trajectories_eval_rviz", 1);
+  pub_LocalWeightedTrajectories = nh.advertise<rubis_msgs::LaneArrayWithPoseTwist>("local_weighted_trajectories", 1);
+  pub_LocalWeightedTrajectoriesWithPoseTwist = nh.advertise<rubis_msgs::LaneArrayWithPoseTwist>("local_weighted_trajectories_with_pose_twist", 1);
+  pub_TrajectoryCost = nh.advertise<autoware_msgs::Lane>("local_trajectory_cost", 1);
+  pub_SafetyBorderRviz = nh.advertise<visualization_msgs::Marker>("safety_border", 1);
+  pub_DistanceToPedestrian = nh.advertise<std_msgs::Float64>("distance_to_pedestrian", 1);
+  pub_IntersectionCondition = nh.advertise<autoware_msgs::IntersectionCondition>("intersection_condition", 1);
+  pub_SprintSwitch = nh.advertise<std_msgs::Bool>("sprint_switch", 1);
+
+  // sub_current_pose = nh.subscribe("/current_pose", 10, &TrajectoryEval::callbackGetCurrentPose, this);
+  // sub_current_state = nh.subscribe("/current_state", 10, &TrajectoryEval::callbackGetCurrentState, this);
+
+  int bVelSource = 1;
+  _nh.getParam("/op_trajectory_evaluator/velocitySource", bVelSource);
+  if(bVelSource == 0)
+    sub_robot_odom = nh.subscribe("/odom", 10, &TrajectoryEval::callbackGetRobotOdom, this);
+  // else if(bVelSource == 1)
+  //   sub_current_velocity = nh.subscribe("/current_velocity", 10, &TrajectoryEval::callbackGetVehicleStatus, this);
+  else if(bVelSource == 2)
+    sub_can_info = nh.subscribe("/can_info", 10, &TrajectoryEval::callbackGetCANInfo, this);
+
+  sub_GlobalPlannerPaths = nh.subscribe("/lane_waypoints_array", 1, &TrajectoryEval::callbackGetGlobalPlannerPath, this);
+  sub_LocalPlannerPaths = nh.subscribe("/local_trajectories_with_pose_twist", 1, &TrajectoryEval::callbackGetLocalPlannerPath, this);
+  sub_predicted_objects = nh.subscribe("/predicted_objects", 1, &TrajectoryEval::callbackGetPredictedObjects, this);
+  sub_current_behavior = nh.subscribe("/current_behavior", 1, &TrajectoryEval::callbackGetBehaviorState, this);
+
+  PlannerHNS::ROSHelpers::InitCollisionPointsMarkers(50, m_CollisionsDummy);
+
+  while(1){
+    if(UpdateTf() == true)
+      break;
+  }
+}
+
+TrajectoryEval::~TrajectoryEval()
+{
+}
+
+void TrajectoryEval::UpdatePlanningParams(ros::NodeHandle& _nh)
+{
+  _nh.getParam("/op_trajectory_evaluator/enablePrediction", m_bUseMoveingObjectsPrediction);
+
+  _nh.getParam("/op_common_params/horizontalSafetyDistance", m_PlanningParams.horizontalSafetyDistancel);
+  _nh.getParam("/op_common_params/verticalSafetyDistance", m_PlanningParams.verticalSafetyDistance);
+  _nh.getParam("/op_common_params/enableSwerving", m_PlanningParams.enableSwerving);
+  if(m_PlanningParams.enableSwerving)
+    m_PlanningParams.enableFollowing = true;
+  else
+    _nh.getParam("/op_common_params/enableFollowing", m_PlanningParams.enableFollowing);
+
+  _nh.getParam("/op_common_params/enableTrafficLightBehavior", m_PlanningParams.enableTrafficLightBehavior);
+  _nh.getParam("/op_common_params/enableStopSignBehavior", m_PlanningParams.enableStopSignBehavior);
+
+  _nh.getParam("/op_common_params/maxVelocity", m_PlanningParams.maxSpeed);
+  _nh.getParam("/op_common_params/minVelocity", m_PlanningParams.minSpeed);
+  _nh.getParam("/op_common_params/maxLocalPlanDistance", m_PlanningParams.microPlanDistance);
+
+  _nh.getParam("/op_common_params/pathDensity", m_PlanningParams.pathDensity);
+
+  _nh.getParam("/op_common_params/rollOutDensity", m_PlanningParams.rollOutDensity);
+  if(m_PlanningParams.enableSwerving)
+    _nh.getParam("/op_common_params/rollOutsNumber", m_PlanningParams.rollOutNumber);
+  else
+    m_PlanningParams.rollOutNumber = 0;
+
+  std::cout << "Rolls Number: " << m_PlanningParams.rollOutNumber << std::endl;
+
+  _nh.getParam("/op_common_params/horizonDistance", m_PlanningParams.horizonDistance);
+  _nh.getParam("/op_common_params/minFollowingDistance", m_PlanningParams.minFollowingDistance);
+  _nh.getParam("/op_common_params/minDistanceToAvoid", m_PlanningParams.minDistanceToAvoid);
+  _nh.getParam("/op_common_params/maxDistanceToAvoid", m_PlanningParams.maxDistanceToAvoid);
+  _nh.getParam("/op_common_params/speedProfileFactor", m_PlanningParams.speedProfileFactor);
+
+  _nh.getParam("/op_common_params/enableLaneChange", m_PlanningParams.enableLaneChange);
+
+  _nh.getParam("/op_common_params/width", m_CarInfo.width);
+  _nh.getParam("/op_common_params/length", m_CarInfo.length);
+  _nh.getParam("/op_common_params/wheelBaseLength", m_CarInfo.wheel_base);
+  _nh.getParam("/op_common_params/turningRadius", m_CarInfo.turning_radius);
+  _nh.getParam("/op_common_params/maxSteerAngle", m_CarInfo.max_steer_angle);
+  _nh.getParam("/op_common_params/maxAcceleration", m_CarInfo.max_acceleration);
+  _nh.getParam("/op_common_params/maxDeceleration", m_CarInfo.max_deceleration);
+  m_CarInfo.max_speed_forward = m_PlanningParams.maxSpeed;
+  m_CarInfo.min_speed_forward = m_PlanningParams.minSpeed;
+
+  _nh.param("/op_trajectory_evaluator/PedestrianRightThreshold", m_PedestrianRightThreshold, 7.0);
+  _nh.param("/op_trajectory_evaluator/PedestrianLeftThreshold", m_PedestrianLeftThreshold, 2.0);
+  _nh.param("/op_trajectory_evaluator/PedestrianImageDetectionRange", m_PedestrianImageDetectionRange, 0.7);
+  _nh.param("/op_trajectory_evaluator/PedestrianStopImgHeightThreshold", m_pedestrian_stop_img_height_threshold, 120);
+  _nh.param("/op_trajectory_evaluator/ImageWidth", m_ImageWidth, 1920);
+  _nh.param("/op_trajectory_evaluator/ImageHeight", m_ImageHeight, 1080);
+  _nh.param("/op_trajectory_evaluator/VehicleImageDetectionRange", m_VehicleImageDetectionRange, 0.3);
+  _nh.param("/op_trajectory_evaluator/VehicleImageWidthThreshold", m_VehicleImageWidthThreshold, 0.05);
+  _nh.param("/op_trajectory_evaluator/SprintDecisionTime", m_SprintDecisionTime, 5.0);
+  
+  
+  m_VehicleImageWidthThreshold = m_VehicleImageWidthThreshold * m_ImageWidth;
+  m_PedestrianRightThreshold *= -1;
+
+}
+
+// void TrajectoryEval::callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr& msg)
+// {
+//   m_CurrentPos = PlannerHNS::WayPoint(msg->pose.position.x, msg->pose.position.y, msg->pose.position.z, tf::getYaw(msg->pose.orientation));
+//   bNewCurrentPos = true;
+// }
+
+// void TrajectoryEval::callbackGetVehicleStatus(const geometry_msgs::TwistStampedConstPtr& msg)
+// {
+//   m_VehicleStatus.speed = msg->twist.linear.x;
+//   m_CurrentPos.v = m_VehicleStatus.speed;
+//   if(fabs(msg->twist.linear.x) > 0.25)
+//     m_VehicleStatus.steer = atan(m_CarInfo.wheel_base * msg->twist.angular.z/msg->twist.linear.x);
+//   UtilityHNS::UtilityH::GetTickCount(m_VehicleStatus.tStamp);
+//   bVehicleStatus = true;
+// }
+
+void TrajectoryEval::callbackGetCANInfo(const autoware_can_msgs::CANInfoConstPtr &msg)
+{
+  m_VehicleStatus.speed = msg->speed/3.6;
+  m_CurrentPos.v = m_VehicleStatus.speed;
+  m_VehicleStatus.steer = msg->angle * m_CarInfo.max_steer_angle / m_CarInfo.max_steer_value;
+  UtilityHNS::UtilityH::GetTickCount(m_VehicleStatus.tStamp);
+  bVehicleStatus = true;
+}
+
+void TrajectoryEval::callbackGetRobotOdom(const nav_msgs::OdometryConstPtr& msg)
+{
+  m_VehicleStatus.speed = msg->twist.twist.linear.x;
+  m_CurrentPos.v = m_VehicleStatus.speed;
+  if(fabs(msg->twist.twist.linear.x) > 0.25)
+    m_VehicleStatus.steer = atan(m_CarInfo.wheel_base * msg->twist.twist.angular.z/msg->twist.twist.linear.x);
+  UtilityHNS::UtilityH::GetTickCount(m_VehicleStatus.tStamp);
+  bVehicleStatus = true;
+}
+
+void TrajectoryEval::callbackGetGlobalPlannerPath(const autoware_msgs::LaneArrayConstPtr& msg)
+{
+  if(msg->lanes.size() > 0)
+  {
+
+    bool bOldGlobalPath = m_GlobalPaths.size() == msg->lanes.size();
+
+    m_GlobalPaths.clear();
+
+    for(unsigned int i = 0 ; i < msg->lanes.size(); i++)
+    {
+      PlannerHNS::ROSHelpers::ConvertFromAutowareLaneToLocalLane(msg->lanes.at(i), m_temp_path);
+
+      PlannerHNS::PlanningHelpers::CalcAngleAndCost(m_temp_path);
+      m_GlobalPaths.push_back(m_temp_path);
+
+      if(bOldGlobalPath)
+      {
+        bOldGlobalPath = PlannerHNS::PlanningHelpers::CompareTrajectories(m_temp_path, m_GlobalPaths.at(i));
+      }
+    }
+
+    if(!bOldGlobalPath)
+    {
+      bWayGlobalPath = true;
+      std::cout << "Received New Global Path Evaluator! " << std::endl;
+    }
+    else
+    {
+      m_GlobalPaths.clear();
+    }
+  }
+}
+
+void TrajectoryEval::callbackGetLocalPlannerPath(const rubis_msgs::LaneArrayWithPoseTwistConstPtr& msg)
+{
+  rubis::instance_ = msg->instance;
+  // Callback
+  m_CurrentPos = PlannerHNS::WayPoint(msg->pose.pose.position.x, msg->pose.pose.position.y, msg->pose.pose.position.z, tf::getYaw(msg->pose.pose.orientation));
+  bNewCurrentPos = true;
+
+  m_VehicleStatus.speed = msg->twist.twist.linear.x;
+  m_CurrentPos.v = m_VehicleStatus.speed;
+  if(fabs(msg->twist.twist.linear.x) > 0.25)
+    m_VehicleStatus.steer = atan(m_CarInfo.wheel_base * msg->twist.twist.angular.z/msg->twist.twist.linear.x);
+  UtilityHNS::UtilityH::GetTickCount(m_VehicleStatus.tStamp);
+  bVehicleStatus = true;  
+
+  if(msg->lane_array.lanes.size() > 0)
+  {
+    m_GeneratedRollOuts.clear();
+    int globalPathId_roll_outs = -1;
+
+    for(unsigned int i = 0 ; i < msg->lane_array.lanes.size(); i++)
+    {
+      std::vector<PlannerHNS::WayPoint> path;
+      PlannerHNS::ROSHelpers::ConvertFromAutowareLaneToLocalLane(msg->lane_array.lanes.at(i), path);
+      m_GeneratedRollOuts.push_back(path);
+      if(path.size() > 0)
+        globalPathId_roll_outs = path.at(0).gid;
+    }
+
+    if(bWayGlobalPath && m_GlobalPaths.size() > 0 && m_GlobalPaths.at(0).size() > 0)
+    {
+      int globalPathId = m_GlobalPaths.at(0).at(0).gid;
+      std::cout << "Before Synchronization At Trajectory Evaluator: GlobalID: " <<  globalPathId << ", LocalID: " << globalPathId_roll_outs << std::endl;
+
+      if(globalPathId_roll_outs == globalPathId)
+      {
+        bWayGlobalPath = false;
+        m_GlobalPathsToUse = m_GlobalPaths;
+        std::cout << "Synchronization At Trajectory Evaluator: GlobalID: " <<  globalPathId << ", LocalID: " << globalPathId_roll_outs << std::endl;
+      }
+    }
+
+    bRollOuts = true;
+  }
+}
+
+void TrajectoryEval::callbackGetPredictedObjects(const autoware_msgs::DetectedObjectArrayConstPtr& msg)
+{  
+  m_PredictedObjects.clear();
+  bPredictedObjects = true;
+  double distance_to_pedestrian = 1000;
+  int image_person_detection_range_left = m_ImageWidth/2 - m_ImageWidth*m_PedestrianImageDetectionRange/2;
+  int image_person_detection_range_right = m_ImageWidth/2 + m_ImageWidth*m_PedestrianImageDetectionRange/2;
+  
+  int image_vehicle_detection_range_left = m_ImageWidth/2 - m_ImageWidth*m_VehicleImageDetectionRange/2;
+  int image_vehicle_detection_range_right = m_ImageWidth/2 + m_ImageWidth*m_VehicleImageDetectionRange/2;
+
+  int vehicle_cnt = 0;
+
+  PlannerHNS::DetectedObject obj;
+  for(unsigned int i = 0 ; i <msg->objects.size(); i++)
+  {    
+    if(msg->objects.at(i).pose.position.y < -20 || msg->objects.at(i).pose.position.y > 20)
+      continue;    
+      
+    if(msg->objects.at(i).pose.position.z > 1 || msg->objects.at(i).pose.position.z < -1.5)
+      continue;
+
+    autoware_msgs::DetectedObject msg_obj = msg->objects.at(i);     
+
+    // #### Decison making for objects
+    
+    if(msg_obj.id > 0) // If fusion object is detected
+    {
+      // calculate distance to person first
+      // if(msg_obj.label == "person"){        
+      //   std::cout<<"Pedestrian box size(width x height):"<<msg_obj.width<<" "<<msg_obj.height<<std::endl;
+      //   geometry_msgs::PoseStamped pose;
+      //   pose.header = msg_obj.header;
+      //   pose.pose = msg_obj.pose;
+      //   try{
+      //     m_vtob_listener.transformPose("/base_link", pose, pose);
+      //     double temp_x_distance = pose.pose.position.x;
+      //     double temp_y_distance = pose.pose.position.y;
+      //     // y-axis: Left + / Right -          
+      //     if(temp_y_distance > m_PedestrianLeftThreshold || temp_y_distance < m_PedestrianRightThreshold ) continue;
+      //     if(abs(temp_x_distance) < abs(distance_to_pedestrian)) distance_to_pedestrian = temp_x_distance;          
+      //   }
+      //   catch(tf::TransformException& ex){
+      //     // ROS_ERROR("Cannot transform person pose: %s", ex.what());
+
+      //   }
+      // }
+
+      if(msg_obj.label == "car" || msg_obj.label == "truck" || msg_obj.label == "bus"){
+        vehicle_cnt += 1;
+      }
+
+      PlannerHNS::ROSHelpers::ConvertFromAutowareDetectedObjectToOpenPlannerDetectedObject(msg->objects.at(i), obj);
+
+
+      // transform center pose into map frame
+      geometry_msgs::PoseStamped pose_in_map;
+      pose_in_map.header = msg_obj.header;
+      pose_in_map.pose = msg_obj.pose;
+      try{
+        m_vtom_listener.transformPose("/map", pose_in_map, pose_in_map);
+      }
+      catch(tf::TransformException& ex)
+      {
+        // ROS_ERROR("Cannot transform object pose: %s", ex.what());
+        continue;
+      }
+      // msg_obj.header.frame_id = "map";
+      obj.center.pos.x = pose_in_map.pose.position.x;
+      obj.center.pos.y = pose_in_map.pose.position.y;
+      obj.center.pos.z = pose_in_map.pose.position.z;
+
+      // transform contour into map frame
+      for(unsigned int j = 0; j < msg_obj.convex_hull.polygon.points.size(); j++){
+        geometry_msgs::PoseStamped contour_point_in_map;
+        contour_point_in_map.header = msg_obj.header;
+        contour_point_in_map.pose.position.x = msg_obj.convex_hull.polygon.points.at(j).x;
+        contour_point_in_map.pose.position.y = msg_obj.convex_hull.polygon.points.at(j).y;
+        contour_point_in_map.pose.position.z = msg_obj.convex_hull.polygon.points.at(j).z;
+
+        // For resolve TF malform, set orientation w to 1
+        contour_point_in_map.pose.orientation.w = 1;
+
+        try{
+          m_vtom_listener.transformPose("/map", contour_point_in_map, contour_point_in_map);
+        }
+        catch(tf::TransformException& ex){
+          // ROS_ERROR("Cannot transform contour pose: %s", ex.what());
+          continue;
+        }
+
+        obj.contour.at(j).x = contour_point_in_map.pose.position.x;
+        obj.contour.at(j).y = contour_point_in_map.pose.position.y;
+        obj.contour.at(j).z = contour_point_in_map.pose.position.z;
+      }
+
+      msg_obj.header.frame_id = "map";
+
+      m_PredictedObjects.push_back(obj);
+    }
+    /*
+    else{ // If object is only detected at vision
+      int image_obj_center_x = msg_obj.x+msg_obj.width/2;
+      int image_obj_center_y = msg_obj.y+msg_obj.height/2;
+      // if (msg_obj.label == "person"){// If person is detected only in image
+      //   // TO ERASE
+      //   std::cout<<"object height:" << msg_obj.height << " / threshold:" << m_pedestrian_stop_img_height_threshold << std::endl;
+      //   if(image_obj_center_x >= image_person_detection_range_left && image_obj_center_x <= image_person_detection_range_right){ 
+      //     double temp_x_distance = 1000;
+      //     if(msg_obj.height >= m_pedestrian_stop_img_height_threshold) temp_x_distance = 10;
+      //     if(abs(temp_x_distance) < abs(distance_to_pedestrian)) distance_to_pedestrian = temp_x_distance;
+      //   }
+      // }                    
+      // else 
+      if(msg_obj.label == "car" || msg_obj.label == "truck" || msg_obj.label == "bus"){            
+        if((msg_obj.width > m_VehicleImageWidthThreshold) 
+              && (image_obj_center_x > image_vehicle_detection_range_left) 
+              && (image_obj_center_x < image_vehicle_detection_range_right)
+        )
+        {          
+          vehicle_cnt+=1;        
+        }
+      }
+    }
+    */
+
+    int image_obj_center_x = msg_obj.x+msg_obj.width/2;
+    int image_obj_center_y = msg_obj.y+msg_obj.height/2;
+    if (msg_obj.label == "person"){// If person is detected only in image
+      
+      // TO ERASE
+      // ROS_WARN("object height:%d // thr: %d\n", msg_obj.height, m_pedestrian_stop_img_height_threshold);
+      printf("center_x %d \n left: %d \n right %d\n\n\n", image_obj_center_x, image_person_detection_range_left, image_person_detection_range_right);
+      if(image_obj_center_x >= image_person_detection_range_left && image_obj_center_x <= image_person_detection_range_right){ 
+        double temp_x_distance = 1000;
+        if(msg_obj.height >= m_pedestrian_stop_img_height_threshold) temp_x_distance = 10;
+        if(abs(temp_x_distance) < abs(distance_to_pedestrian)) distance_to_pedestrian = temp_x_distance;
+      }
+    }
+    
+  }
+
+  // Publish Sprint Switch
+  std_msgs::Bool sprint_switch_msg;
+
+  if(vehicle_cnt != 0){
+    m_noVehicleCnt = 0;
+    sprint_switch_msg.data = false;
+  }
+  else{ // No vehicle is exist in front of the car
+    if(m_noVehicleCnt < m_SprintDecisionTime*10) {
+      m_noVehicleCnt +=1;
+      sprint_switch_msg.data = false;
+    }
+    else if (m_noVehicleCnt >= 5) sprint_switch_msg.data = true;
+  }  
+  pub_SprintSwitch.publish(sprint_switch_msg);
+
+  // ROS_INFO("object # : %d", m_PredictedObjects.size());
+  
+  std_msgs::Float64 distanceToPedestrianMsg; 
+  distanceToPedestrianMsg.data = distance_to_pedestrian;
+  pub_DistanceToPedestrian.publish(distanceToPedestrianMsg);
+}
+
+void TrajectoryEval::callbackGetBehaviorState(const geometry_msgs::TwistStampedConstPtr& msg)
+{
+  m_CurrentBehavior.iTrajectory = msg->twist.angular.z;
+}
+
+void TrajectoryEval::callbackGetCurrentState(const std_msgs::Int32 & msg)
+{
+  m_CurrentBehavior.state = static_cast<PlannerHNS::STATE_TYPE>(msg.data);
+}
+
+void TrajectoryEval::UpdateMyParams()
+{
+  ros::NodeHandle _nh;
+  _nh.getParam("/op_trajectory_evaluator/weightPriority", m_PlanningParams.weightPriority);
+  _nh.getParam("/op_trajectory_evaluator/weightTransition", m_PlanningParams.weightTransition);
+  _nh.getParam("/op_trajectory_evaluator/weightLong", m_PlanningParams.weightLong);
+  _nh.getParam("/op_trajectory_evaluator/weightLat", m_PlanningParams.weightLat);
+  _nh.getParam("/op_trajectory_evaluator/LateralSkipDistance", m_PlanningParams.LateralSkipDistance);
+}
+
+bool TrajectoryEval::UpdateTf()
+{
+  try{
+    m_vtob_listener.waitForTransform("/velodyne", "/base_link", ros::Time(0), ros::Duration(0.001));
+    m_vtob_listener.lookupTransform("/velodyne", "/base_link", ros::Time(0), m_velodyne_to_base_link);
+
+    m_vtom_listener.waitForTransform("/velodyne", "/map", ros::Time(0), ros::Duration(0.001));
+    m_vtom_listener.lookupTransform("/velodyne", "/map", ros::Time(0), m_velodyne_to_map);
+    return true;
+  }
+  catch(tf::TransformException& ex){
+    if(TF_DEBUG)
+      ROS_ERROR("%s", ex.what());
+    return false;
+  }
+}
+
+void TrajectoryEval::MainLoop()
+{
+  ros::NodeHandle private_nh("~");
+
+  // Scheduling Setup
+  std::string task_response_time_filename;
+  int rate;
+  double task_minimum_inter_release_time;
+  double task_execution_time;
+  double task_relative_deadline; 
+
+  private_nh.param<std::string>("/op_trajectory_evaluator/task_response_time_filename", task_response_time_filename, "~/Documents/profiling/response_time/op_trajectory_evaluator.csv");
+  private_nh.param<int>("/op_trajectory_evaluator/rate", rate, 10);
+  private_nh.param("/op_trajectory_evaluator/task_minimum_inter_release_time", task_minimum_inter_release_time, (double)10);
+  private_nh.param("/op_trajectory_evaluator/task_execution_time", task_execution_time, (double)10);
+  private_nh.param("/op_trajectory_evaluator/task_relative_deadline", task_relative_deadline, (double)10);  
+
+  rubis::init_task_profiling(task_response_time_filename);
+
+  PlannerHNS::WayPoint prevState, state_change;
+
+  // Add Crossing Info from yaml file
+  XmlRpc::XmlRpcValue intersection_xml;  
+  nh.getParam("/op_trajectory_evaluator/intersection_list", intersection_xml);
+  PlannerHNS::MappingHelpers::ConstructIntersection_RUBIS(intersection_list_, intersection_xml);
+
+  ros::Rate r(100);
+
+  while(ros::ok()){
+    // Before spin
+    UpdateMyParams();
+    UpdateTf();
+
+    ros::spinOnce();
+
+    PlannerHNS::TrajectoryCost tc;
+
+    if(bNewCurrentPos && m_GlobalPaths.size()>0)
+    {
+      m_GlobalPathSections.clear();
+
+      for(unsigned int i = 0; i < m_GlobalPathsToUse.size(); i++)
+      {
+        t_centerTrajectorySmoothed.clear();
+        PlannerHNS::PlanningHelpers::ExtractPartFromPointToDistanceDirectionFast(m_GlobalPathsToUse.at(i), m_CurrentPos, m_PlanningParams.horizonDistance , m_PlanningParams.pathDensity ,t_centerTrajectorySmoothed);
+        m_GlobalPathSections.push_back(t_centerTrajectorySmoothed);
+      }
+
+      if(m_GlobalPathSections.size()>0)
+      {
+        if(m_bUseMoveingObjectsPrediction)
+          tc = m_TrajectoryCostsCalculator.DoOneStepDynamic(m_GeneratedRollOuts, m_GlobalPathSections.at(0), m_CurrentPos,m_PlanningParams,  m_CarInfo,m_VehicleStatus, m_PredictedObjects, m_CurrentBehavior.iTrajectory);
+        else
+          tc = m_TrajectoryCostsCalculator.DoOneStepStatic(m_GeneratedRollOuts, m_GlobalPathSections.at(0), m_CurrentPos,  m_PlanningParams,  m_CarInfo,m_VehicleStatus, m_PredictedObjects, m_CurrentBehavior.state);
+
+        autoware_msgs::Lane l;
+        l.closest_object_distance = tc.closest_obj_distance;
+        l.closest_object_velocity = tc.closest_obj_velocity;
+        l.cost = tc.cost;
+        l.is_blocked = tc.bBlocked;
+        l.lane_index = tc.index;
+        pub_TrajectoryCost.publish(l);
+
+        // hjw added : Check if ego is on intersection and obstacles are in risky area 
+        int intersectionID = -1;
+        double closestIntersectionDistance = -1;
+        bool isInsideIntersection = false;
+        bool riskyLeftTurn = false;
+        bool riskyRightTurn = false;
+
+        PlannerHNS::PlanningHelpers::GetIntersectionCondition(m_CurrentPos, intersection_list_, m_PredictedObjects, intersectionID, closestIntersectionDistance, isInsideIntersection, riskyLeftTurn, riskyRightTurn);
+
+        autoware_msgs::IntersectionCondition ic_msg;
+        ic_msg.intersectionID = intersectionID;
+        ic_msg.intersectionDistance = closestIntersectionDistance;
+        ic_msg.isIntersection = isInsideIntersection;
+        ic_msg.riskyLeftTurn = riskyLeftTurn;
+        ic_msg.riskyRightTurn = riskyRightTurn;
+
+        pub_IntersectionCondition.publish(ic_msg);
+
+      }
+
+      if(m_TrajectoryCostsCalculator.m_TrajectoryCosts.size() == m_GeneratedRollOuts.size())
+      {
+        rubis_msgs::LaneArrayWithPoseTwist local_lanes;
+        for(unsigned int i=0; i < m_GeneratedRollOuts.size(); i++)
+        {
+          autoware_msgs::Lane lane;
+          PlannerHNS::ROSHelpers::ConvertFromLocalLaneToAutowareLane(m_GeneratedRollOuts.at(i), lane);
+          lane.closest_object_distance = m_TrajectoryCostsCalculator.m_TrajectoryCosts.at(i).closest_obj_distance;
+          lane.closest_object_velocity = m_TrajectoryCostsCalculator.m_TrajectoryCosts.at(i).closest_obj_velocity;
+          lane.cost = m_TrajectoryCostsCalculator.m_TrajectoryCosts.at(i).cost;
+          lane.is_blocked = m_TrajectoryCostsCalculator.m_TrajectoryCosts.at(i).bBlocked;
+          lane.lane_index = i;
+          local_lanes.lane_array.lanes.push_back(lane);
+        }
+        
+        local_lanes.instance = rubis::instance_;
+        local_lanes.pose = msg->pose;
+        local_lanes.twist = msg->twist;
+
+        pub_LocalWeightedTrajectoriesWithPoseTwist.publish(local_lanes);
+        pub_LocalWeightedTrajectories.publish(local_lanes.lane_array);
+        
+      }
+      else
+      {
+        ROS_ERROR("m_TrajectoryCosts.size() Not Equal m_GeneratedRollOuts.size()");
+      }
+
+      if(m_TrajectoryCostsCalculator.m_TrajectoryCosts.size()>0)
+      {
+        visualization_msgs::MarkerArray all_rollOuts;
+        PlannerHNS::ROSHelpers::TrajectoriesToColoredMarkers(m_GeneratedRollOuts, m_TrajectoryCostsCalculator.m_TrajectoryCosts, m_CurrentBehavior.iTrajectory, all_rollOuts);
+        pub_LocalWeightedTrajectoriesRviz.publish(all_rollOuts);
+
+        PlannerHNS::ROSHelpers::ConvertCollisionPointsMarkers(m_TrajectoryCostsCalculator.m_CollisionPoints, m_CollisionsActual, m_CollisionsDummy);
+        pub_CollisionPointsRviz.publish(m_CollisionsActual);
+
+        //Visualize Safety Box
+        visualization_msgs::Marker safety_box;
+        PlannerHNS::ROSHelpers::ConvertFromPlannerHRectangleToAutowareRviz(m_TrajectoryCostsCalculator.m_SafetyBorder.points, safety_box);
+        pub_SafetyBorderRviz.publish(safety_box);
+      }
+    } 
+    else
+      sub_GlobalPlannerPaths = nh.subscribe("/lane_waypoints_array",   1,    &TrajectoryEval::callbackGetGlobalPlannerPath,   this);
+
+    rubis::stop_task_profiling(0, 0);  
+
+    r.sleep();
+  }
+}
+
+}
diff --git a/autoware.ai/src/autoware/core_planning/op_local_planner/nodes/op_trajectory_generator/op_trajectory_generator_core.cpp b/autoware.ai/src/autoware/core_planning/op_local_planner/nodes/op_trajectory_generator/op_trajectory_generator_core.cpp
index 10549a37..be9bebe5 100644
--- a/autoware.ai/src/autoware/core_planning/op_local_planner/nodes/op_trajectory_generator/op_trajectory_generator_core.cpp
+++ b/autoware.ai/src/autoware/core_planning/op_local_planner/nodes/op_trajectory_generator/op_trajectory_generator_core.cpp
@@ -39,37 +39,24 @@ TrajectoryGen::TrajectoryGen()
   m_OriginPos.position.y  = transform.getOrigin().y();
   m_OriginPos.position.z  = transform.getOrigin().z();
 
-  pub_LocalTrajectories = nh.advertise<autoware_msgs::LaneArray>("local_trajectories", 1);
+  // pub_LocalTrajectories = nh.advertise<autoware_msgs::LaneArray>("local_trajectories", 1);
+  pub_LocalTrajectoriesWithPoseTwist = nh.advertise<rubis_msgs::LaneArrayWithPoseTwist>("local_trajectories_with_pose_twist", 1);
   pub_LocalTrajectoriesRviz = nh.advertise<visualization_msgs::MarkerArray>("local_trajectories_gen_rviz", 1);
 
   sub_initialpose = nh.subscribe("/initialpose", 1, &TrajectoryGen::callbackGetInitPose, this);
-  sub_current_pose = nh.subscribe("/current_pose", 10, &TrajectoryGen::callbackGetCurrentPose, this);
 
   int bVelSource = 1;
   _nh.getParam("/op_trajectory_generator/velocitySource", bVelSource);
-  if(bVelSource == 0)
-    sub_robot_odom = nh.subscribe("/odom", 10,  &TrajectoryGen::callbackGetRobotOdom, this);
-  else if(bVelSource == 1)
-    sub_current_velocity = nh.subscribe("/current_velocity", 10, &TrajectoryGen::callbackGetVehicleStatus, this);
-  else if(bVelSource == 2)
-    sub_can_info = nh.subscribe("/can_info", 10, &TrajectoryGen::callbackGetCANInfo, this);
-
-  sub_GlobalPlannerPaths = nh.subscribe("/lane_waypoints_array", 1, &TrajectoryGen::callbackGetGlobalPlannerPath, this);
-  
-  /*  RT Scheduling setup  */
-  // sub_initialpose = nh.subscribe("/initialpose", 1, &TrajectoryGen::callbackGetInitPose, this);
-  // sub_current_pose = nh.subscribe("/current_pose", 1, &TrajectoryGen::callbackGetCurrentPose, this); //origin 10
-
-  // int bVelSource = 1;
-  // _nh.getParam("/op_trajectory_generator/velocitySource", bVelSource);
   // if(bVelSource == 0)
-  //   sub_robot_odom = nh.subscribe("/odom", 1,  &TrajectoryGen::callbackGetRobotOdom, this); //origin 10
+  //   sub_robot_odom = nh.subscribe("/odom", 10,  &TrajectoryGen::callbackGetRobotOdom, this);
   // else if(bVelSource == 1)
-  //   sub_current_velocity = nh.subscribe("/current_velocity", 1, &TrajectoryGen::callbackGetVehicleStatus, this); //origin 10
+  //   sub_current_velocity = nh.subscribe("/current_velocity", 10, &TrajectoryGen::callbackGetVehicleStatus, this);
   // else if(bVelSource == 2)
-  //   sub_can_info = nh.subscribe("/can_info", 1, &TrajectoryGen::callbackGetCANInfo, this); //origin 10
+  //   sub_can_info = nh.subscribe("/can_info", 10, &TrajectoryGen::callbackGetCANInfo, this);
 
-  // sub_GlobalPlannerPaths = nh.subscribe("/lane_waypoints_array", 1, &TrajectoryGen::callbackGetGlobalPlannerPath, this);
+  sub_GlobalPlannerPaths = nh.subscribe("/lane_waypoints_array", 1, &TrajectoryGen::callbackGetGlobalPlannerPath, this);
+  
+  sub_pose_twist = nh.subscribe("/rubis_current_pose_twist", 1, &TrajectoryGen::callbackGetCurrentPoseTwist, this); // Def: 10
 }
 
 TrajectoryGen::~TrajectoryGen()
@@ -143,26 +130,45 @@ void TrajectoryGen::callbackGetInitPose(const geometry_msgs::PoseWithCovarianceS
   }
 }
 
-void TrajectoryGen::callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr& msg)
-{
-  m_CurrentPos = PlannerHNS::WayPoint(msg->pose.position.x, msg->pose.position.y, msg->pose.position.z, tf::getYaw(msg->pose.orientation));
+// void TrajectoryGen::callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr& msg)
+// {
+//   m_CurrentPos = PlannerHNS::WayPoint(msg->pose.position.x, msg->pose.position.y, msg->pose.position.z, tf::getYaw(msg->pose.orientation));
+//   m_InitPos = m_CurrentPos;
+//   bNewCurrentPos = true;
+//   bInitPos = true;
+// }
+
+// void TrajectoryGen::callbackGetVehicleStatus(const geometry_msgs::TwistStampedConstPtr& msg)
+// {
+//   m_VehicleStatus.speed = msg->twist.linear.x;
+//   m_CurrentPos.v = m_VehicleStatus.speed;
+//   if(fabs(msg->twist.linear.x) > 0.25)
+//     m_VehicleStatus.steer = atan(m_CarInfo.wheel_base * msg->twist.angular.z/msg->twist.linear.x);
+//   UtilityHNS::UtilityH::GetTickCount(m_VehicleStatus.tStamp);
+//   bVehicleStatus = true;
+// }
+
+void TrajectoryGen::callbackGetCurrentPoseTwist(const rubis_msgs::PoseTwistStampedPtr& msg){
+  // Callback
+  rubis::instance_ = msg->instance;
+  
+  m_CurrentPos = PlannerHNS::WayPoint(msg->pose.pose.position.x, msg->pose.pose.position.y, msg->pose.pose.position.z, tf::getYaw(msg->pose.pose.orientation));
   m_InitPos = m_CurrentPos;
   bNewCurrentPos = true;
   bInitPos = true;
-}
 
-void TrajectoryGen::callbackGetVehicleStatus(const geometry_msgs::TwistStampedConstPtr& msg)
-{
-  m_VehicleStatus.speed = msg->twist.linear.x;
+  m_VehicleStatus.speed = msg->twist.twist.linear.x;
   m_CurrentPos.v = m_VehicleStatus.speed;
-  if(fabs(msg->twist.linear.x) > 0.25)
-    m_VehicleStatus.steer = atan(m_CarInfo.wheel_base * msg->twist.angular.z/msg->twist.linear.x);
+  if(fabs(msg->twist.twist.linear.x) > 0.25)
+    m_VehicleStatus.steer = atan(m_CarInfo.wheel_base * msg->twist.twist.angular.z/msg->twist.twist.linear.x);
   UtilityHNS::UtilityH::GetTickCount(m_VehicleStatus.tStamp);
   bVehicleStatus = true;
 
-  if(rubis::sched::is_task_ready_ == TASK_NOT_READY) rubis::sched::init_task();  
+  current_pose_ = msg->pose;
+  current_twist_ = msg->twist;
 }
 
+
 void TrajectoryGen::callbackGetCANInfo(const autoware_can_msgs::CANInfoConstPtr &msg)
 {
   m_VehicleStatus.speed = msg->speed/3.6;
@@ -216,41 +222,34 @@ void TrajectoryGen::MainLoop()
 {
   ros::NodeHandle private_nh("~");
 
-  // Scheduling Setup
-  int task_scheduling_flag;
-  int task_profiling_flag;
+  // Scheduling & Profiling Setup
+  std::string node_name = ros::this_node::getName();
   std::string task_response_time_filename;
-  int rate;
-  double task_minimum_inter_release_time;
-  double task_execution_time;
-  double task_relative_deadline; 
+  private_nh.param<std::string>(node_name+"/task_response_time_filename", task_response_time_filename, "~/Documents/profiling/response_time/op_trajectory_generator.csv");
 
-  private_nh.param<int>("/op_trajectory_generator/task_scheduling_flag", task_scheduling_flag, 0);
-  private_nh.param<int>("/op_trajectory_generator/task_profiling_flag", task_profiling_flag, 0);
-  private_nh.param<std::string>("/op_trajectory_generator/task_response_time_filename", task_response_time_filename, "~/Documents/profiling/response_time/op_trajectory_generator.csv");
-  private_nh.param<int>("/op_trajectory_generator/rate", rate, 10);
-  private_nh.param("/op_trajectory_generator/task_minimum_inter_release_time", task_minimum_inter_release_time, (double)10);
-  private_nh.param("/op_trajectory_generator/task_execution_time", task_execution_time, (double)10);
-  private_nh.param("/op_trajectory_generator/task_relative_deadline", task_relative_deadline, (double)10);
-
-  if(task_profiling_flag) rubis::sched::init_task_profiling(task_response_time_filename);
+  int rate;
+  private_nh.param<int>(node_name+"/rate", rate, 10);
+
+  struct rubis::sched_attr attr;
+  std::string policy;
+  int priority, exec_time ,deadline, period;
+    
+  private_nh.param(node_name+"/task_scheduling_configs/policy", policy, std::string("NONE"));    
+  private_nh.param(node_name+"/task_scheduling_configs/priority", priority, 99);
+  private_nh.param(node_name+"/task_scheduling_configs/exec_time", exec_time, 0);
+  private_nh.param(node_name+"/task_scheduling_configs/deadline", deadline, 0);
+  private_nh.param(node_name+"/task_scheduling_configs/period", period, 0);
+  attr = rubis::create_sched_attr(priority, exec_time, deadline, period);    
+  rubis::init_task_scheduling(policy, attr);
+
+  rubis::init_task_profiling(task_response_time_filename);
 
   PlannerHNS::WayPoint prevState, state_change;
 
+  ros::Rate r(rate);
 
-  ros::Rate loop_rate(rate);
-  if(!task_scheduling_flag && !task_profiling_flag) loop_rate = ros::Rate(100);
-
-  struct timespec start_time, end_time;
-
-  while (ros::ok())
-  {
-    if(task_profiling_flag) rubis::sched::start_task_profiling();
-
-    if(rubis::sched::is_task_ready_ == TASK_READY && rubis::sched::task_state_ == TASK_STATE_READY){
-      if(task_scheduling_flag) rubis::sched::request_task_scheduling(task_minimum_inter_release_time, task_execution_time, task_relative_deadline); 
-      rubis::sched::task_state_ = TASK_STATE_RUNNING;     
-    }
+  while(ros::ok()){
+    rubis::start_task_profiling();
 
     ros::spinOnce();
 
@@ -288,7 +287,7 @@ void TrajectoryGen::MainLoop()
                 -1 , -1,
                 m_RollOuts, sampledPoints_debug);
 
-      autoware_msgs::LaneArray local_lanes;
+      rubis_msgs::LaneArrayWithPoseTwist local_lanes;
       for(unsigned int i=0; i < m_RollOuts.size(); i++)
       {
         for(unsigned int j=0; j < m_RollOuts.at(i).size(); j++)
@@ -301,28 +300,30 @@ void TrajectoryGen::MainLoop()
           lane.cost = 0;
           lane.is_blocked = false;
           lane.lane_index = i;
-          local_lanes.lanes.push_back(lane);
+          local_lanes.lane_array.lanes.push_back(lane);
         }
       }
-      pub_LocalTrajectories.publish(local_lanes);
-      rubis::sched::task_state_ = TASK_STATE_DONE;
+
+      local_lanes.instance = rubis::instance_;
+      local_lanes.pose = current_pose_;
+      local_lanes.twist = current_twist_;
+
+      pub_LocalTrajectoriesWithPoseTwist.publish(local_lanes);
+      // pub_LocalTrajectories.publish(local_lanes.lane_array);
+      
     }
-    else
+    else{
       sub_GlobalPlannerPaths = nh.subscribe("/lane_waypoints_array",   1,    &TrajectoryGen::callbackGetGlobalPlannerPath,   this);
 
-    visualization_msgs::MarkerArray all_rollOuts;
-    PlannerHNS::ROSHelpers::TrajectoriesToMarkers(m_RollOuts, all_rollOuts);
-    pub_LocalTrajectoriesRviz.publish(all_rollOuts);
+      visualization_msgs::MarkerArray all_rollOuts;
+      PlannerHNS::ROSHelpers::TrajectoriesToMarkers(m_RollOuts, all_rollOuts);
+      pub_LocalTrajectoriesRviz.publish(all_rollOuts);
 
-    if(task_profiling_flag) rubis::sched::stop_task_profiling(0, rubis::sched::task_state_);
-
-    if(rubis::sched::is_task_ready_ == TASK_READY && rubis::sched::task_state_ == TASK_STATE_DONE){
-      if(task_scheduling_flag) rubis::sched::yield_task_scheduling();
-      rubis::sched::task_state_ = TASK_STATE_READY;
+      rubis::stop_task_profiling(0, 0);
     }
 
-    loop_rate.sleep();
-  } 
+    r.sleep();
+  }
 }
 
-}
+}
\ No newline at end of file
diff --git a/autoware.ai/src/autoware/core_planning/op_local_planner/nodes/op_trajectory_generator/op_trajectory_generator_core.modified.cpp b/autoware.ai/src/autoware/core_planning/op_local_planner/nodes/op_trajectory_generator/op_trajectory_generator_core.modified.cpp
new file mode 100644
index 00000000..2c40bb81
--- /dev/null
+++ b/autoware.ai/src/autoware/core_planning/op_local_planner/nodes/op_trajectory_generator/op_trajectory_generator_core.modified.cpp
@@ -0,0 +1,315 @@
+/*
+ * Copyright 2018-2019 Autoware Foundation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "op_trajectory_generator_core.h"
+#include "op_ros_helpers/op_ROSHelpers.h"
+#include <rubis_lib/sched.hpp>
+
+#define SPIN_PROFILING
+
+namespace TrajectoryGeneratorNS
+{
+
+TrajectoryGen::TrajectoryGen()
+{
+  bInitPos = false;
+  bNewCurrentPos = false;
+  bVehicleStatus = false;
+  bWayGlobalPath = false;
+
+  ros::NodeHandle _nh;
+  UpdatePlanningParams(_nh);
+
+  tf::StampedTransform transform;
+  PlannerHNS::ROSHelpers::GetTransformFromTF("map", "world", transform);
+  m_OriginPos.position.x  = transform.getOrigin().x();
+  m_OriginPos.position.y  = transform.getOrigin().y();
+  m_OriginPos.position.z  = transform.getOrigin().z();
+
+  pub_LocalTrajectories = nh.advertise<autoware_msgs::LaneArray>("local_trajectories", 1);
+  pub_LocalTrajectoriesWithPoseTwist = nh.advertise<rubis_msgs::LaneArrayWithPoseTwist>("local_trajectories_with_pose_twist", 1);
+  pub_LocalTrajectoriesRviz = nh.advertise<visualization_msgs::MarkerArray>("local_trajectories_gen_rviz", 1);
+
+  sub_initialpose = nh.subscribe("/initialpose", 1, &TrajectoryGen::callbackGetInitPose, this);
+  // sub_current_pose = nh.subscribe("/current_pose", 10, &TrajectoryGen::callbackGetCurrentPose, this);
+
+  int bVelSource = 1;
+  _nh.getParam("/op_trajectory_generator/velocitySource", bVelSource);
+  if(bVelSource == 0)
+    sub_robot_odom = nh.subscribe("/odom", 10,  &TrajectoryGen::callbackGetRobotOdom, this);
+  // else if(bVelSource == 1)
+  //   sub_current_velocity = nh.subscribe("/current_velocity", 10, &TrajectoryGen::callbackGetVehicleStatus, this);
+  else if(bVelSource == 2)
+    sub_can_info = nh.subscribe("/can_info", 10, &TrajectoryGen::callbackGetCANInfo, this);
+
+  sub_GlobalPlannerPaths = nh.subscribe("/lane_waypoints_array", 1, &TrajectoryGen::callbackGetGlobalPlannerPath, this);
+  
+  sub_pose_twist = nh.subscribe("/rubis_current_pose_twist", 10, &TrajectoryGen::callbackGetCurrentPoseTwist, this);
+}
+
+TrajectoryGen::~TrajectoryGen()
+{
+}
+
+void TrajectoryGen::UpdatePlanningParams(ros::NodeHandle& _nh)
+{
+  _nh.getParam("/op_trajectory_generator/samplingTipMargin", m_PlanningParams.carTipMargin);
+  _nh.getParam("/op_trajectory_generator/samplingOutMargin", m_PlanningParams.rollInMargin);
+  _nh.getParam("/op_trajectory_generator/samplingSpeedFactor", m_PlanningParams.rollInSpeedFactor);
+  _nh.getParam("/op_trajectory_generator/enableHeadingSmoothing", m_PlanningParams.enableHeadingSmoothing);
+
+  _nh.getParam("/op_common_params/enableSwerving", m_PlanningParams.enableSwerving);
+  if(m_PlanningParams.enableSwerving)
+    m_PlanningParams.enableFollowing = true;
+  else
+    _nh.getParam("/op_common_params/enableFollowing", m_PlanningParams.enableFollowing);
+
+  _nh.getParam("/op_common_params/enableTrafficLightBehavior", m_PlanningParams.enableTrafficLightBehavior);
+  _nh.getParam("/op_common_params/enableStopSignBehavior", m_PlanningParams.enableStopSignBehavior);
+
+  _nh.getParam("/op_common_params/maxVelocity", m_PlanningParams.maxSpeed);
+  _nh.getParam("/op_common_params/minVelocity", m_PlanningParams.minSpeed);
+  _nh.getParam("/op_common_params/maxLocalPlanDistance", m_PlanningParams.microPlanDistance);
+
+  _nh.getParam("/op_common_params/pathDensity", m_PlanningParams.pathDensity);
+  _nh.getParam("/op_common_params/rollOutDensity", m_PlanningParams.rollOutDensity);
+  if(m_PlanningParams.enableSwerving)
+    _nh.getParam("/op_common_params/rollOutsNumber", m_PlanningParams.rollOutNumber);
+  else
+    m_PlanningParams.rollOutNumber = 0;
+
+  _nh.getParam("/op_common_params/horizonDistance", m_PlanningParams.horizonDistance);
+  _nh.getParam("/op_common_params/minFollowingDistance", m_PlanningParams.minFollowingDistance);
+  _nh.getParam("/op_common_params/minDistanceToAvoid", m_PlanningParams.minDistanceToAvoid);
+  _nh.getParam("/op_common_params/maxDistanceToAvoid", m_PlanningParams.maxDistanceToAvoid);
+  _nh.getParam("/op_common_params/speedProfileFactor", m_PlanningParams.speedProfileFactor);
+
+  _nh.getParam("/op_common_params/smoothingDataWeight", m_PlanningParams.smoothingDataWeight);
+  _nh.getParam("/op_common_params/smoothingSmoothWeight", m_PlanningParams.smoothingSmoothWeight);
+
+  _nh.getParam("/op_common_params/horizontalSafetyDistance", m_PlanningParams.horizontalSafetyDistancel);
+  _nh.getParam("/op_common_params/verticalSafetyDistance", m_PlanningParams.verticalSafetyDistance);
+
+  _nh.getParam("/op_common_params/enableLaneChange", m_PlanningParams.enableLaneChange);
+
+  _nh.getParam("/op_common_params/width", m_CarInfo.width);
+  _nh.getParam("/op_common_params/length", m_CarInfo.length);
+  _nh.getParam("/op_common_params/wheelBaseLength", m_CarInfo.wheel_base);
+  _nh.getParam("/op_common_params/turningRadius", m_CarInfo.turning_radius);
+  _nh.getParam("/op_common_params/maxSteerAngle", m_CarInfo.max_steer_angle);
+  _nh.getParam("/op_common_params/maxAcceleration", m_CarInfo.max_acceleration);
+  _nh.getParam("/op_common_params/maxDeceleration", m_CarInfo.max_deceleration);
+
+  m_CarInfo.max_speed_forward = m_PlanningParams.maxSpeed;
+  m_CarInfo.min_speed_forward = m_PlanningParams.minSpeed;
+
+}
+
+void TrajectoryGen::callbackGetInitPose(const geometry_msgs::PoseWithCovarianceStampedConstPtr &msg)
+{
+  if(!bInitPos)
+  {
+    m_InitPos = PlannerHNS::WayPoint(msg->pose.pose.position.x+m_OriginPos.position.x,
+        msg->pose.pose.position.y+m_OriginPos.position.y,
+        msg->pose.pose.position.z+m_OriginPos.position.z,
+        tf::getYaw(msg->pose.pose.orientation));
+    m_CurrentPos = m_InitPos;
+    bInitPos = true;
+  }
+}
+
+// void TrajectoryGen::callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr& msg)
+// {
+//   m_CurrentPos = PlannerHNS::WayPoint(msg->pose.position.x, msg->pose.position.y, msg->pose.position.z, tf::getYaw(msg->pose.orientation));
+//   m_InitPos = m_CurrentPos;
+//   bNewCurrentPos = true;
+//   bInitPos = true;
+// }
+
+// void TrajectoryGen::callbackGetVehicleStatus(const geometry_msgs::TwistStampedConstPtr& msg)
+// {
+//   m_VehicleStatus.speed = msg->twist.linear.x;
+//   m_CurrentPos.v = m_VehicleStatus.speed;
+//   if(fabs(msg->twist.linear.x) > 0.25)
+//     m_VehicleStatus.steer = atan(m_CarInfo.wheel_base * msg->twist.angular.z/msg->twist.linear.x);
+//   UtilityHNS::UtilityH::GetTickCount(m_VehicleStatus.tStamp);
+//   bVehicleStatus = true;
+// }
+
+void TrajectoryGen::callbackGetCurrentPoseTwist(const rubis_msgs::PoseTwistStampedPtr& msg){
+  // Before spinOnce
+  rubis::start_task_profiling();
+
+  // Callback
+  m_CurrentPos = PlannerHNS::WayPoint(msg->pose.pose.position.x, msg->pose.pose.position.y, msg->pose.pose.position.z, tf::getYaw(msg->pose.pose.orientation));
+  m_InitPos = m_CurrentPos;
+  bNewCurrentPos = true;
+  bInitPos = true;
+
+  m_VehicleStatus.speed = msg->twist.twist.linear.x;
+  m_CurrentPos.v = m_VehicleStatus.speed;
+  if(fabs(msg->twist.twist.linear.x) > 0.25)
+    m_VehicleStatus.steer = atan(m_CarInfo.wheel_base * msg->twist.twist.angular.z/msg->twist.twist.linear.x);
+  UtilityHNS::UtilityH::GetTickCount(m_VehicleStatus.tStamp);
+  bVehicleStatus = true;
+  
+  // After spinOnce
+  if(bInitPos && m_GlobalPaths.size()>0)
+  {
+    m_GlobalPathSections.clear();
+
+    for(unsigned int i = 0; i < m_GlobalPaths.size(); i++)
+    {
+      t_centerTrajectorySmoothed.clear();
+      PlannerHNS::PlanningHelpers::ExtractPartFromPointToDistanceDirectionFast(m_GlobalPaths.at(i), m_CurrentPos, m_PlanningParams.horizonDistance ,
+          m_PlanningParams.pathDensity ,t_centerTrajectorySmoothed);
+
+      m_GlobalPathSections.push_back(t_centerTrajectorySmoothed);
+    }
+
+    std::vector<PlannerHNS::WayPoint> sampledPoints_debug;
+    m_Planner.GenerateRunoffTrajectory(m_GlobalPathSections, m_CurrentPos,
+              m_PlanningParams.enableLaneChange,
+              m_VehicleStatus.speed,
+              m_PlanningParams.microPlanDistance,
+              m_PlanningParams.maxSpeed,
+              m_PlanningParams.minSpeed,
+              m_PlanningParams.carTipMargin,
+              m_PlanningParams.rollInMargin,
+              m_PlanningParams.rollInSpeedFactor,
+              m_PlanningParams.pathDensity,
+              m_PlanningParams.rollOutDensity,
+              m_PlanningParams.rollOutNumber,
+              m_PlanningParams.smoothingDataWeight,
+              m_PlanningParams.smoothingSmoothWeight,
+              m_PlanningParams.smoothingToleranceError,
+              m_PlanningParams.speedProfileFactor,
+              m_PlanningParams.enableHeadingSmoothing,
+              -1 , -1,
+              m_RollOuts, sampledPoints_debug);
+
+    rubis_msgs::LaneArrayWithPoseTwist local_lanes;
+    for(unsigned int i=0; i < m_RollOuts.size(); i++)
+    {
+      for(unsigned int j=0; j < m_RollOuts.at(i).size(); j++)
+      {
+        autoware_msgs::Lane lane;
+        PlannerHNS::PlanningHelpers::PredictConstantTimeCostForTrajectory(m_RollOuts.at(i).at(j), m_CurrentPos, m_PlanningParams.minSpeed, m_PlanningParams.microPlanDistance);
+        PlannerHNS::ROSHelpers::ConvertFromLocalLaneToAutowareLane(m_RollOuts.at(i).at(j), lane);
+        lane.closest_object_distance = 0;
+        lane.closest_object_velocity = 0;
+        lane.cost = 0;
+        lane.is_blocked = false;
+        lane.lane_index = i;
+        local_lanes.lane_array.lanes.push_back(lane);
+      }
+    }
+
+    rubis::instance_ = msg->instance;
+    local_lanes.instance = rubis::instance_;
+    local_lanes.pose = msg->pose;
+    local_lanes.twist = msg->twist;
+
+    pub_LocalTrajectoriesWithPoseTwist.publish(local_lanes);
+    pub_LocalTrajectories.publish(local_lanes.lane_array);
+    
+  }
+  else{
+    sub_GlobalPlannerPaths = nh.subscribe("/lane_waypoints_array",   1,    &TrajectoryGen::callbackGetGlobalPlannerPath,   this);
+
+    visualization_msgs::MarkerArray all_rollOuts;
+    PlannerHNS::ROSHelpers::TrajectoriesToMarkers(m_RollOuts, all_rollOuts);
+    pub_LocalTrajectoriesRviz.publish(all_rollOuts);
+
+    rubis::stop_task_profiling(0, 0);
+  }
+}
+
+
+void TrajectoryGen::callbackGetCANInfo(const autoware_can_msgs::CANInfoConstPtr &msg)
+{
+  m_VehicleStatus.speed = msg->speed/3.6;
+  m_VehicleStatus.steer = msg->angle * m_CarInfo.max_steer_angle / m_CarInfo.max_steer_value;
+  UtilityHNS::UtilityH::GetTickCount(m_VehicleStatus.tStamp);
+  bVehicleStatus = true;
+}
+
+void TrajectoryGen::callbackGetRobotOdom(const nav_msgs::OdometryConstPtr& msg)
+{
+  m_VehicleStatus.speed = msg->twist.twist.linear.x;
+  m_VehicleStatus.steer += atan(m_CarInfo.wheel_base * msg->twist.twist.angular.z/msg->twist.twist.linear.x);
+  UtilityHNS::UtilityH::GetTickCount(m_VehicleStatus.tStamp);
+  bVehicleStatus = true;
+}
+
+void TrajectoryGen::callbackGetGlobalPlannerPath(const autoware_msgs::LaneArrayConstPtr& msg)
+{
+  if(msg->lanes.size() > 0)
+  {
+    bool bOldGlobalPath = m_GlobalPaths.size() == msg->lanes.size();
+
+    m_GlobalPaths.clear();
+
+    for(unsigned int i = 0 ; i < msg->lanes.size(); i++)
+    {
+      PlannerHNS::ROSHelpers::ConvertFromAutowareLaneToLocalLane(msg->lanes.at(i), m_temp_path);
+
+      PlannerHNS::PlanningHelpers::CalcAngleAndCost(m_temp_path);
+      m_GlobalPaths.push_back(m_temp_path);
+
+      if(bOldGlobalPath)
+      {
+        bOldGlobalPath = PlannerHNS::PlanningHelpers::CompareTrajectories(m_temp_path, m_GlobalPaths.at(i));
+      }
+    }
+
+    if(!bOldGlobalPath)
+    {
+      bWayGlobalPath = true;
+      std::cout << "Received New Global Path Generator ! " << std::endl;
+    }
+    else
+    {
+      m_GlobalPaths.clear();
+    }
+  }
+}
+
+void TrajectoryGen::MainLoop()
+{
+  ros::NodeHandle private_nh("~");
+
+  // Scheduling Setup
+  std::string task_response_time_filename;
+  int rate;
+  double task_minimum_inter_release_time;
+  double task_execution_time;
+  double task_relative_deadline; 
+
+  private_nh.param<std::string>("/op_trajectory_generator/task_response_time_filename", task_response_time_filename, "~/Documents/profiling/response_time/op_trajectory_generator.csv");
+  private_nh.param<int>("/op_trajectory_generator/rate", rate, 10);
+  private_nh.param("/op_trajectory_generator/task_minimum_inter_release_time", task_minimum_inter_release_time, (double)10);
+  private_nh.param("/op_trajectory_generator/task_execution_time", task_execution_time, (double)10);
+  private_nh.param("/op_trajectory_generator/task_relative_deadline", task_relative_deadline, (double)10);
+
+  rubis::init_task_profiling(task_response_time_filename);
+
+  PlannerHNS::WayPoint prevState, state_change;
+
+  ros::spin();
+}
+
+}
\ No newline at end of file
diff --git a/autoware.ai/src/autoware/core_planning/pure_pursuit/CMakeLists.txt b/autoware.ai/src/autoware/core_planning/pure_pursuit/CMakeLists.txt
index 97cc58e4..deef12e6 100644
--- a/autoware.ai/src/autoware/core_planning/pure_pursuit/CMakeLists.txt
+++ b/autoware.ai/src/autoware/core_planning/pure_pursuit/CMakeLists.txt
@@ -60,20 +60,4 @@ install(
 install(
   DIRECTORY launch/
   DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION}/launch
-)
-
-if(CATKIN_ENABLE_TESTING)
-  find_package(rostest REQUIRED)
-
-  add_rostest_gtest(
-    test-pure_pursuit
-    test/test_pure_pursuit.test
-    test/src/test_pure_pursuit.cpp
-    src/pure_pursuit_core.cpp
-    src/pure_pursuit.cpp src/pure_pursuit_viz.cpp
-  )
-  add_dependencies(test-pure_pursuit ${catkin_EXPORTED_TARGETS})
-  target_link_libraries(test-pure_pursuit ${catkin_LIBRARIES})
-
-  roslint_add_test()
-endif()
+)
\ No newline at end of file
diff --git a/autoware.ai/src/autoware/core_planning/pure_pursuit/include/pure_pursuit/pure_pursuit.h b/autoware.ai/src/autoware/core_planning/pure_pursuit/include/pure_pursuit/pure_pursuit.h
index bab5c953..6a56fee1 100644
--- a/autoware.ai/src/autoware/core_planning/pure_pursuit/include/pure_pursuit/pure_pursuit.h
+++ b/autoware.ai/src/autoware/core_planning/pure_pursuit/include/pure_pursuit/pure_pursuit.h
@@ -24,6 +24,7 @@
 #include <geometry_msgs/TwistStamped.h>
 #include <rubis_msgs/PoseStamped.h>
 #include <rubis_msgs/TwistStamped.h>
+#include "autoware_msgs/Lane.h"
 
 // C++ includes
 #include <vector>
diff --git a/autoware.ai/src/autoware/core_planning/pure_pursuit/include/pure_pursuit/pure_pursuit_core.h b/autoware.ai/src/autoware/core_planning/pure_pursuit/include/pure_pursuit/pure_pursuit_core.h
index 4e2511ef..3e6700e2 100755
--- a/autoware.ai/src/autoware/core_planning/pure_pursuit/include/pure_pursuit/pure_pursuit_core.h
+++ b/autoware.ai/src/autoware/core_planning/pure_pursuit/include/pure_pursuit/pure_pursuit_core.h
@@ -27,6 +27,7 @@
 #include <geometry_msgs/Point.h>
 #include <rubis_msgs/PoseStamped.h>
 #include <rubis_msgs/TwistStamped.h>
+#include <rubis_msgs/PoseTwistStamped.h>
 
 #include <ros/ros.h>
 #include <std_msgs/Float32.h>
@@ -44,6 +45,8 @@
 
 #include <XmlRpcException.h>
 
+#include "rubis_msgs/LaneWithPoseTwist.h"
+
 #ifdef IONIC
 #include <can_data_msgs/Car_ctrl_output.h>
 #endif
@@ -97,7 +100,7 @@ private:
     pub11_, pub12_, pub13_, pub14_, pub15_, pub16_, pub17_, pub18_;
 
   // subscriber
-  ros::Subscriber sub1_, pose_sub_, rubis_pose_sub_, sub3_, velocity_sub_, car_ctrl_output_sub;
+  ros::Subscriber sub1_, sub3_, pose_twist_sub_, final_waypoints_with_pose_twist_sub, car_ctrl_output_sub;
 
   // constant
   const int LOOP_RATE_;  // processing frequency
@@ -125,17 +128,14 @@ private:
   // Added by PHY
   bool dynamic_param_flag_;
   std::vector<DynamicParams> dynamic_params;
+  autoware_msgs::Lane lane_;
 
   // callbacks
-  void callbackFromConfig(
-    const autoware_config_msgs::ConfigWaypointFollowerConstPtr& config);
-  void callbackFromCurrentPose(const geometry_msgs::PoseStampedConstPtr& msg);
-  void callbackFromRubisCurrentPose(const rubis_msgs::PoseStampedConstPtr& _msg);
+  void callbackFromConfig(const autoware_config_msgs::ConfigWaypointFollowerConstPtr& config);
   void callbackFromWayPoints(const autoware_msgs::LaneConstPtr& msg);
-
-  #ifdef SVL
-  void callbackFromCurrentVelocity(const geometry_msgs::TwistStampedConstPtr& msg);
-  #endif
+  void CallbackTwistPose(const rubis_msgs::PoseTwistStampedConstPtr& msg);
+  void CallbackFinalWaypointsWithPoseTwist(const rubis_msgs::LaneWithPoseTwistConstPtr& msg);
+  void _CallbackFinalWaypointsWithPoseTwist();
 
   #ifdef IONIC
   void callbackCtrlOutput(const can_data_msgs::Car_ctrl_output::ConstPtr &msg);
@@ -160,7 +160,7 @@ private:
     const std::vector<autoware_msgs::Waypoint>& waypoints) const;
   void connectVirtualLastWaypoints(
     autoware_msgs::Lane* expand_lane, LaneDirection direction);
-  inline void updateCurrentPose(const geometry_msgs::PoseStampedConstPtr& msg);
+  inline void updateCurrentPose(geometry_msgs::PoseStampedConstPtr& msg);
   
   // Added by PHY
   void setLookaheadParamsByVel();
diff --git a/autoware.ai/src/autoware/core_planning/pure_pursuit/launch/pure_pursuit.launch b/autoware.ai/src/autoware/core_planning/pure_pursuit/launch/pure_pursuit.launch
index 359db355..0e4c9427 100644
--- a/autoware.ai/src/autoware/core_planning/pure_pursuit/launch/pure_pursuit.launch
+++ b/autoware.ai/src/autoware/core_planning/pure_pursuit/launch/pure_pursuit.launch
@@ -7,7 +7,6 @@
   <arg name="const_velocity" default="5.0"/>
   <arg name="lookahead_ratio" default="2.0"/>
   <arg name="minimum_lookahead_distance" default="6.0"/>
-  <arg name="instance_mode" default="0"/>
 
 
   <!-- 0 = waypoints, 1 = provided constant velocity -->
@@ -15,7 +14,6 @@
   
   <!-- rosrun waypoint_follower pure_pursuit -->
   <node pkg="pure_pursuit" type="pure_pursuit" name="pure_pursuit" >
-    <param name="instance_mode" value="$(arg instance_mode)" />
     <param name="is_linear_interpolation" value="$(arg is_linear_interpolation)"/>
     <param name="publishes_for_steering_robot" value="$(arg publishes_for_steering_robot)"/>
     <param name="add_virtual_end_waypoints" value="$(arg add_virtual_end_waypoints)"/>
diff --git a/autoware.ai/src/autoware/core_planning/pure_pursuit/launch/pure_pursuit_params.launch b/autoware.ai/src/autoware/core_planning/pure_pursuit/launch/pure_pursuit_params.launch
index 3ac38797..e04e165e 100644
--- a/autoware.ai/src/autoware/core_planning/pure_pursuit/launch/pure_pursuit_params.launch
+++ b/autoware.ai/src/autoware/core_planning/pure_pursuit/launch/pure_pursuit_params.launch
@@ -7,7 +7,6 @@
   <arg name="const_velocity" default="5.0"/>
   <arg name="lookahead_ratio" default="2.0"/>
   <arg name="minimum_lookahead_distance" default="6.0"/>
-  <!-- <arg name="instance_mode" default="0"/> -->
 
 
   <!-- 0 = waypoints, 1 = provided constant velocity -->
@@ -15,7 +14,6 @@
   
   <!-- rosrun waypoint_follower pure_pursuit -->
   <node pkg="pure_pursuit" type="pure_pursuit" name="pure_pursuit">
-    <!-- <param name="instance_mode" value="$(arg instance_mode)" /> -->
     <param name="is_linear_interpolation" value="$(arg is_linear_interpolation)"/>
     <param name="publishes_for_steering_robot" value="$(arg publishes_for_steering_robot)"/>
     <param name="add_virtual_end_waypoints" value="$(arg add_virtual_end_waypoints)"/>
diff --git a/autoware.ai/src/autoware/core_planning/pure_pursuit/src/pure_pursuit_core.cpp b/autoware.ai/src/autoware/core_planning/pure_pursuit/src/pure_pursuit_core.cpp
old mode 100755
new mode 100644
index 0532fe93..1e105f4a
--- a/autoware.ai/src/autoware/core_planning/pure_pursuit/src/pure_pursuit_core.cpp
+++ b/autoware.ai/src/autoware/core_planning/pure_pursuit/src/pure_pursuit_core.cpp
@@ -142,7 +142,6 @@ void PurePursuitNode::initForROS()
   nh_.param("vehicle_info/wheel_base", wheel_base_, 2.7);
 
   private_nh_.param("/pure_pursuit/dynamic_params_flag", dynamic_param_flag_, false);
-  private_nh_.param("/pure_pursuit/instance_mode", rubis::instance_mode_, 0);
   
   if(dynamic_param_flag_){
     XmlRpc::XmlRpcValue xml_list;
@@ -167,26 +166,15 @@ void PurePursuitNode::initForROS()
 
 
   // setup subscriber
-  sub1_ = nh_.subscribe("final_waypoints", 10,
-    &PurePursuitNode::callbackFromWayPoints, this);
-
-  if(rubis::instance_mode_) rubis_pose_sub_ = nh_.subscribe("rubis_current_pose", 10, &PurePursuitNode::callbackFromRubisCurrentPose, this);
-  else pose_sub_ = nh_.subscribe("current_pose", 10, &PurePursuitNode::callbackFromCurrentPose, this);
+  pose_twist_sub_ = nh_.subscribe("/rubis_current_pose_twist", 1, &PurePursuitNode::CallbackTwistPose, this);
+  final_waypoints_with_pose_twist_sub = nh_.subscribe("/final_waypoints_with_pose_twist", 1, &PurePursuitNode::CallbackFinalWaypointsWithPoseTwist, this); // Def: 10
 
   sub3_ = nh_.subscribe("config/waypoint_follower", 10,
     &PurePursuitNode::callbackFromConfig, this);
   
-  #ifdef SVL
-  velocity_sub_ = nh_.subscribe("current_velocity", 10, &PurePursuitNode::callbackFromCurrentVelocity, this);
-  #endif
-
-  #ifdef IONIC
-  car_ctrl_output_sub = nh_.subscribe("car_ctrl_output", 10, &PurePursuitNode::callbackCtrlOutput, this);
-  #endif
-
   // setup publisher
   twist_pub_ = nh_.advertise<geometry_msgs::TwistStamped>("twist_raw", 10);
-  if(rubis::instance_mode_) rubis_twist_pub_ = nh_.advertise<rubis_msgs::TwistStamped>("rubis_twist_raw", 10);
+  rubis_twist_pub_ = nh_.advertise<rubis_msgs::TwistStamped>("rubis_twist_raw", 10);
 
   pub2_ = nh_.advertise<autoware_msgs::ControlCommandStamped>("ctrl_raw", 10);
   pub11_ = nh_.advertise<visualization_msgs::Marker>("next_waypoint_mark", 0);
@@ -208,99 +196,32 @@ void PurePursuitNode::run()
 {
   ros::NodeHandle private_nh("~");
 
-  // Scheduling Setup
-  int task_scheduling_flag;
-  int task_profiling_flag;
+  // Scheduling & Profiling Setup
+  std::string node_name = ros::this_node::getName();
   std::string task_response_time_filename;
-  int rate;
-  double task_minimum_inter_release_time;
-  double task_execution_time;
-  double task_relative_deadline;
-
-  private_nh.param<int>("/pure_pursuit/task_scheduling_flag", task_scheduling_flag, 0);
-  private_nh.param<int>("/pure_pursuit/task_profiling_flag", task_profiling_flag, 0);
-  private_nh.param<std::string>("/pure_pursuit/task_response_time_filename", task_response_time_filename, "~/Documents/profiling/response_time/pure_pursuit.csv");
-  private_nh.param<int>("/pure_pursuit/rate", rate, 10);
-  private_nh.param("/pure_pursuit/task_minimum_inter_release_time", task_minimum_inter_release_time, (double)10);
-  private_nh.param("/pure_pursuit/task_execution_time", task_execution_time, (double)10);
-  private_nh.param("/pure_pursuit/task_relative_deadline", task_relative_deadline, (double)10);
-
-  ROS_INFO_STREAM("pure pursuit start");
-
-  if(task_profiling_flag) rubis::sched::init_task_profiling(task_response_time_filename);
-
-  ros::Rate loop_rate(LOOP_RATE_);
-  if(!task_scheduling_flag && !task_profiling_flag) loop_rate = ros::Rate(rate);
-
-  while (ros::ok())
-  {
-    if(task_profiling_flag) rubis::sched::start_task_profiling();
-
-    if(rubis::sched::is_task_ready_ == TASK_READY && rubis::sched::task_state_ == TASK_STATE_READY){
-      if(task_scheduling_flag) rubis::sched::request_task_scheduling(task_minimum_inter_release_time, task_execution_time, task_relative_deadline); 
-      rubis::sched::task_state_ = TASK_STATE_RUNNING;     
-    }
-
-    ros::spinOnce();
-    if (!is_pose_set_ || !is_waypoint_set_ || !is_velocity_set_)
-    {
-      // ROS_WARN("Necessary topics are not subscribed yet ... ");
-      
-      if(task_profiling_flag) rubis::sched::stop_task_profiling(rubis::instance_, rubis::sched::task_state_);
-
-      if(rubis::sched::is_task_ready_ == TASK_READY && rubis::sched::task_state_ == TASK_STATE_DONE){
-        if(task_scheduling_flag) rubis::sched::yield_task_scheduling();
-        rubis::sched::task_state_ = TASK_STATE_READY;
-      }
+  private_nh.param<std::string>(node_name+"/task_response_time_filename", task_response_time_filename, "~/Documents/profiling/response_time/pure_pursuit.csv");
 
-      loop_rate.sleep();
-      continue;
-    }
-
-    pp_.setLookaheadDistance(computeLookaheadDistance());
-    pp_.setMinimumLookaheadDistance(minimum_lookahead_distance_);
-
-    double kappa = 0;
-    bool can_get_curvature = pp_.canGetCurvature(&kappa);
-
-    publishTwistStamped(can_get_curvature, kappa);
-    publishControlCommandStamped(can_get_curvature, kappa);
-    // for visualization with Rviz
-    pub11_.publish(displayNextWaypoint(pp_.getPoseOfNextWaypoint()));
-    pub13_.publish(displaySearchRadius(
-      pp_.getCurrentPose().position, pp_.getLookaheadDistance()));
-    pub12_.publish(displayNextTarget(pp_.getPoseOfNextTarget()));
-    pub15_.publish(displayTrajectoryCircle(
-        waypoint_follower::generateTrajectoryCircle(
-          pp_.getPoseOfNextTarget(), pp_.getCurrentPose())));
-    if (add_virtual_end_waypoints_)
-    {
-      pub18_.publish(
-        displayExpandWaypoints(pp_.getCurrentWaypoints(), expand_size_));
-    }
-    std_msgs::Float32 angular_gravity_msg;
-    angular_gravity_msg.data =
-      computeAngularGravity(computeCommandVelocity(), kappa);
-    pub16_.publish(angular_gravity_msg);
-
-    publishDeviationCurrentPosition(
-      pp_.getCurrentPose().position, pp_.getCurrentWaypoints());
-
-    is_pose_set_ = false;
-    is_velocity_set_ = false;
-    is_waypoint_set_ = false;
-
-    if(task_profiling_flag) rubis::sched::stop_task_profiling(rubis::instance_, rubis::sched::task_state_);
-
-    if(rubis::sched::is_task_ready_ == TASK_READY && rubis::sched::task_state_ == TASK_STATE_DONE){
-      if(task_scheduling_flag) rubis::sched::yield_task_scheduling();
-      rubis::sched::task_state_ = TASK_STATE_READY;
-    }
-
-    loop_rate.sleep();
-  }
+  int rate;
+  private_nh.param<int>(node_name+"/rate", rate, 10);
+
+  struct rubis::sched_attr attr;
+  std::string policy;
+  int priority, exec_time ,deadline, period;
+    
+  private_nh.param(node_name+"/task_scheduling_configs/policy", policy, std::string("NONE"));    
+  private_nh.param(node_name+"/task_scheduling_configs/priority", priority, 99);
+  private_nh.param(node_name+"/task_scheduling_configs/exec_time", exec_time, 0);
+  private_nh.param(node_name+"/task_scheduling_configs/deadline", deadline, 0);
+  private_nh.param(node_name+"/task_scheduling_configs/period", period, 0);
+  attr = rubis::create_sched_attr(priority, exec_time, deadline, period);    
+  rubis::init_task_scheduling(policy, attr);
+
+  rubis::init_task_profiling(task_response_time_filename);
+
+  ros::spin();
 }
 
+
 void PurePursuitNode::publishTwistStamped(
   const bool& can_get_curvature, const double& kappa) const
 {
@@ -310,15 +231,11 @@ void PurePursuitNode::publishTwistStamped(
   ts.twist.angular.z = can_get_curvature ? kappa * ts.twist.linear.x : 0;
   twist_pub_.publish(ts);
 
-  if(rubis::instance_mode_ && rubis::instance_mode_ != RUBIS_NO_INSTANCE){
-    rubis_msgs::TwistStamped rubis_ts;
-    rubis_ts.instance = rubis::instance_;
-    rubis_ts.msg = ts;
-    rubis_twist_pub_.publish(rubis_ts);
-  }
-
-  if(rubis::sched::is_task_ready_ == TASK_NOT_READY) rubis::sched::init_task();
-  rubis::sched::task_state_ = TASK_STATE_DONE;
+  rubis_msgs::TwistStamped rubis_ts;
+  rubis_ts.instance = rubis::instance_;
+  rubis_ts.obj_instance = rubis::obj_instance_;
+  rubis_ts.msg = ts;
+  rubis_twist_pub_.publish(rubis_ts);
 }
 
 void PurePursuitNode::publishControlCommandStamped(
@@ -395,6 +312,7 @@ double PurePursuitNode::computeCommandVelocity() const
 
 double PurePursuitNode::computeCommandAccel() const
 {
+  if(pp_.getCurrentWaypoints().size() < 2) return 0.0;
   const geometry_msgs::Pose current_pose = pp_.getCurrentPose();
   const geometry_msgs::Pose target_pose =
     pp_.getCurrentWaypoints().at(1).pose.pose;
@@ -406,6 +324,7 @@ double PurePursuitNode::computeCommandAccel() const
   const double v0 = current_linear_velocity_;
   const double v = computeCommandVelocity();
   const double a = getSgn() * (v * v - v0 * v0) / (2 * x);
+
   return a;
 }
 
@@ -449,7 +368,7 @@ void PurePursuitNode::publishDeviationCurrentPosition(
   pub17_.publish(msg);
 }
 
-inline void PurePursuitNode::updateCurrentPose(const geometry_msgs::PoseStampedConstPtr& msg){
+inline void PurePursuitNode::updateCurrentPose(geometry_msgs::PoseStampedConstPtr& msg){
 #ifndef USE_WAYPOINT_ORIENTATION
   pp_.setCurrentPose(msg);
 #else
@@ -462,27 +381,6 @@ inline void PurePursuitNode::updateCurrentPose(const geometry_msgs::PoseStampedC
   is_pose_set_ = true;
 }
 
-void PurePursuitNode::callbackFromCurrentPose(const geometry_msgs::PoseStampedConstPtr& msg)
-{
-  updateCurrentPose(msg);
-}
-
-void PurePursuitNode::callbackFromRubisCurrentPose(const rubis_msgs::PoseStampedConstPtr& _msg)
-{
-  geometry_msgs::PoseStampedConstPtr msg = boost::make_shared<const geometry_msgs::PoseStamped>(_msg->msg);
-  rubis::instance_ = _msg->instance;
-  updateCurrentPose(msg);
-}
-
-#ifdef SVL
-void PurePursuitNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStampedConstPtr& msg)
-{
-  current_linear_velocity_ = msg->twist.linear.x;
-  pp_.setCurrentVelocity(current_linear_velocity_);
-  is_velocity_set_ = true;
-}
-#endif
-
 #ifdef IONIC
 void PurePursuitNode::callbackCtrlOutput(const can_data_msgs::Car_ctrl_output::ConstPtr &msg)
 {
@@ -526,19 +424,32 @@ double PurePursuitNode::findWayPointVelocity(autoware_msgs::Waypoint msg){
   return way_points_velocity_[idx];
 }
 
-void PurePursuitNode::callbackFromWayPoints(
-  const autoware_msgs::LaneConstPtr& msg)
+void PurePursuitNode::CallbackTwistPose(const rubis_msgs::PoseTwistStampedConstPtr& msg)
 {
+  rubis::start_task_profiling();
+  rubis::instance_ = msg->instance;
+
+  // Update pose
+  geometry_msgs::PoseStampedConstPtr pose_ptr(new geometry_msgs::PoseStamped(msg->pose));
+  updateCurrentPose(pose_ptr);
+
+  // Update twist
+  current_linear_velocity_ = msg->twist.twist.linear.x;
+  pp_.setCurrentVelocity(current_linear_velocity_);
+  is_velocity_set_ = true;
+
+  if(lane_.waypoints.size() < 1) return;
+
   if(use_algorithm_){
-    command_linear_velocity_ = findWayPointVelocity(msg->waypoints.at(0));
+    command_linear_velocity_ = findWayPointVelocity(lane_.waypoints.at(0));
   }
   else{
-    command_linear_velocity_ = (!msg->waypoints.empty()) ? msg->waypoints.at(0).twist.twist.linear.x : 0;
+    command_linear_velocity_ = (!lane_.waypoints.empty()) ? lane_.waypoints.at(0).twist.twist.linear.x : 0;
   }
 
-  geometry_msgs::Point curr_point = msg->waypoints.at(0).pose.pose.position;
-  geometry_msgs::Point near_point = msg->waypoints.at(std::min(3, (int)msg->waypoints.size() - 1)).pose.pose.position;
-  geometry_msgs::Point far_point = msg->waypoints.at(std::min(30, (int)msg->waypoints.size() - 1)).pose.pose.position;
+  geometry_msgs::Point curr_point = lane_.waypoints.at(0).pose.pose.position;
+  geometry_msgs::Point near_point = lane_.waypoints.at(std::min(3, (int)lane_.waypoints.size() - 1)).pose.pose.position;
+  geometry_msgs::Point far_point = lane_.waypoints.at(std::min(30, (int)lane_.waypoints.size() - 1)).pose.pose.position;
 
   double deg_1 = atan2((near_point.y - curr_point.y), (near_point.x - curr_point.x)) / 3.14 * 180;
   double deg_2 = atan2((far_point.y - curr_point.y), (far_point.x - curr_point.x)) / 3.14 * 180;
@@ -549,15 +460,58 @@ void PurePursuitNode::callbackFromWayPoints(
 
   angle_diff_ = angle_diff;
 
+  // Update waypoints
+  _CallbackFinalWaypointsWithPoseTwist();
+
+  // After spinOnce
+  pp_.setLookaheadDistance(computeLookaheadDistance());
+  pp_.setMinimumLookaheadDistance(minimum_lookahead_distance_);
+
+  double kappa = 0;
+  bool can_get_curvature = pp_.canGetCurvature(&kappa);
+
+  publishTwistStamped(can_get_curvature, kappa);
+  publishControlCommandStamped(can_get_curvature, kappa);
+  // for visualization with Rviz
+  pub11_.publish(displayNextWaypoint(pp_.getPoseOfNextWaypoint()));
+  pub13_.publish(displaySearchRadius(
+    pp_.getCurrentPose().position, pp_.getLookaheadDistance()));
+  pub12_.publish(displayNextTarget(pp_.getPoseOfNextTarget()));
+  pub15_.publish(displayTrajectoryCircle(
+      waypoint_follower::generateTrajectoryCircle(
+        pp_.getPoseOfNextTarget(), pp_.getCurrentPose())));
+  if (add_virtual_end_waypoints_)
+  {
+    pub18_.publish(
+      displayExpandWaypoints(pp_.getCurrentWaypoints(), expand_size_));
+  }
+  std_msgs::Float32 angular_gravity_msg;
+  angular_gravity_msg.data =
+    computeAngularGravity(computeCommandVelocity(), kappa);
+  pub16_.publish(angular_gravity_msg);
+
+  publishDeviationCurrentPosition(
+    pp_.getCurrentPose().position, pp_.getCurrentWaypoints());
+
+  is_pose_set_ = false;
+  is_velocity_set_ = false;
+  is_waypoint_set_ = false;
+
+  rubis::stop_task_profiling(rubis::instance_, 0);
+
+}
+
+void PurePursuitNode::_CallbackFinalWaypointsWithPoseTwist()
+{
   if(dynamic_param_flag_){
     setLookaheadParamsByVel();
   }
   
   if (add_virtual_end_waypoints_)
   {
-    const LaneDirection solved_dir = getLaneDirection(*msg);
+    const LaneDirection solved_dir = getLaneDirection(lane_);
     direction_ = (solved_dir != LaneDirection::Error) ? solved_dir : direction_;
-    autoware_msgs::Lane expanded_lane(*msg);
+    autoware_msgs::Lane expanded_lane(lane_);
     expand_size_ = -expanded_lane.waypoints.size();
     connectVirtualLastWaypoints(&expanded_lane, direction_);
     expand_size_ += expanded_lane.waypoints.size();
@@ -566,15 +520,21 @@ void PurePursuitNode::callbackFromWayPoints(
   }
   else
   {
-    pp_.setCurrentWaypoints(msg->waypoints);
+    pp_.setCurrentWaypoints(lane_.waypoints);
   }
   is_waypoint_set_ = true;
 
 #ifdef USE_WAYPOINT_ORIENTATION
-  waypoint_pose_ = msg->waypoints[0].pose;
+  waypoint_pose_ = lane_.waypoints[0].pose;
 #endif
 }
 
+void PurePursuitNode::CallbackFinalWaypointsWithPoseTwist(const rubis_msgs::LaneWithPoseTwistConstPtr& msg)
+{   
+  rubis::obj_instance_ = msg->obj_instance;
+  lane_ = msg->lane;
+}
+
 void PurePursuitNode::connectVirtualLastWaypoints(
   autoware_msgs::Lane* lane, LaneDirection direction)
 {
diff --git a/autoware.ai/src/autoware/core_planning/pure_pursuit/test/src/test_pure_pursuit.cpp b/autoware.ai/src/autoware/core_planning/pure_pursuit/test/src/test_pure_pursuit.cpp
deleted file mode 100644
index 5df8b48e..00000000
--- a/autoware.ai/src/autoware/core_planning/pure_pursuit/test/src/test_pure_pursuit.cpp
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Copyright 2018-2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <ros/ros.h>
-#include <gtest/gtest.h>
-#include <pure_pursuit/pure_pursuit_core.h>
-
-namespace waypoint_follower
-{
-class PurePursuitNodeTestSuite : public ::testing::Test
-{
-protected:
-  std::unique_ptr<PurePursuitNode> obj_;
-  virtual void SetUp()
-  {
-    obj_ = std::unique_ptr<PurePursuitNode>(new PurePursuitNode());
-    obj_->add_virtual_end_waypoints_ = true;
-  }
-  virtual void TearDown()
-  {
-    obj_.reset();
-  }
-
-public:
-  PurePursuitNodeTestSuite() {}
-  ~PurePursuitNodeTestSuite() {}
-  LaneDirection getDirection()
-  {
-    return obj_->direction_;
-  }
-  void ppCallbackFromWayPoints(const autoware_msgs::LaneConstPtr& msg)
-  {
-    obj_->callbackFromWayPoints(msg);
-  }
-  void ppConnectVirtualLastWaypoints(
-    autoware_msgs::Lane* expand_lane, LaneDirection direction)
-  {
-    obj_->connectVirtualLastWaypoints(expand_lane, direction);
-  }
-};
-
-TEST_F(PurePursuitNodeTestSuite, inputPositivePath)
-{
-  autoware_msgs::Lane original_lane;
-  original_lane.waypoints.resize(3, autoware_msgs::Waypoint());
-  for (int i = 0; i < 3; i++)
-  {
-    original_lane.waypoints[i].pose.pose.position.x = i;
-    original_lane.waypoints[i].pose.pose.orientation =
-      tf::createQuaternionMsgFromYaw(0.0);
-  }
-  const autoware_msgs::LaneConstPtr
-    lp(boost::make_shared<autoware_msgs::Lane>(original_lane));
-  ppCallbackFromWayPoints(lp);
-  ASSERT_EQ(getDirection(), LaneDirection::Forward)
-    << "direction is not matching to positive lane.";
-}
-
-TEST_F(PurePursuitNodeTestSuite, inputNegativePath)
-{
-  autoware_msgs::Lane original_lane;
-  original_lane.waypoints.resize(3, autoware_msgs::Waypoint());
-  for (int i = 0; i < 3; i++)
-  {
-    original_lane.waypoints[i].pose.pose.position.x = -i;
-    original_lane.waypoints[i].pose.pose.orientation =
-      tf::createQuaternionMsgFromYaw(0.0);
-  }
-  const autoware_msgs::LaneConstPtr
-    lp(boost::make_shared<autoware_msgs::Lane>(original_lane));
-  ppCallbackFromWayPoints(lp);
-  ASSERT_EQ(getDirection(), LaneDirection::Backward)
-    << "direction is not matching to negative lane.";
-}
-// If original lane is empty, new lane is also empty.
-TEST_F(PurePursuitNodeTestSuite, inputEmptyLane)
-{
-  autoware_msgs::Lane original_lane, new_lane;
-  ppConnectVirtualLastWaypoints(&new_lane, LaneDirection::Forward);
-  ASSERT_EQ(original_lane.waypoints.size(), new_lane.waypoints.size())
-    << "Input empty lane, and output is not empty";
-}
-
-// If the original lane exceeds 2 points,
-// the additional part will be updated at
-// the interval of the first 2 points.
-TEST_F(PurePursuitNodeTestSuite, inputNormalLane)
-{
-  autoware_msgs::Lane original_lane;
-  original_lane.waypoints.resize(2, autoware_msgs::Waypoint());
-  for (int i = 0; i < 2; i++)
-  {
-    original_lane.waypoints[i].pose.pose.position.x = i;
-  }
-  autoware_msgs::Lane new_lane(original_lane);
-  ppConnectVirtualLastWaypoints(&new_lane, LaneDirection::Forward);
-
-  ASSERT_LT(original_lane.waypoints.size(), new_lane.waypoints.size())
-    << "Fail to expand waypoints";
-}
-}  // namespace waypoint_follower
-
-int main(int argc, char** argv)
-{
-  testing::InitGoogleTest(&argc, argv);
-  ros::init(argc, argv, "PurePursuitTest");
-  return RUN_ALL_TESTS();
-}
diff --git a/autoware.ai/src/autoware/core_planning/pure_pursuit/test/test_pure_pursuit.test b/autoware.ai/src/autoware/core_planning/pure_pursuit/test/test_pure_pursuit.test
deleted file mode 100644
index caba2948..00000000
--- a/autoware.ai/src/autoware/core_planning/pure_pursuit/test/test_pure_pursuit.test
+++ /dev/null
@@ -1,3 +0,0 @@
-<launch>
-  <test test-name="test-pure_pursuit" pkg="pure_pursuit" type="test-pure_pursuit" name="test"/>
-</launch>
diff --git a/autoware.ai/src/autoware/core_planning/twist_filter/include/twist_filter/twist_filter_node.h b/autoware.ai/src/autoware/core_planning/twist_filter/include/twist_filter/twist_filter_node.h
index 997b984c..6c05ce54 100644
--- a/autoware.ai/src/autoware/core_planning/twist_filter/include/twist_filter/twist_filter_node.h
+++ b/autoware.ai/src/autoware/core_planning/twist_filter/include/twist_filter/twist_filter_node.h
@@ -50,8 +50,9 @@ private:
   ros::Subscriber twist_sub_, rubis_twist_sub_, ctrl_sub_, config_sub_;
   // Added by PHY
   ros::Subscriber emergency_stop_sub_;
+  autoware_msgs::ControlCommandStampedConstPtr ctrl_cmd_ptr_;
   
-  bool emergency_stop_;
+  bool emergency_stop_, current_emergency_stop_;
   int max_stop_count_;
   int current_stop_count_;
 
@@ -60,13 +61,16 @@ private:
   void rubisTwistCmdCallback(const rubis_msgs::TwistStampedConstPtr& _msg);
   inline void publishTwist(const geometry_msgs::TwistStampedConstPtr& msg);
   void ctrlCmdCallback(const autoware_msgs::ControlCommandStampedConstPtr& msg);
+  void _ctrlCmdCallback(const autoware_msgs::ControlCommandStampedConstPtr& msg);
   void checkTwist(const twist_filter::Twist twist, const twist_filter::Twist twist_prev, const double& dt);
   void checkCtrl(const twist_filter::Ctrl ctrl, const twist_filter::Ctrl ctrl_prev, const double& dt);
 
   //Added by PHY
   void emergencyStopCallback(const std_msgs::Bool& msg);
+  void _emergencyStopCallback();
 };
 
 }  // namespace twist_filter_node
 
 #endif  // TWIST_FILTER_TWIST_FILTER_NODE_H
+
diff --git a/autoware.ai/src/autoware/core_planning/twist_filter/launch/twist_filter.launch b/autoware.ai/src/autoware/core_planning/twist_filter/launch/twist_filter.launch
index 81dc1fed..b3b8806e 100644
--- a/autoware.ai/src/autoware/core_planning/twist_filter/launch/twist_filter.launch
+++ b/autoware.ai/src/autoware/core_planning/twist_filter/launch/twist_filter.launch
@@ -8,7 +8,6 @@
   <arg name="lowpass_gain_angular_z" default="0.0" />
   <arg name="lowpass_gain_steering_angle" default="0.0" />
   <arg name="max_stop_count" default="40" /> <!-- 10 = 1 second -->
-  <arg name="instance_mode" defaut="0" />
 
   <param name="vehicle_info/wheel_base" value="$(arg wheel_base)" />
 
@@ -24,12 +23,10 @@
     <param name="lowpass_gain_angular_z" value="$(arg lowpass_gain_angular_z)" />
     <param name="lowpass_gain_steering_angle" value="$(arg lowpass_gain_steering_angle)" />
     <param name="max_stop_count" value="$(arg max_stop_count)" />
-    <param name="instance_mode" value="$(arg instance_mode)" />
   </node>
 
-  <node pkg="twist_gate" type="twist_gate" name="twist_gate">
+  <node pkg="twist_gate" type="twist_gate" name="twist_gate" output="screen">
     <param name="loop_rate" value="$(arg loop_rate)" />
     <param name="use_decision_maker" value="$(arg use_decision_maker)" />
-    <param name="instance_mode" value="$(arg instance_mode)" />
   </node>
 </launch>
diff --git a/autoware.ai/src/autoware/core_planning/twist_filter/launch/twist_filter_params.launch b/autoware.ai/src/autoware/core_planning/twist_filter/launch/twist_filter_params.launch
index 0b470a12..b3b8806e 100644
--- a/autoware.ai/src/autoware/core_planning/twist_filter/launch/twist_filter_params.launch
+++ b/autoware.ai/src/autoware/core_planning/twist_filter/launch/twist_filter_params.launch
@@ -8,7 +8,6 @@
   <arg name="lowpass_gain_angular_z" default="0.0" />
   <arg name="lowpass_gain_steering_angle" default="0.0" />
   <arg name="max_stop_count" default="40" /> <!-- 10 = 1 second -->
-  <!-- <arg name="instance_mode" defaut="0" /> -->
 
   <param name="vehicle_info/wheel_base" value="$(arg wheel_base)" />
 
@@ -24,12 +23,10 @@
     <param name="lowpass_gain_angular_z" value="$(arg lowpass_gain_angular_z)" />
     <param name="lowpass_gain_steering_angle" value="$(arg lowpass_gain_steering_angle)" />
     <param name="max_stop_count" value="$(arg max_stop_count)" />
-    <!-- <param name="instance_mode" value="$(arg instance_mode)" /> -->
   </node>
 
-  <node pkg="twist_gate" type="twist_gate" name="twist_gate">
+  <node pkg="twist_gate" type="twist_gate" name="twist_gate" output="screen">
     <param name="loop_rate" value="$(arg loop_rate)" />
     <param name="use_decision_maker" value="$(arg use_decision_maker)" />
-    <!-- <param name="instance_mode" value="$(arg instance_mode)" /> -->
   </node>
 </launch>
diff --git a/autoware.ai/src/autoware/core_planning/twist_filter/src/twist_filter_node.cpp b/autoware.ai/src/autoware/core_planning/twist_filter/src/twist_filter_node.cpp
index 89165fd1..c447e46f 100644
--- a/autoware.ai/src/autoware/core_planning/twist_filter/src/twist_filter_node.cpp
+++ b/autoware.ai/src/autoware/core_planning/twist_filter/src/twist_filter_node.cpp
@@ -29,27 +29,19 @@ TwistFilterNode::TwistFilterNode() : nh_(), private_nh_("~")
   nh_.param("twist_filter/lowpass_gain_angular_z", twist_filter_config.lowpass_gain_angular_z, 0.0);
   nh_.param("twist_filter/lowpass_gain_steering_angle", twist_filter_config.lowpass_gain_steering_angle, 0.0);
   nh_.param("twist_filter/max_stop_count", max_stop_count_, 30);
-  nh_.param("twist_filter/instance_mode", rubis::instance_mode_, 0);
   twist_filter_ptr_ = std::make_shared<twist_filter::TwistFilter>(twist_filter_config);
   emergency_stop_ = false;
   current_stop_count_ = 0;
 
   // Subscribe
-  if(rubis::instance_mode_) rubis_twist_sub_ = nh_.subscribe("rubis_twist_raw", 1, &TwistFilterNode::rubisTwistCmdCallback, this);
-  else twist_sub_ = nh_.subscribe("twist_raw", 1, &TwistFilterNode::twistCmdCallback, this);
+  rubis_twist_sub_ = nh_.subscribe("rubis_twist_raw", 1, &TwistFilterNode::rubisTwistCmdCallback, this);
   ctrl_sub_ = nh_.subscribe("ctrl_raw", 1, &TwistFilterNode::ctrlCmdCallback, this);
   config_sub_ = nh_.subscribe("config/twist_filter", 10, &TwistFilterNode::configCallback, this);
   emergency_stop_sub_ = nh_.subscribe("emergency_stop", 1 ,&TwistFilterNode::emergencyStopCallback, this);
 
-  /*  RT Scheduling setup  */
-  // twist_sub_ = nh_.subscribe("twist_raw", 1, &TwistFilterNode::twistCmdCallback, this);
-  // ctrl_sub_ = nh_.subscribe("ctrl_raw", 1, &TwistFilterNode::ctrlCmdCallback, this);
-  // config_sub_ = nh_.subscribe("config/twist_filter", 1, &TwistFilterNode::configCallback, this); //origin 10
-  // emergency_stop_sub_ = nh_.subscribe("emergency_stop", 1 ,&TwistFilterNode::emergencyStopCallback, this);
-
   // Publish
   twist_pub_ = nh_.advertise<geometry_msgs::TwistStamped>("twist_cmd", 5);
-  if(rubis::instance_mode_) rubis_twist_pub_ = nh_.advertise<rubis_msgs::TwistStamped>("rubis_twist_cmd", 5);
+  rubis_twist_pub_ = nh_.advertise<rubis_msgs::TwistStamped>("rubis_twist_cmd", 5);
   ctrl_pub_ = nh_.advertise<autoware_msgs::ControlCommandStamped>("ctrl_cmd", 5);
   twist_lacc_limit_debug_pub_ = private_nh_.advertise<std_msgs::Float32>("limitation_debug/twist/lateral_accel", 5);
   twist_ljerk_limit_debug_pub_ = private_nh_.advertise<std_msgs::Float32>("limitation_debug/twist/lateral_jerk", 5);
@@ -113,6 +105,8 @@ inline void TwistFilterNode::publishTwist(const geometry_msgs::TwistStampedConst
   // Smoothed value publish
   geometry_msgs::TwistStamped out_msg = *msg;
   if(emergency_stop_ == false){
+    // out_msg.twist.linear.x = twist_out.lx;
+    // out_msg.twist.angular.z = twist_out.az;
     out_msg.twist.linear.x = twist_out.lx;
     out_msg.twist.angular.z = twist_out.az;
   }
@@ -121,15 +115,11 @@ inline void TwistFilterNode::publishTwist(const geometry_msgs::TwistStampedConst
     out_msg.twist.angular.z = 0;
   }
   twist_pub_.publish(out_msg);
-  if(rubis::instance_mode_ && rubis::instance_ != RUBIS_NO_INSTANCE){
-    rubis_msgs::TwistStamped rubis_out_msg;
-    rubis_out_msg.instance = rubis::instance_;
-    rubis_out_msg.msg = out_msg;
-    rubis_twist_pub_.publish(rubis_out_msg);
-  }
-
-  if(rubis::sched::is_task_ready_ == TASK_NOT_READY) rubis::sched::init_task();
-  rubis::sched::task_state_ = TASK_STATE_DONE;
+  rubis_msgs::TwistStamped rubis_out_msg;
+  rubis_out_msg.instance = rubis::instance_;
+  rubis_out_msg.obj_instance = rubis::obj_instance_;
+  rubis_out_msg.msg = out_msg;
+  rubis_twist_pub_.publish(rubis_out_msg);
 
   // Publish lateral accel and jerk after smoothing
   auto lacc_smoothed_result = twist_filter_ptr_->calcLaccWithAngularZ(twist_out);
@@ -153,20 +143,37 @@ inline void TwistFilterNode::publishTwist(const geometry_msgs::TwistStampedConst
 }
 
 void TwistFilterNode::rubisTwistCmdCallback(const rubis_msgs::TwistStampedConstPtr& _msg){
+  // Before spin
+  rubis::start_task_profiling();
+
+  // Callback
+  _emergencyStopCallback();
+  _ctrlCmdCallback(ctrl_cmd_ptr_);
+
   geometry_msgs::TwistStampedConstPtr msg = boost::make_shared<const geometry_msgs::TwistStamped>(_msg-> msg);
   rubis::instance_ = _msg->instance;
+  rubis::obj_instance_ = _msg->obj_instance;
   publishTwist(msg);
+
+  // After spin
+  rubis::stop_task_profiling(rubis::instance_, 0);
 }
 
 
 void TwistFilterNode::twistCmdCallback(const geometry_msgs::TwistStampedConstPtr& msg)
 {
-  rubis::instance_ = RUBIS_NO_INSTANCE;
+  rubis::instance_ = 0;
   publishTwist(msg);
 }
 
 void TwistFilterNode::ctrlCmdCallback(const autoware_msgs::ControlCommandStampedConstPtr& msg)
 {
+  ctrl_cmd_ptr_ = boost::make_shared<autoware_msgs::ControlCommandStamped const>(*msg);
+}
+
+void TwistFilterNode::_ctrlCmdCallback(const autoware_msgs::ControlCommandStampedConstPtr& msg)
+{
+  if(ctrl_cmd_ptr_ == NULL) return;
   const twist_filter::Ctrl ctrl = { msg->cmd.linear_velocity, msg->cmd.steering_angle };
   ros::Time current_time = ros::Time::now();
 
@@ -236,15 +243,19 @@ void TwistFilterNode::ctrlCmdCallback(const autoware_msgs::ControlCommandStamped
 }
 
 void TwistFilterNode::emergencyStopCallback(const std_msgs::Bool& msg){
-  bool current_emergency_stop = msg.data;
+  current_emergency_stop_ = msg.data;
+  return;
+}
+
+void TwistFilterNode::_emergencyStopCallback(){
   static std::string state("none");
   
-  if(current_emergency_stop == true){
+  if(current_emergency_stop_ == true){
     state = std::string("object is detected");
     emergency_stop_ = true;
     current_stop_count_ = max_stop_count_;
   }
-  else if(current_emergency_stop == false && emergency_stop_ == true){ // Emergency Stop event is finished or wait
+  else if(current_emergency_stop_ == false && emergency_stop_ == true){ // Emergency Stop event is finished or wait
     current_stop_count_--;
     if(current_stop_count_ > 0){
       state = std::string("Wait for go");
@@ -253,7 +264,7 @@ void TwistFilterNode::emergencyStopCallback(const std_msgs::Bool& msg){
     else
       emergency_stop_ = false;
   }
-  else if(current_emergency_stop == false && emergency_stop_ == false){ // No event
+  else if(current_emergency_stop_ == false && emergency_stop_ == false){ // No event
     state = std::string("No object");
     emergency_stop_ = false;
     current_stop_count_ = 0;
diff --git a/autoware.ai/src/autoware/core_planning/twist_filter/src/twist_filter_node_main.cpp b/autoware.ai/src/autoware/core_planning/twist_filter/src/twist_filter_node_main.cpp
index eb82a63b..6a1da019 100644
--- a/autoware.ai/src/autoware/core_planning/twist_filter/src/twist_filter_node_main.cpp
+++ b/autoware.ai/src/autoware/core_planning/twist_filter/src/twist_filter_node_main.cpp
@@ -17,67 +17,38 @@
 #include "twist_filter/twist_filter_node.h"
 
 extern unsigned long rubis::instance_;
+extern 
 
 int main(int argc, char** argv)
 {
   ros::init(argc, argv, "twist_filter");
   twist_filter_node::TwistFilterNode node;
 
-  // Scheduling Setup
-  int task_scheduling_flag;
-  int task_profiling_flag;
-  std::string task_response_time_filename;
-  int rate;
-  double task_minimum_inter_release_time;
-  double task_execution_time;
-  double task_relative_deadline;
-
   ros::NodeHandle private_nh("~");
-  private_nh.param<int>("/twist_filter/task_scheduling_flag", task_scheduling_flag, 0);
-  private_nh.param<int>("/twist_filter/task_profiling_flag", task_profiling_flag, 0);
-  private_nh.param<std::string>("/twist_filter/task_response_time_filename", task_response_time_filename, "~/Documents/profiling/response_time/twist_filter.csv");
-  private_nh.param<int>("/twist_filter/rate", rate, 10);
-  private_nh.param("/twist_filter/task_minimum_inter_release_time", task_minimum_inter_release_time, (double)10);
-  private_nh.param("/twist_filter/task_execution_time", task_execution_time, (double)10);
-  private_nh.param("/twist_filter/task_relative_deadline", task_relative_deadline, (double)10);
-
-  if(task_profiling_flag) rubis::sched::init_task_profiling(task_response_time_filename);
-  
-  if(!task_scheduling_flag && !task_profiling_flag){
-    ros::spin();
-  }
-  else{
-    ros::Rate r(rate);
-    // Initialize task ( Wait until first necessary topic is published )
-    while(ros::ok()){
-      if(rubis::sched::is_task_ready_ == TASK_READY) break;
-      ros::spinOnce();
-      r.sleep();      
-    }
-
-    // Executing task
-    while(ros::ok()){
-      if(task_profiling_flag) rubis::sched::start_task_profiling();
 
-      if(rubis::sched::task_state_ == TASK_STATE_READY){
-        if(task_scheduling_flag) rubis::sched::request_task_scheduling(task_minimum_inter_release_time, task_execution_time, task_relative_deadline); 
-        rubis::sched::task_state_ = TASK_STATE_RUNNING;     
-      }
-
-      ros::spinOnce();
-
-      if(task_profiling_flag){
-        rubis::sched::stop_task_profiling(rubis::instance_, rubis::sched::task_state_);
-      }
+  // Scheduling & Profiling Setup
+  std::string node_name = ros::this_node::getName();
+  std::string task_response_time_filename;
+  private_nh.param<std::string>(node_name+"/task_response_time_filename", task_response_time_filename, "~/Documents/profiling/response_time/twist_filter.csv");
 
-      if(rubis::sched::task_state_ == TASK_STATE_DONE){
-        if(task_scheduling_flag) rubis::sched::yield_task_scheduling();
-        rubis::sched::task_state_ = TASK_STATE_READY;
-      }
-      
-      r.sleep();
-    }
-  }
+  int rate;
+  private_nh.param<int>(node_name+"/rate", rate, 10);
+
+  struct rubis::sched_attr attr;
+  std::string policy;
+  int priority, exec_time ,deadline, period;
+    
+  private_nh.param(node_name+"/task_scheduling_configs/policy", policy, std::string("NONE"));    
+  private_nh.param(node_name+"/task_scheduling_configs/priority", priority, 99);
+  private_nh.param(node_name+"/task_scheduling_configs/exec_time", exec_time, 0);
+  private_nh.param(node_name+"/task_scheduling_configs/deadline", deadline, 0);
+  private_nh.param(node_name+"/task_scheduling_configs/period", period, 0);
+  attr = rubis::create_sched_attr(priority, exec_time, deadline, period);    
+  rubis::init_task_scheduling(policy, attr);
+
+  rubis::init_task_profiling(task_response_time_filename);
+  
+  ros::spin();
   
   return 0;
 }
diff --git a/autoware.ai/src/autoware/core_planning/twist_gate/CMakeLists.txt b/autoware.ai/src/autoware/core_planning/twist_gate/CMakeLists.txt
index 3073a8b7..6d0f645d 100644
--- a/autoware.ai/src/autoware/core_planning/twist_gate/CMakeLists.txt
+++ b/autoware.ai/src/autoware/core_planning/twist_gate/CMakeLists.txt
@@ -44,17 +44,4 @@ install(
   ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
   LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
   RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
-)
-
-if(CATKIN_ENABLE_TESTING)
-  roslint_add_test()
-  find_package(rostest REQUIRED)
-  add_rostest_gtest(
-    test-twist_gate
-    test/test_twist_gate.test
-    test/src/test_twist_gate.cpp
-    src/twist_gate.cpp
-  )
-  add_dependencies(test-twist_gate ${catkin_EXPORTED_TARGETS})
-  target_link_libraries(test-twist_gate ${catkin_LIBRARIES})
-endif()
+)
\ No newline at end of file
diff --git a/autoware.ai/src/autoware/core_planning/twist_gate/include/twist_gate/twist_gate.h b/autoware.ai/src/autoware/core_planning/twist_gate/include/twist_gate/twist_gate.h
index ba9dae2c..b6254f84 100644
--- a/autoware.ai/src/autoware/core_planning/twist_gate/include/twist_gate/twist_gate.h
+++ b/autoware.ai/src/autoware/core_planning/twist_gate/include/twist_gate/twist_gate.h
@@ -60,7 +60,8 @@ private:
   void watchdogTimer();
   void remoteCmdCallback(const remote_msgs_t::ConstPtr& input_msg);
   void autoCmdTwistCmdCallback(const geometry_msgs::TwistStamped::ConstPtr& input_msg);
-  void autoCmdRubisTwistCmdCallback(const rubis_msgs::TwistStamped::ConstPtr& _input_msg);
+  void autoCmdRubisTwistCmdCallback(const rubis_msgs::TwistStamped::ConstPtr& input_msg);
+  void _autoCmdRubisTwistCmdCallback(const rubis_msgs::TwistStamped::ConstPtr& input_msg);
   void modeCmdCallback(const tablet_socket_msgs::mode_cmd::ConstPtr& input_msg);
   void gearCmdCallback(const tablet_socket_msgs::gear_cmd::ConstPtr& input_msg);
   void accelCmdCallback(const autoware_msgs::AccelCmd::ConstPtr& input_msg);
@@ -89,6 +90,9 @@ private:
   ros::Subscriber config_sub_;
   std::map<std::string, ros::Subscriber> auto_cmd_sub_stdmap_;
   ros::Timer timer_;
+  ros::Time current_time_;
+
+  bool is_current_time_changed_;
 
   vehicle_cmd_msg_t twist_gate_msg_;
   rubis_msgs::VehicleCmd rubis_twist_gate_msg_;
@@ -101,6 +105,8 @@ private:
   std::thread watchdog_timer_thread_;
   bool is_alive;
 
+  rubis_msgs::TwistStamped::ConstPtr rubis_twist_cmd_ptr_;
+
   enum class CommandMode
   {
     AUTO = 1,
diff --git a/autoware.ai/src/autoware/core_planning/twist_gate/src/twist_gate.cpp b/autoware.ai/src/autoware/core_planning/twist_gate/src/twist_gate.cpp
index d008743b..e812acc9 100644
--- a/autoware.ai/src/autoware/core_planning/twist_gate/src/twist_gate.cpp
+++ b/autoware.ai/src/autoware/core_planning/twist_gate/src/twist_gate.cpp
@@ -45,32 +45,33 @@ TwistGate::TwistGate(const ros::NodeHandle& nh, const ros::NodeHandle& private_n
   , timeout_period_(10.0)
   , command_mode_(CommandMode::AUTO)
   , previous_command_mode_(CommandMode::AUTO)
+  , rubis_twist_cmd_ptr_(NULL)
+  , current_time_(0)
+  , is_current_time_changed_(false)
 {
   private_nh_.param<double>("loop_rate", loop_rate_, 30.0);
   private_nh_.param<bool>("use_decision_maker", use_decision_maker_, false);
-  private_nh_.param<int>("instance_mode", rubis::instance_mode_, 0);
 
   control_command_pub_ = nh_.advertise<std_msgs::String>("/ctrl_mode", 1);
   vehicle_cmd_pub_ = nh_.advertise<vehicle_cmd_msg_t>("/vehicle_cmd", 1, true);
-  if(rubis::instance_mode_) rubis_vehicle_cmd_pub_ = nh_.advertise<rubis_msgs::VehicleCmd>("/rubis_vehicle_cmd", 1, true);
-  remote_cmd_sub_ = nh_.subscribe("/remote_cmd", 1, &TwistGate::remoteCmdCallback, this);
-  config_sub_ = nh_.subscribe("config/twist_filter", 1, &TwistGate::configCallback, this);
-
+  rubis_vehicle_cmd_pub_ = nh_.advertise<rubis_msgs::VehicleCmd>("/rubis_vehicle_cmd", 1, true);
+  
   timer_ = nh_.createTimer(ros::Duration(1.0 / loop_rate_), &TwistGate::timerCallback, this);
 
-  if(rubis::instance_mode_) auto_cmd_sub_stdmap_["twist_cmd"] = nh_.subscribe("/rubis_twist_cmd", 1, &TwistGate::autoCmdRubisTwistCmdCallback, this);
-  else auto_cmd_sub_stdmap_["twist_cmd"] = nh_.subscribe("/twist_cmd", 1, &TwistGate::autoCmdTwistCmdCallback, this);
+  // remote_cmd_sub_ = nh_.subscribe("/remote_cmd", 1, &TwistGate::remoteCmdCallback, this);
+  config_sub_ = nh_.subscribe("config/twist_filter", 1, &TwistGate::configCallback, this);
+  auto_cmd_sub_stdmap_["twist_cmd"] = nh_.subscribe("/rubis_twist_cmd", 1, &TwistGate::autoCmdRubisTwistCmdCallback, this);
   
-  auto_cmd_sub_stdmap_["mode_cmd"] = nh_.subscribe("/mode_cmd", 1, &TwistGate::modeCmdCallback, this);
-  auto_cmd_sub_stdmap_["gear_cmd"] = nh_.subscribe("/gear_cmd", 1, &TwistGate::gearCmdCallback, this);
-  auto_cmd_sub_stdmap_["accel_cmd"] = nh_.subscribe("/accel_cmd", 1, &TwistGate::accelCmdCallback, this);
-  auto_cmd_sub_stdmap_["steer_cmd"] = nh_.subscribe("/steer_cmd", 1, &TwistGate::steerCmdCallback, this);
-  auto_cmd_sub_stdmap_["brake_cmd"] = nh_.subscribe("/brake_cmd", 1, &TwistGate::brakeCmdCallback, this);
-  auto_cmd_sub_stdmap_["lamp_cmd"] = nh_.subscribe("/lamp_cmd", 1, &TwistGate::lampCmdCallback, this);
-  auto_cmd_sub_stdmap_["ctrl_cmd"] = nh_.subscribe("/ctrl_cmd", 1, &TwistGate::ctrlCmdCallback, this);
-  auto_cmd_sub_stdmap_["state"] = nh_.subscribe("/decision_maker/state", 1, &TwistGate::stateCallback, this);
-  auto_cmd_sub_stdmap_["emergency_velocity"] =
-      nh_.subscribe("emergency_velocity", 1, &TwistGate::emergencyCmdCallback, this);
+  // auto_cmd_sub_stdmap_["mode_cmd"] = nh_.subscribe("/mode_cmd", 1, &TwistGate::modeCmdCallback, this);
+  // auto_cmd_sub_stdmap_["gear_cmd"] = nh_.subscribe("/gear_cmd", 1, &TwistGate::gearCmdCallback, this);
+  // auto_cmd_sub_stdmap_["accel_cmd"] = nh_.subscribe("/accel_cmd", 1, &TwistGate::accelCmdCallback, this);
+  // auto_cmd_sub_stdmap_["steer_cmd"] = nh_.subscribe("/steer_cmd", 1, &TwistGate::steerCmdCallback, this);
+  // auto_cmd_sub_stdmap_["brake_cmd"] = nh_.subscribe("/brake_cmd", 1, &TwistGate::brakeCmdCallback, this);
+  // auto_cmd_sub_stdmap_["lamp_cmd"] = nh_.subscribe("/lamp_cmd", 1, &TwistGate::lampCmdCallback, this);
+  // auto_cmd_sub_stdmap_["ctrl_cmd"] = nh_.subscribe("/ctrl_cmd", 1, &TwistGate::ctrlCmdCallback, this);
+  // auto_cmd_sub_stdmap_["state"] = nh_.subscribe("/decision_maker/state", 1, &TwistGate::stateCallback, this);
+  // auto_cmd_sub_stdmap_["emergency_velocity"] =
+  //     nh_.subscribe("emergency_velocity", 1, &TwistGate::emergencyCmdCallback, this);
 
 
   twist_gate_msg_.header.seq = 0;
@@ -192,15 +193,26 @@ void TwistGate::remoteCmdCallback(const remote_msgs_t::ConstPtr& input_msg)
 
 void TwistGate::autoCmdTwistCmdCallback(const geometry_msgs::TwistStamped::ConstPtr& input_msg)
 {
-  rubis::instance_ = RUBIS_NO_INSTANCE;
+  rubis::instance_ = 0;
   updateTwistGateMsg(input_msg); 
 }
 
-void TwistGate::autoCmdRubisTwistCmdCallback(const rubis_msgs::TwistStamped::ConstPtr& _input_msg)
+void TwistGate::_autoCmdRubisTwistCmdCallback(const rubis_msgs::TwistStamped::ConstPtr& input_msg)
 {
-  geometry_msgs::TwistStamped::ConstPtr input_msg = boost::make_shared<const geometry_msgs::TwistStamped>(_input_msg->msg);
-  rubis::instance_ = _input_msg->instance;
-  updateTwistGateMsg(input_msg); 
+  if(rubis_twist_cmd_ptr_ == NULL) return;
+  if(!is_current_time_changed_){
+    current_time_ = input_msg->msg.header.stamp;  
+    is_current_time_changed_ = true;
+  }
+  rubis::instance_ = input_msg->instance;  
+  rubis::obj_instance_ = input_msg->obj_instance;  
+  geometry_msgs::TwistStamped::ConstPtr _input_msg = boost::make_shared<const geometry_msgs::TwistStamped>(input_msg->msg);
+  updateTwistGateMsg(_input_msg); 
+}
+
+void TwistGate::autoCmdRubisTwistCmdCallback(const rubis_msgs::TwistStamped::ConstPtr& input_msg)
+{
+  rubis_twist_cmd_ptr_ = boost::make_shared<rubis_msgs::TwistStamped const>(*input_msg);
 }
 
 inline void TwistGate::updateTwistGateMsg(const geometry_msgs::TwistStamped::ConstPtr& input_msg){
@@ -211,14 +223,9 @@ inline void TwistGate::updateTwistGateMsg(const geometry_msgs::TwistStamped::Con
     twist_gate_msg_.header.seq++;
     twist_gate_msg_.twist_cmd.twist = input_msg->twist;
     
-    if(rubis::instance_mode_ && rubis::instance_ != RUBIS_NO_INSTANCE){
-      rubis_twist_gate_msg_.instance = rubis::instance_;
-    }
+    rubis_twist_gate_msg_.instance = rubis::instance_;
     checkState();
   }
-
-  if(rubis::sched::is_task_ready_ == TASK_NOT_READY) rubis::sched::init_task();
-  rubis::sched::task_state_ = TASK_STATE_DONE;
 }
 
 void TwistGate::modeCmdCallback(const tablet_socket_msgs::mode_cmd::ConstPtr& input_msg)
@@ -347,15 +354,45 @@ void TwistGate::emergencyCmdCallback(const vehicle_cmd_msg_t::ConstPtr& input_ms
 
 void TwistGate::timerCallback(const ros::TimerEvent& e)
 {
+  rubis::start_task_profiling();
+  if(rubis_twist_cmd_ptr_ == NULL){
+    rubis::stop_task_profiling(rubis::instance_, 0);
+    return;
+  }
+  
+
+  static ros::Time previous_time = ros::Time::now(); 
+  static double previous_target_velocity = 0.0;
+  static double previous_target_accel = 0.0;
+
+  // Callback
+  _autoCmdRubisTwistCmdCallback(rubis_twist_cmd_ptr_);  
+
+  double diff_time = (current_time_ - previous_time).toSec();
+  double current_target_velocity = 0.0, current_target_accel = 0.0;
+
+  current_target_velocity = rubis_twist_cmd_ptr_->msg.twist.linear.x;
+  current_target_accel = (diff_time > 0) ? ((current_target_velocity - previous_target_velocity) / diff_time) : previous_target_accel;
+  
   if(zero_flag_ == 1)
     resetVehicleCmdMsg();
+  twist_gate_msg_.ctrl_cmd.linear_acceleration = current_target_accel;
+  twist_gate_msg_.ctrl_cmd.linear_velocity = current_target_velocity;
 
   vehicle_cmd_pub_.publish(twist_gate_msg_);
-  if(rubis::instance_mode_){
-    rubis_twist_gate_msg_.msg = twist_gate_msg_;
-    rubis_vehicle_cmd_pub_.publish(rubis_twist_gate_msg_);
+  rubis_twist_gate_msg_.msg = twist_gate_msg_;
+  rubis_vehicle_cmd_pub_.publish(rubis_twist_gate_msg_);
+  
+  
+  
+  if(is_current_time_changed_){
+    previous_time = current_time_;
+    previous_target_velocity = current_target_velocity;
+    previous_target_accel = current_target_accel;
+    is_current_time_changed_ = false;    
   }
-  rubis::sched::task_state_ = TASK_STATE_DONE;
+
+  rubis::stop_task_profiling(rubis::instance_, 0);
 }
 
 void TwistGate::configCallback(const autoware_config_msgs::ConfigTwistFilter& msg)
diff --git a/autoware.ai/src/autoware/core_planning/twist_gate/src/twist_gate_node.cpp b/autoware.ai/src/autoware/core_planning/twist_gate/src/twist_gate_node.cpp
index e3f3e429..9e0bc827 100644
--- a/autoware.ai/src/autoware/core_planning/twist_gate/src/twist_gate_node.cpp
+++ b/autoware.ai/src/autoware/core_planning/twist_gate/src/twist_gate_node.cpp
@@ -28,61 +28,31 @@ int main(int argc, char** argv)
   ros::NodeHandle nh;
   ros::NodeHandle private_nh("~");
 
-  // Scheduling Setup
-  int task_scheduling_flag;
-  int task_profiling_flag;
-  std::string task_response_time_filename;
-  int rate;
-  double task_minimum_inter_release_time;
-  double task_execution_time;
-  double task_relative_deadline;
-
-  private_nh.param<int>("/twist_gate/task_scheduling_flag", task_scheduling_flag, 0);
-  private_nh.param<int>("/twist_gate/task_profiling_flag", task_profiling_flag, 0);
-  private_nh.param<std::string>("/twist_gate/task_response_time_filename", task_response_time_filename, "~/Documents/profiling/response_time/twist_gate.csv");
-  private_nh.param<int>("/twist_gate/rate", rate, 10);
-  private_nh.param("/twist_gate/task_minimum_inter_release_time", task_minimum_inter_release_time, (double)10);
-  private_nh.param("/twist_gate/task_execution_time", task_execution_time, (double)10);
-  private_nh.param("/twist_gate/task_relative_deadline", task_relative_deadline, (double)10);
-  private_nh.param<int>("/twist_gate/zero_flag", zero_flag_, 0);
-
   TwistGate twist_gate(nh, private_nh);
 
-  if(task_profiling_flag) rubis::sched::init_task_profiling(task_response_time_filename);
-
-  if(!task_scheduling_flag && !task_profiling_flag){
-    ros::spin();
-  }
-  else{
-    ros::Rate r(rate);
-    // Initialize task ( Wait until first necessary topic is published )
-    while(ros::ok()){
-      if(rubis::sched::is_task_ready_ == TASK_READY) break;
-      ros::spinOnce();
-      r.sleep();      
-    }
-
-    // Executing task
-    while(ros::ok()){
-      if(task_profiling_flag) rubis::sched::start_task_profiling();
-
-      if(rubis::sched::task_state_ == TASK_STATE_READY){
-        if(task_scheduling_flag) rubis::sched::request_task_scheduling(task_minimum_inter_release_time, task_execution_time, task_relative_deadline); 
-        rubis::sched::task_state_ = TASK_STATE_RUNNING;     
-      }
-
-      ros::spinOnce();
-
-      if(task_profiling_flag) rubis::sched::stop_task_profiling(rubis::instance_, rubis::sched::task_state_);
+  // Scheduling & Profiling Setup
+  std::string node_name = ros::this_node::getName();
+  std::string task_response_time_filename;
+  private_nh.param<std::string>(node_name+"/task_response_time_filename", task_response_time_filename, "~/Documents/profiling/response_time/twist_gate.csv");
 
-      if(rubis::sched::task_state_ == TASK_STATE_DONE){
-        if(task_scheduling_flag) rubis::sched::yield_task_scheduling();
-        rubis::sched::task_state_ = TASK_STATE_READY;
-      }
-      
-      r.sleep();
-    }
-  }
+  int rate;
+  private_nh.param<int>(node_name+"/rate", rate, 10);
+
+  struct rubis::sched_attr attr;
+  std::string policy;
+  int priority, exec_time ,deadline, period;
+    
+  private_nh.param(node_name+"/task_scheduling_configs/policy", policy, std::string("NONE"));    
+  private_nh.param(node_name+"/task_scheduling_configs/priority", priority, 99);
+  private_nh.param(node_name+"/task_scheduling_configs/exec_time", exec_time, 0);
+  private_nh.param(node_name+"/task_scheduling_configs/deadline", deadline, 0);
+  private_nh.param(node_name+"/task_scheduling_configs/period", period, 0);
+  attr = rubis::create_sched_attr(priority, exec_time, deadline, period);    
+  rubis::init_task_scheduling(policy, attr);
+
+  rubis::init_task_profiling(task_response_time_filename);
+
+  ros::spin();
 
   return 0;
 }
diff --git a/autoware.ai/src/autoware/core_planning/twist_gate/test/src/test_twist_gate.cpp b/autoware.ai/src/autoware/core_planning/twist_gate/test/src/test_twist_gate.cpp
deleted file mode 100644
index cf8882a2..00000000
--- a/autoware.ai/src/autoware/core_planning/twist_gate/test/src/test_twist_gate.cpp
+++ /dev/null
@@ -1,351 +0,0 @@
-/*
- * Copyright 2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <gtest/gtest.h>
-#include <ros/ros.h>
-
-#include "test_twist_gate.hpp"
-
-class TwistGateTestSuite : public ::testing::Test
-{
-public:
-  TwistGateTestSuite() {}
-  ~TwistGateTestSuite() {}
-
-  TwistGateTestClass test_obj_;
-
-protected:
-  virtual void SetUp()
-  {
-    ros::NodeHandle nh;
-    ros::NodeHandle private_nh("~");
-    test_obj_.tg = new TwistGate(nh, private_nh);
-  };
-  virtual void TearDown() { delete test_obj_.tg; }
-};
-
-TEST_F(TwistGateTestSuite, resetVehicelCmd)
-{
-  double d_value = 1.5;
-  int i_value = 1;
-
-  autoware_msgs::VehicleCmd msg = test_obj_.setTgTwistGateMsg(d_value, i_value);
-
-  ASSERT_EQ(d_value, msg.twist_cmd.twist.linear.x);
-  ASSERT_EQ(d_value, msg.twist_cmd.twist.angular.z);
-  ASSERT_EQ(i_value, msg.mode);
-  ASSERT_EQ(i_value, msg.gear_cmd.gear);
-  ASSERT_EQ(i_value, msg.lamp_cmd.l);
-  ASSERT_EQ(i_value, msg.lamp_cmd.r);
-  ASSERT_EQ(i_value, msg.accel_cmd.accel);
-  ASSERT_EQ(i_value, msg.brake_cmd.brake);
-  ASSERT_EQ(i_value, msg.steer_cmd.steer);
-  ASSERT_EQ(i_value, msg.ctrl_cmd.linear_velocity);
-  ASSERT_EQ(i_value, msg.ctrl_cmd.steering_angle);
-  ASSERT_EQ(i_value, msg.emergency);
-
-  test_obj_.tgResetVehicleCmdMsg();
-  msg = test_obj_.getTgTwistGateMsg();
-
-  ASSERT_EQ(0, msg.twist_cmd.twist.linear.x);
-  ASSERT_EQ(0, msg.twist_cmd.twist.angular.z);
-  ASSERT_EQ(0, msg.mode);
-  ASSERT_EQ(0, msg.gear_cmd.gear);
-  ASSERT_EQ(0, msg.lamp_cmd.l);
-  ASSERT_EQ(0, msg.lamp_cmd.r);
-  ASSERT_EQ(0, msg.accel_cmd.accel);
-  ASSERT_EQ(0, msg.brake_cmd.brake);
-  ASSERT_EQ(0, msg.steer_cmd.steer);
-  ASSERT_EQ(-1, msg.ctrl_cmd.linear_velocity);
-  ASSERT_EQ(0, msg.ctrl_cmd.steering_angle);
-  ASSERT_EQ(0, msg.emergency);
-}
-
-TEST_F(TwistGateTestSuite, twistCmdCallback)
-{
-  double linear_x = 5.0;
-  double angular_z = 1.5;
-  test_obj_.publishTwistCmd(linear_x, angular_z);
-  ros::WallDuration(0.1).sleep();
-  test_obj_.tgSpinOnce();
-  for (int i = 0; i < 3; i++)
-  {
-    ros::WallDuration(0.1).sleep();
-    ros::spinOnce();
-  }
-
-  ASSERT_EQ(linear_x, test_obj_.cb_vehicle_cmd.twist_cmd.twist.linear.x);
-  ASSERT_EQ(angular_z, test_obj_.cb_vehicle_cmd.twist_cmd.twist.angular.z);
-}
-
-TEST_F(TwistGateTestSuite, controlCmdCallback)
-{
-  double linear_vel = 5.0;
-  double linear_acc = 1.5;
-  double steer_angle = 1.57;
-  test_obj_.publishControlCmd(linear_vel, linear_acc, steer_angle);
-  ros::WallDuration(0.1).sleep();
-  test_obj_.tgSpinOnce();
-  for (int i = 0; i < 3; i++)
-  {
-    ros::WallDuration(0.1).sleep();
-    ros::spinOnce();
-  }
-
-
-  ASSERT_EQ(linear_vel, test_obj_.cb_vehicle_cmd.ctrl_cmd.linear_velocity);
-  ASSERT_EQ(linear_acc, test_obj_.cb_vehicle_cmd.ctrl_cmd.linear_acceleration);
-  ASSERT_EQ(steer_angle, test_obj_.cb_vehicle_cmd.ctrl_cmd.steering_angle);
-}
-
-TEST_F(TwistGateTestSuite, remoteCmdCallback)
-{
-  autoware_msgs::RemoteCmd remote_cmd;
-  remote_cmd.vehicle_cmd.header.frame_id = "/test_frame";
-  remote_cmd.vehicle_cmd.header.stamp = ros::Time::now();
-  remote_cmd.vehicle_cmd.twist_cmd.twist.linear.x = 5.0;
-  remote_cmd.vehicle_cmd.twist_cmd.twist.angular.z = 0.785;
-  remote_cmd.vehicle_cmd.ctrl_cmd.linear_velocity = 4.0;
-  remote_cmd.vehicle_cmd.ctrl_cmd.linear_acceleration = 3.0;
-  remote_cmd.vehicle_cmd.ctrl_cmd.steering_angle = 0.393;
-  remote_cmd.vehicle_cmd.accel_cmd.accel = 10;
-  remote_cmd.vehicle_cmd.brake_cmd.brake = 20;
-  remote_cmd.vehicle_cmd.steer_cmd.steer = 30;
-  remote_cmd.vehicle_cmd.gear_cmd.gear = autoware_msgs::Gear::PARK;
-  remote_cmd.vehicle_cmd.lamp_cmd.l = 1;
-  remote_cmd.vehicle_cmd.lamp_cmd.r = 1;
-  remote_cmd.vehicle_cmd.mode = 6;
-  remote_cmd.vehicle_cmd.emergency = 0;
-  remote_cmd.control_mode = 2;
-
-  test_obj_.publishRemoteCmd(remote_cmd);
-  ros::WallDuration(0.1).sleep();
-  test_obj_.tgSpinOnce();
-  for (int i = 0; i < 3; i++)
-  {
-    ros::WallDuration(0.1).sleep();
-    ros::spinOnce();
-  }
-
-  ASSERT_EQ(remote_cmd.vehicle_cmd.header.frame_id
-      , test_obj_.cb_vehicle_cmd.header.frame_id);
-  ASSERT_EQ(remote_cmd.vehicle_cmd.header.stamp
-      , test_obj_.cb_vehicle_cmd.header.stamp);
-  ASSERT_EQ(remote_cmd.vehicle_cmd.twist_cmd.twist.linear.x
-      , test_obj_.cb_vehicle_cmd.twist_cmd.twist.linear.x);
-  ASSERT_EQ(remote_cmd.vehicle_cmd.twist_cmd.twist.angular.z
-      , test_obj_.cb_vehicle_cmd.twist_cmd.twist.angular.z);
-  ASSERT_EQ(remote_cmd.vehicle_cmd.ctrl_cmd.linear_velocity
-      , test_obj_.cb_vehicle_cmd.ctrl_cmd.linear_velocity);
-  ASSERT_EQ(remote_cmd.vehicle_cmd.ctrl_cmd.linear_acceleration
-      , test_obj_.cb_vehicle_cmd.ctrl_cmd.linear_acceleration);
-  ASSERT_EQ(remote_cmd.vehicle_cmd.ctrl_cmd.steering_angle
-      , test_obj_.cb_vehicle_cmd.ctrl_cmd.steering_angle);
-  ASSERT_EQ(remote_cmd.vehicle_cmd.accel_cmd.accel
-      , test_obj_.cb_vehicle_cmd.accel_cmd.accel);
-  ASSERT_EQ(remote_cmd.vehicle_cmd.brake_cmd.brake
-      , test_obj_.cb_vehicle_cmd.brake_cmd.brake);
-  ASSERT_EQ(remote_cmd.vehicle_cmd.steer_cmd.steer
-      , test_obj_.cb_vehicle_cmd.steer_cmd.steer);
-  ASSERT_EQ(remote_cmd.vehicle_cmd.gear_cmd.gear
-      , test_obj_.cb_vehicle_cmd.gear_cmd.gear);
-  ASSERT_EQ(remote_cmd.vehicle_cmd.lamp_cmd.l
-      , test_obj_.cb_vehicle_cmd.lamp_cmd.l);
-  ASSERT_EQ(remote_cmd.vehicle_cmd.lamp_cmd.r
-      , test_obj_.cb_vehicle_cmd.lamp_cmd.r);
-  ASSERT_EQ(remote_cmd.vehicle_cmd.mode
-      , test_obj_.cb_vehicle_cmd.mode);
-}
-
-TEST_F(TwistGateTestSuite, modeCmdCallback)
-{
-  int mode = 8;
-
-  test_obj_.publishModeCmd(mode);
-  ros::WallDuration(0.1).sleep();
-  test_obj_.tgSpinOnce();
-  for (int i = 0; i < 3; i++)
-  {
-    ros::WallDuration(0.1).sleep();
-    ros::spinOnce();
-  }
-
-
-  ASSERT_EQ(mode, test_obj_.cb_vehicle_cmd.mode);
-}
-
-TEST_F(TwistGateTestSuite, gearCmdCallback)
-{
-  int gear = autoware_msgs::Gear::DRIVE;
-
-  test_obj_.publishGearCmd(gear);
-  ros::WallDuration(0.1).sleep();
-  test_obj_.tgSpinOnce();
-  for (int i = 0; i < 3; i++)
-  {
-    ros::WallDuration(0.1).sleep();
-    ros::spinOnce();
-  }
-
-
-  ASSERT_EQ(gear, test_obj_.cb_vehicle_cmd.gear_cmd.gear);
-}
-
-TEST_F(TwistGateTestSuite, accelCmdCallback)
-{
-  int accel = 100;
-
-  test_obj_.publishAccelCmd(accel);
-  ros::WallDuration(0.1).sleep();
-  test_obj_.tgSpinOnce();
-  for (int i = 0; i < 3; i++)
-  {
-    ros::WallDuration(0.1).sleep();
-    ros::spinOnce();
-  }
-
-  ASSERT_EQ(accel, test_obj_.cb_vehicle_cmd.accel_cmd.accel);
-}
-
-TEST_F(TwistGateTestSuite, steerCmdCallback)
-{
-  int steer = 100;
-
-  test_obj_.publishSteerCmd(steer);
-  ros::WallDuration(0.1).sleep();
-  test_obj_.tgSpinOnce();
-  for (int i = 0; i < 3; i++)
-  {
-    ros::WallDuration(0.1).sleep();
-    ros::spinOnce();
-  }
-
-
-  ASSERT_EQ(steer, test_obj_.cb_vehicle_cmd.steer_cmd.steer);
-}
-
-TEST_F(TwistGateTestSuite, brakeCmdCallback)
-{
-  int brake = 100;
-
-  test_obj_.publishBrakeCmd(brake);
-  ros::WallDuration(0.1).sleep();
-  test_obj_.tgSpinOnce();
-  for (int i = 0; i < 3; i++)
-  {
-    ros::WallDuration(0.1).sleep();
-    ros::spinOnce();
-  }
-
-
-  ASSERT_EQ(brake, test_obj_.cb_vehicle_cmd.brake_cmd.brake);
-}
-
-TEST_F(TwistGateTestSuite, lampCmdCallback)
-{
-  int lamp_l = 1;
-  int lamp_r = 1;
-
-  test_obj_.publishLampCmd(lamp_l, lamp_r);
-  ros::WallDuration(0.1).sleep();
-  test_obj_.tgSpinOnce();
-  for (int i = 0; i < 3; i++)
-  {
-    ros::WallDuration(0.1).sleep();
-    ros::spinOnce();
-  }
-
-  ASSERT_EQ(lamp_l, test_obj_.cb_vehicle_cmd.lamp_cmd.l);
-  ASSERT_EQ(lamp_r, test_obj_.cb_vehicle_cmd.lamp_cmd.r);
-}
-
-TEST_F(TwistGateTestSuite, emergencyVehicleCmdCallback)
-{
-  int lamp_l_pre = 0;
-  int lamp_r_pre = 0;
-  int emergency = 1;
-
-  test_obj_.publishLampCmd(lamp_l_pre, lamp_r_pre);
-  test_obj_.publishEmergencyVehicleCmd(emergency);
-  ros::WallDuration(0.1).sleep();
-  test_obj_.tgSpinOnce();
-
-  for (int i = 0; i < 3; i++)
-  {
-    ros::WallDuration(0.1).sleep();
-    ros::spinOnce();
-  }
-
-  ASSERT_EQ(emergency, test_obj_.cb_vehicle_cmd.emergency);
-
-  int lamp_l = 1;
-  int lamp_r = 1;
-  test_obj_.publishLampCmd(lamp_l, lamp_r);
-  ros::WallDuration(0.1).sleep();
-  test_obj_.tgSpinOnce();
-
-  for (int i = 0; i < 3; i++)
-  {
-    ros::WallDuration(0.1).sleep();
-    ros::spinOnce();
-  }
-
-  ASSERT_EQ(lamp_l_pre, test_obj_.cb_vehicle_cmd.lamp_cmd.l);
-  ASSERT_EQ(lamp_r_pre, test_obj_.cb_vehicle_cmd.lamp_cmd.r);
-
-  std::this_thread::sleep_for(std::chrono::milliseconds(10000));
-
-  test_obj_.publishLampCmd(lamp_l, lamp_r);
-  ros::WallDuration(0.1).sleep();
-  test_obj_.tgSpinOnce();
-
-  for (int i = 0; i < 3; i++)
-  {
-    ros::WallDuration(0.1).sleep();
-    ros::spinOnce();
-  }
-
-  ASSERT_EQ(lamp_l, test_obj_.cb_vehicle_cmd.lamp_cmd.l);
-  ASSERT_EQ(lamp_r, test_obj_.cb_vehicle_cmd.lamp_cmd.r);
-}
-
-TEST_F(TwistGateTestSuite, stateCallback)
-{
-  test_obj_.publishDecisionMakerState("VehicleReady\nWaitOrder\nWaitEngage\n");
-  test_obj_.tgSpinOnce();
-  ros::WallDuration(0.1).sleep();
-  ros::spinOnce();
-
-  autoware_msgs::VehicleCmd tg_msg = test_obj_.getTwistGateMsg();
-  ASSERT_EQ(autoware_msgs::Gear::PARK, tg_msg.gear_cmd.gear);
-  ASSERT_EQ(false, test_obj_.getIsStateDriveFlag());
-
-  test_obj_.publishDecisionMakerState("VehicleReady\nDriving\nDrive\n");
-  test_obj_.tgSpinOnce();
-  ros::WallDuration(0.1).sleep();
-  ros::spinOnce();
-
-  tg_msg = test_obj_.getTwistGateMsg();
-  ASSERT_EQ(autoware_msgs::Gear::DRIVE, tg_msg.gear_cmd.gear);
-  ASSERT_EQ(true, test_obj_.getIsStateDriveFlag());
-}
-
-int main(int argc, char **argv)
-{
-  testing::InitGoogleTest(&argc, argv);
-  ros::init(argc, argv, "TwistGateTestNode");
-  return RUN_ALL_TESTS();
-}
diff --git a/autoware.ai/src/autoware/core_planning/twist_gate/test/src/test_twist_gate.hpp b/autoware.ai/src/autoware/core_planning/twist_gate/test/src/test_twist_gate.hpp
deleted file mode 100644
index bd4acca1..00000000
--- a/autoware.ai/src/autoware/core_planning/twist_gate/test/src/test_twist_gate.hpp
+++ /dev/null
@@ -1,168 +0,0 @@
-/*
- * Copyright 2019 Autoware Foundation. All rights reserved.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <gtest/gtest.h>
-#include <ros/ros.h>
-
-#include "twist_gate/twist_gate.h"
-
-class TwistGateTestClass {
-public:
-  TwistGateTestClass() {
-    twist_cmd_publisher =
-        nh.advertise<geometry_msgs::TwistStamped>("twist_cmd", 0);
-    control_cmd_publisher =
-        nh.advertise<autoware_msgs::ControlCommandStamped>("ctrl_cmd", 0);
-    decision_maker_state_publisher =
-        nh.advertise<std_msgs::String>("decision_maker/state", 0);
-    remote_cmd_publisher = nh.advertise<autoware_msgs::RemoteCmd>("remote_cmd", 0);
-    mode_cmd_publisher = nh.advertise<tablet_socket_msgs::mode_cmd>("mode_cmd", 0);
-    gear_cmd_publisher = nh.advertise<tablet_socket_msgs::gear_cmd>("gear_cmd", 0);
-    accel_cmd_publisher = nh.advertise<autoware_msgs::AccelCmd>("accel_cmd", 0);
-    steer_cmd_publisher = nh.advertise<autoware_msgs::SteerCmd>("steer_cmd", 0);
-    brake_cmd_publisher = nh.advertise<autoware_msgs::BrakeCmd>("brake_cmd", 0);
-    lamp_cmd_publisher = nh.advertise<autoware_msgs::LampCmd>("lamp_cmd", 0);
-    emergency_vehicle_cmd_publisher = nh.advertise<autoware_msgs::VehicleCmd>("emergency_velocity", 0);
-    vehicle_cmd_subscriber = nh.subscribe(
-        "/vehicle_cmd", 1, &TwistGateTestClass::vehicleCmdCallback, this);
-  }
-
-  TwistGate *tg;
-  autoware_msgs::VehicleCmd cb_vehicle_cmd;
-
-  ros::NodeHandle nh;
-  ros::Publisher twist_cmd_publisher, control_cmd_publisher, remote_cmd_publisher, mode_cmd_publisher, gear_cmd_publisher, accel_cmd_publisher, steer_cmd_publisher, brake_cmd_publisher, lamp_cmd_publisher, decision_maker_state_publisher, emergency_vehicle_cmd_publisher;
-  ros::Subscriber vehicle_cmd_subscriber;
-
-  void tgSpinOnce() { tg->spinOnce(); }
-
-  void tgResetVehicleCmdMsg() { tg->resetVehicleCmdMsg(); }
-
-  autoware_msgs::VehicleCmd setTgTwistGateMsg(double d_value, int i_value) {
-    tg->twist_gate_msg_.twist_cmd.twist.linear.x = d_value;
-    tg->twist_gate_msg_.twist_cmd.twist.angular.z = d_value;
-    tg->twist_gate_msg_.mode = i_value;
-    tg->twist_gate_msg_.gear_cmd.gear = i_value;
-    tg->twist_gate_msg_.lamp_cmd.l = i_value;
-    tg->twist_gate_msg_.lamp_cmd.r = i_value;
-    tg->twist_gate_msg_.accel_cmd.accel = i_value;
-    tg->twist_gate_msg_.brake_cmd.brake = i_value;
-    tg->twist_gate_msg_.steer_cmd.steer = i_value;
-    tg->twist_gate_msg_.ctrl_cmd.linear_velocity = i_value;
-    tg->twist_gate_msg_.ctrl_cmd.steering_angle = i_value;
-    tg->twist_gate_msg_.emergency = i_value;
-
-    return tg->twist_gate_msg_;
-  }
-
-  autoware_msgs::VehicleCmd getTgTwistGateMsg() {return tg->twist_gate_msg_;}
-
-  void publishTwistCmd(double linear_x, double angular_z) {
-    geometry_msgs::TwistStamped msg;
-    msg.header.stamp = ros::Time::now();
-    msg.twist.linear.x = linear_x;
-    msg.twist.angular.z = angular_z;
-
-    twist_cmd_publisher.publish(msg);
-  }
-
-  void publishControlCmd(double linear_vel, double linear_acc,
-                         double steer_angle) {
-    autoware_msgs::ControlCommandStamped msg;
-    msg.header.stamp = ros::Time::now();
-    msg.cmd.linear_velocity = linear_vel;
-    msg.cmd.linear_acceleration = linear_acc;
-    msg.cmd.steering_angle = steer_angle;
-
-    control_cmd_publisher.publish(msg);
-  }
-
-  void publishRemoteCmd(autoware_msgs::RemoteCmd remote_cmd){
-    remote_cmd_publisher.publish(remote_cmd);
-  }
-
-  void publishModeCmd(int mode){
-    tablet_socket_msgs::mode_cmd msg;
-    msg.header.stamp = ros::Time::now();
-    msg.mode = mode;
-
-    mode_cmd_publisher.publish(msg);
-  }
-
-  void publishGearCmd(int gear){
-    tablet_socket_msgs::gear_cmd msg;
-    msg.header.stamp = ros::Time::now();
-    msg.gear = gear;
-
-    gear_cmd_publisher.publish(msg);
-  }
-
-  void publishAccelCmd(int accel){
-    autoware_msgs::AccelCmd msg;
-    msg.header.stamp = ros::Time::now();
-    msg.accel = accel;
-
-    accel_cmd_publisher.publish(msg);
-  }
-
-  void publishSteerCmd(int steer){
-    autoware_msgs::SteerCmd msg;
-    msg.header.stamp = ros::Time::now();
-    msg.steer = steer;
-
-    steer_cmd_publisher.publish(msg);
-  }
-
-  void publishBrakeCmd(int brake){
-    autoware_msgs::BrakeCmd msg;
-    msg.header.stamp = ros::Time::now();
-    msg.brake = brake;
-
-    brake_cmd_publisher.publish(msg);
-  }
-
-  void publishLampCmd(int lamp_l, int lamp_r){
-    autoware_msgs::LampCmd msg;
-    msg.header.stamp = ros::Time::now();
-    msg.l = lamp_l;
-    msg.r = lamp_r;
-
-    lamp_cmd_publisher.publish(msg);
-  }
-
-  void publishEmergencyVehicleCmd(int emergency){
-    autoware_msgs::VehicleCmd msg;
-    msg.header.stamp = ros::Time::now();
-    msg.emergency = emergency;
-
-    emergency_vehicle_cmd_publisher.publish(msg);
-  }
-
-  void publishDecisionMakerState(std::string states) {
-    std_msgs::String msg;
-    msg.data = states;
-
-    decision_maker_state_publisher.publish(msg);
-  }
-
-  void vehicleCmdCallback(autoware_msgs::VehicleCmd msg) {
-    cb_vehicle_cmd = msg;
-  }
-
-  autoware_msgs::VehicleCmd getTwistGateMsg() { return tg->twist_gate_msg_; }
-
-  bool getIsStateDriveFlag() { return tg->is_state_drive_; }
-};
diff --git a/autoware.ai/src/autoware/core_planning/twist_gate/test/test_twist_gate.test b/autoware.ai/src/autoware/core_planning/twist_gate/test/test_twist_gate.test
deleted file mode 100644
index abe4934a..00000000
--- a/autoware.ai/src/autoware/core_planning/twist_gate/test/test_twist_gate.test
+++ /dev/null
@@ -1,5 +0,0 @@
-<launch>
-
-  <test test-name="test-twist_gate" pkg="twist_gate" type="test-twist_gate" name="test"/>
-
-</launch>
diff --git a/autoware.ai/src/autoware/messages/nav_msgs/CHANGELOG.rst b/autoware.ai/src/autoware/messages/nav_msgs/CHANGELOG.rst
new file mode 100644
index 00000000..41c70f27
--- /dev/null
+++ b/autoware.ai/src/autoware/messages/nav_msgs/CHANGELOG.rst
@@ -0,0 +1,267 @@
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+Changelog for package nav_msgs
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+1.13.1 (2021-01-11)
+-------------------
+* Update package maintainers (`#168 <https://github.com/ros/common_msgs/issues/168>`_)
+* Add LoadMap service (`#164 <https://github.com/ros/common_msgs/issues/164>`_)
+* Contributors: David V. Lu!!, Michel Hidalgo
+
+1.13.0 (2020-05-21)
+-------------------
+* Bump CMake version to avoid CMP0048 warning (`#158 <https://github.com/ros/common_msgs/issues/158>`_)
+* Contributors: Shane Loretz
+
+1.12.7 (2018-11-06)
+-------------------
+
+1.12.6 (2018-05-03)
+-------------------
+
+1.12.5 (2016-09-30)
+-------------------
+
+1.12.4 (2016-02-22)
+-------------------
+
+1.12.3 (2015-04-20)
+-------------------
+
+1.12.2 (2015-03-21)
+-------------------
+* change type of initial_pose in SetMap service to PoseWithCovarianceStamped
+* Contributors: Stephan Wirth
+
+1.12.1 (2015-03-17)
+-------------------
+* updating outdated urls. fixes `#52 <https://github.com/ros/common_msgs/issues/52>`_.
+* Adds a SetMap service message to support swap maps functionality in amcl
+* Contributors: Tully Foote, liz-murphy
+
+1.12.0 (2014-12-29)
+-------------------
+
+1.11.6 (2014-11-04)
+-------------------
+
+1.11.5 (2014-10-27)
+-------------------
+
+1.11.4 (2014-06-19)
+-------------------
+
+1.11.3 (2014-05-07)
+-------------------
+* Export architecture_independent flag in package.xml
+* Contributors: Scott K Logan
+
+1.11.2 (2014-04-24)
+-------------------
+
+1.11.1 (2014-04-16)
+-------------------
+
+1.11.0 (2014-03-04)
+-------------------
+
+1.10.6 (2014-02-27)
+-------------------
+
+1.10.5 (2014-02-25)
+-------------------
+
+1.10.4 (2014-02-18)
+-------------------
+
+1.10.3 (2014-01-07)
+-------------------
+
+1.10.2 (2013-08-19)
+-------------------
+
+1.10.1 (2013-08-16)
+-------------------
+
+1.10.0 (2013-07-13)
+-------------------
+
+1.9.16 (2013-05-21)
+-------------------
+* added action definition for getting maps
+* update email in package.xml
+
+1.9.15 (2013-03-08)
+-------------------
+
+1.9.14 (2013-01-19)
+-------------------
+
+1.9.13 (2013-01-13)
+-------------------
+
+1.9.12 (2013-01-02)
+-------------------
+
+1.9.11 (2012-12-17)
+-------------------
+* modified dep type of catkin
+
+1.9.10 (2012-12-13)
+-------------------
+* add missing downstream depend
+* switched from langs to message_* packages
+
+1.9.9 (2012-11-22)
+------------------
+
+1.9.8 (2012-11-14)
+------------------
+
+1.9.7 (2012-10-30)
+------------------
+* fix catkin function order
+
+1.9.6 (2012-10-18)
+------------------
+* updated cmake min version to 2.8.3, use cmake_parse_arguments instead of custom macro
+
+1.9.5 (2012-09-28)
+------------------
+
+1.9.4 (2012-09-27 18:06)
+------------------------
+
+1.9.3 (2012-09-27 17:39)
+------------------------
+* cleanup
+* cleaned up package.xml files
+* updated to latest catkin
+* fixed dependencies and more
+* updated to latest catkin: created package.xmls, updated CmakeLists.txt
+
+1.9.2 (2012-09-05)
+------------------
+* updated pkg-config in manifest.xml
+
+1.9.1 (2012-09-04)
+------------------
+* use install destination variables, removed manual installation of manifests
+
+1.9.0 (2012-08-29)
+------------------
+* updated to current catkin
+
+1.8.13 (2012-07-26 18:34:15 +0000)
+----------------------------------
+
+1.8.8 (2012-06-12 22:36)
+------------------------
+* make find_package REQUIRED
+* removed obsolete catkin tag from manifest files
+* fixed package dependencies for several common messages (fixed `#3956 <https://github.com/ros/common_msgs/issues/3956>`_)
+* adding manifest exports
+* removed depend, added catkin
+* stripping depend and export tags from common_msgs manifests as msg dependencies are now declared in cmake and stack.yaml.  Also removed bag migration exports
+* common_msgs: removing migration rules as all are over a year old
+* bye bye vestigial MSG_DIRS
+* nav_msgs: getting rid of other build files and cleaning up
+* common_msgs: starting catkin conversion
+* adios rosbuild2 in manifest.xml
+* catkin updates
+* catkin_project
+* Updated to work with new message generation macros
+* More tweaking for standalone message generation
+* Getting standalone message generation working... w/o munging rosbuild2
+* more rosbuild2 hacking
+* missing dependencies
+* updating bagmigration exports
+* rosbuild2 taking shape
+* removing old exports ros`#2292 <https://github.com/ros/common_msgs/issues/2292>`_
+* Added Ubuntu platform tags to manifest
+* Adding a start pose to the GetPlan service
+* Remove use of deprecated rosbuild macros
+* Fixing migration rules for nav_msgs.
+* Changed byte to int8, in response to map_server doc review
+* changing review status
+* adding documentation for `#2997 <https://github.com/ros/common_msgs/issues/2997>`_
+* removing redundant range statements as per ticket:2997
+* Adding documentation to the Odometry message to make things more clear
+* manifest update
+* updated description and url
+* full migration rules
+* adding child_frame_id as per discussion about odometry message
+* Adding a header to Path
+* Adding a header to the GridCells message
+* Adding a new GridCells message for displaying obstacles in nav_view and rviz
+* clearing API reviews for they've been through a bunch of them recently.
+* fixing stack name
+* Adding comments to path
+* documenting messages
+* Making odometry migration fail until we have worked out appropriate way to handle covariances.
+* Changing naming of bag migration rules.
+* Modifying migration rules for Odometry and WrenchStamped change of field names.
+* Adding actual migration rules for all of the tested common_msgs migrations.
+* `#2250 <https://github.com/ros/common_msgs/issues/2250>`_ getting rid of _with_covariance in Odometry fields
+* nav_msgs: added missing srv export
+* Adding migration rules to get migration tests to pass.
+* removing last of robot_msgs and all dependencies on it
+* moving Path from robot_msgs to nav_msgs `#2281 <https://github.com/ros/common_msgs/issues/2281>`_
+* adding header to OccupancyGrid `#1906 <https://github.com/ros/common_msgs/issues/1906>`_
+* First half of the change from deprecated_msgs::RobotBase2DOdom to nav_msgs::Odometry, I think all the c++ compiles, can't speak for functionality yet, also... the python has yet to be run... this may break some things
+* moving PoseArray into geometry_msgs `#1907 <https://github.com/ros/common_msgs/issues/1907>`_
+* fixing names
+* Removing header since there's already one in the pose and fixing message definition to have variable names
+* adding Odometry message as per API review and ticket:2250
+* merging in the changes to messages see ros-users email.  THis is about half the common_msgs API changes
+* Forgot to check in the services I added.... shoot
+* Moving StaticMap.srv to GetMap.srv and moving Plan.srv to GetPlan.srv, also moving them to nav_msgs and removing the nav_srvs package
+* Merging tha actionlib branch back into trunk
+  r29135@att (orig r19792):  eitanme | 2009-07-27 18:30:30 -0700
+  Creating a branch for actionlib.... hopefully for the last time
+  r29137@att (orig r19794):  eitanme | 2009-07-27 18:32:49 -0700
+  Changing ParticleCloud to PoseArray
+  r29139@att (orig r19796):  eitanme | 2009-07-27 18:33:42 -0700
+  Adding action definition to the rep
+  r29148@att (orig r19805):  eitanme | 2009-07-27 18:47:39 -0700
+  Some fixes... almost compiling
+  r29165@att (orig r19822):  eitanme | 2009-07-27 20:41:07 -0700
+  Macro version of the typedefs that compiles
+  r29213@att (orig r19869):  eitanme | 2009-07-28 11:49:10 -0700
+  Compling version of the ActionServer re-write complete with garbage collection, be default it will keep goals without goal handles for 5 seconds
+  r29220@att (orig r19876):  eitanme | 2009-07-28 12:06:06 -0700
+  Fix to make sure that transitions into preempting and recalling states actually happen
+  r29254@att (orig r19888):  eitanme | 2009-07-28 13:27:40 -0700
+  Forgot to actually call the cancel callback... addind a subscriber on the cancel topic
+  r29267@att (orig r19901):  eitanme | 2009-07-28 14:41:09 -0700
+  Adding text field to GoalStatus to allow users to throw some debugging information into the GoalStatus messages
+  r29275@att (orig r19909):  eitanme | 2009-07-28 15:43:49 -0700
+  Using tf remapping as I should've been doing for awhile
+  r29277@att (orig r19911):  eitanme | 2009-07-28 15:48:48 -0700
+  The navigation stack can now handle goals that aren't in the global frame. However, these goals will be transformed to the global frame at the time of reception, so for achieving them accurately the global frame of move_base should really be set to match the goals.
+  r29299@att (orig r19933):  stuglaser | 2009-07-28 17:08:10 -0700
+  Created genaction.py script to create the various messages that an action needs
+  r29376@att (orig r20003):  vijaypradeep | 2009-07-29 02:45:24 -0700
+  ActionClient is running. MoveBase ActionServer seems to be crashing
+  r29409@att (orig r20033):  vijaypradeep | 2009-07-29 11:57:54 -0700
+  Fixing bug with adding status trackers
+  r29410@att (orig r20034):  vijaypradeep | 2009-07-29 11:58:18 -0700
+  Changing from Release to Debug
+  r29432@att (orig r20056):  vijaypradeep | 2009-07-29 14:07:30 -0700
+  No longer building goal_manager_test.cpp
+  r29472@att (orig r20090):  vijaypradeep | 2009-07-29 17:04:14 -0700
+  Lots of Client-Side doxygen
+  r29484@att (orig r20101):  vijaypradeep | 2009-07-29 18:35:01 -0700
+  Adding to mainpage.dox
+  r29487@att (orig r20104):  eitanme | 2009-07-29 18:55:06 -0700
+  Removing file to help resolve merge I hope
+  r29489@att (orig r20106):  eitanme | 2009-07-29 19:00:07 -0700
+  Removing another file to try to resolve the branch
+  r29492@att (orig r20108):  eitanme | 2009-07-29 19:14:25 -0700
+  Again removing a file to get the merge working
+  r29493@att (orig r20109):  eitanme | 2009-07-29 19:34:45 -0700
+  Removing yet another file on which ssl negotiation fails
+  r29500@att (orig r20116):  eitanme | 2009-07-29 19:54:18 -0700
+  Fixing bug in genaction
+* moving MapMetaData and OccGrid into nav_msgs `#1303 <https://github.com/ros/common_msgs/issues/1303>`_
+* created nav_msgs and moved ParticleCloud there `#1300 <https://github.com/ros/common_msgs/issues/1300>`_
diff --git a/autoware.ai/src/autoware/messages/nav_msgs/CMakeLists.txt b/autoware.ai/src/autoware/messages/nav_msgs/CMakeLists.txt
new file mode 100644
index 00000000..b4751819
--- /dev/null
+++ b/autoware.ai/src/autoware/messages/nav_msgs/CMakeLists.txt
@@ -0,0 +1,29 @@
+cmake_minimum_required(VERSION 3.0.2)
+project(nav_msgs)
+
+find_package(catkin REQUIRED COMPONENTS geometry_msgs message_generation std_msgs actionlib_msgs)
+
+add_message_files(
+  DIRECTORY msg
+  FILES
+  GridCells.msg
+  MapMetaData.msg
+  OccupancyGrid.msg
+  Odometry.msg
+  Path.msg)
+
+add_service_files(
+  DIRECTORY srv
+  FILES
+  GetMap.srv
+  GetPlan.srv
+  SetMap.srv
+  LoadMap.srv)
+
+add_action_files(
+  FILES
+  GetMap.action)
+
+generate_messages(DEPENDENCIES geometry_msgs std_msgs actionlib_msgs)
+
+catkin_package(CATKIN_DEPENDS geometry_msgs message_runtime std_msgs actionlib_msgs)
diff --git a/autoware.ai/src/autoware/messages/nav_msgs/action/GetMap.action b/autoware.ai/src/autoware/messages/nav_msgs/action/GetMap.action
new file mode 100644
index 00000000..080e54fe
--- /dev/null
+++ b/autoware.ai/src/autoware/messages/nav_msgs/action/GetMap.action
@@ -0,0 +1,5 @@
+# Get the map as a nav_msgs/OccupancyGrid
+---
+nav_msgs/OccupancyGrid map
+---
+# no feedback
\ No newline at end of file
diff --git a/autoware.ai/src/autoware/messages/nav_msgs/msg/GridCells.msg b/autoware.ai/src/autoware/messages/nav_msgs/msg/GridCells.msg
new file mode 100644
index 00000000..2c928941
--- /dev/null
+++ b/autoware.ai/src/autoware/messages/nav_msgs/msg/GridCells.msg
@@ -0,0 +1,5 @@
+#an array of cells in a 2D grid
+Header header
+float32 cell_width
+float32 cell_height
+geometry_msgs/Point[] cells
diff --git a/autoware.ai/src/autoware/messages/nav_msgs/msg/MapMetaData.msg b/autoware.ai/src/autoware/messages/nav_msgs/msg/MapMetaData.msg
new file mode 100644
index 00000000..398fbdd0
--- /dev/null
+++ b/autoware.ai/src/autoware/messages/nav_msgs/msg/MapMetaData.msg
@@ -0,0 +1,13 @@
+# This hold basic information about the characterists of the OccupancyGrid
+
+# The time at which the map was loaded
+time map_load_time
+# The map resolution [m/cell]
+float32 resolution
+# Map width [cells]
+uint32 width
+# Map height [cells]
+uint32 height
+# The origin of the map [m, m, rad].  This is the real-world pose of the
+# cell (0,0) in the map.
+geometry_msgs/Pose origin
\ No newline at end of file
diff --git a/autoware.ai/src/autoware/messages/nav_msgs/msg/OccupancyGrid.msg b/autoware.ai/src/autoware/messages/nav_msgs/msg/OccupancyGrid.msg
new file mode 100644
index 00000000..f2e79bda
--- /dev/null
+++ b/autoware.ai/src/autoware/messages/nav_msgs/msg/OccupancyGrid.msg
@@ -0,0 +1,11 @@
+# This represents a 2-D grid map, in which each cell represents the probability of
+# occupancy.
+
+Header header 
+
+#MetaData for the map
+MapMetaData info
+
+# The map data, in row-major order, starting with (0,0).  Occupancy
+# probabilities are in the range [0,100].  Unknown is -1.
+int8[] data
diff --git a/autoware.ai/src/autoware/messages/nav_msgs/msg/Odometry.msg b/autoware.ai/src/autoware/messages/nav_msgs/msg/Odometry.msg
new file mode 100644
index 00000000..73578ed8
--- /dev/null
+++ b/autoware.ai/src/autoware/messages/nav_msgs/msg/Odometry.msg
@@ -0,0 +1,7 @@
+# This represents an estimate of a position and velocity in free space.  
+# The pose in this message should be specified in the coordinate frame given by header.frame_id.
+# The twist in this message should be specified in the coordinate frame given by the child_frame_id
+Header header
+string child_frame_id
+geometry_msgs/PoseWithCovariance pose
+geometry_msgs/TwistWithCovariance twist
diff --git a/autoware.ai/src/autoware/messages/nav_msgs/msg/Path.msg b/autoware.ai/src/autoware/messages/nav_msgs/msg/Path.msg
new file mode 100644
index 00000000..979cb7d3
--- /dev/null
+++ b/autoware.ai/src/autoware/messages/nav_msgs/msg/Path.msg
@@ -0,0 +1,3 @@
+#An array of poses that represents a Path for a robot to follow
+Header header
+geometry_msgs/PoseStamped[] poses
diff --git a/autoware.ai/src/autoware/messages/nav_msgs/package.xml b/autoware.ai/src/autoware/messages/nav_msgs/package.xml
new file mode 100644
index 00000000..f379061f
--- /dev/null
+++ b/autoware.ai/src/autoware/messages/nav_msgs/package.xml
@@ -0,0 +1,29 @@
+<package>
+  <name>nav_msgs</name>
+  <version>1.13.1</version>
+  <description>
+    nav_msgs defines the common messages used to interact with the
+    <a href="http://wiki.ros.org/navigation">navigation</a> stack.
+  </description>
+  <maintainer email="michel@ekumenlabs.com">Michel Hidalgo</maintainer>
+  <license>BSD</license>
+
+  <url>http://wiki.ros.org/nav_msgs</url>
+  <author email="tfoote@osrfoundation.org">Tully Foote</author>
+
+  <buildtool_depend>catkin</buildtool_depend>
+
+  <build_depend>geometry_msgs</build_depend>
+  <build_depend>message_generation</build_depend>
+  <build_depend>std_msgs</build_depend>
+  <build_depend>actionlib_msgs</build_depend>
+
+  <run_depend>geometry_msgs</run_depend>
+  <run_depend>message_runtime</run_depend>
+  <run_depend>std_msgs</run_depend>
+  <run_depend>actionlib_msgs</run_depend>
+
+  <export>
+    <architecture_independent/>
+  </export>
+</package>
diff --git a/autoware.ai/src/autoware/messages/nav_msgs/srv/GetMap.srv b/autoware.ai/src/autoware/messages/nav_msgs/srv/GetMap.srv
new file mode 100644
index 00000000..6bd8e4a6
--- /dev/null
+++ b/autoware.ai/src/autoware/messages/nav_msgs/srv/GetMap.srv
@@ -0,0 +1,3 @@
+# Get the map as a nav_msgs/OccupancyGrid
+---
+nav_msgs/OccupancyGrid map
diff --git a/autoware.ai/src/autoware/messages/nav_msgs/srv/GetPlan.srv b/autoware.ai/src/autoware/messages/nav_msgs/srv/GetPlan.srv
new file mode 100644
index 00000000..f5c23edb
--- /dev/null
+++ b/autoware.ai/src/autoware/messages/nav_msgs/srv/GetPlan.srv
@@ -0,0 +1,13 @@
+# Get a plan from the current position to the goal Pose 
+
+# The start pose for the plan
+geometry_msgs/PoseStamped start
+
+# The final pose of the goal position
+geometry_msgs/PoseStamped goal
+
+# If the goal is obstructed, how many meters the planner can 
+# relax the constraint in x and y before failing. 
+float32 tolerance
+---
+nav_msgs/Path plan
diff --git a/autoware.ai/src/autoware/messages/nav_msgs/srv/LoadMap.srv b/autoware.ai/src/autoware/messages/nav_msgs/srv/LoadMap.srv
new file mode 100644
index 00000000..3b9caaad
--- /dev/null
+++ b/autoware.ai/src/autoware/messages/nav_msgs/srv/LoadMap.srv
@@ -0,0 +1,15 @@
+# URL of map resource
+# Can be an absolute path to a file: file:///path/to/maps/floor1.yaml
+# Or, relative to a ROS package: package://my_ros_package/maps/floor2.yaml
+string map_url
+---
+# Result code defintions
+uint8 RESULT_SUCCESS=0
+uint8 RESULT_MAP_DOES_NOT_EXIST=1
+uint8 RESULT_INVALID_MAP_DATA=2
+uint8 RESULT_INVALID_MAP_METADATA=3
+uint8 RESULT_UNDEFINED_FAILURE=255
+
+# Returned map is only valid if result equals RESULT_SUCCESS
+nav_msgs/OccupancyGrid map
+uint8 result
diff --git a/autoware.ai/src/autoware/messages/nav_msgs/srv/SetMap.srv b/autoware.ai/src/autoware/messages/nav_msgs/srv/SetMap.srv
new file mode 100644
index 00000000..55d3c24f
--- /dev/null
+++ b/autoware.ai/src/autoware/messages/nav_msgs/srv/SetMap.srv
@@ -0,0 +1,6 @@
+# Set a new map together with an initial pose
+nav_msgs/OccupancyGrid map
+geometry_msgs/PoseWithCovarianceStamped initial_pose
+---
+bool success
+
diff --git a/autoware.ai/src/autoware/messages/rubis_msgs/CMakeLists.txt b/autoware.ai/src/autoware/messages/rubis_msgs/CMakeLists.txt
index b2ae90cd..be86b1e7 100644
--- a/autoware.ai/src/autoware/messages/rubis_msgs/CMakeLists.txt
+++ b/autoware.ai/src/autoware/messages/rubis_msgs/CMakeLists.txt
@@ -18,6 +18,9 @@ add_message_files(
     TwistStamped.msg
     VehicleCmd.msg
     InsStat.msg
+    PoseTwistStamped.msg
+    LaneWithPoseTwist.msg
+    LaneArrayWithPoseTwist.msg
     DetectedObjectArray.msg
 )
 
diff --git a/autoware.ai/src/autoware/messages/rubis_msgs/msg/DetectedObjectArray.msg b/autoware.ai/src/autoware/messages/rubis_msgs/msg/DetectedObjectArray.msg
index dae5bd5d..5c47b6ac 100644
--- a/autoware.ai/src/autoware/messages/rubis_msgs/msg/DetectedObjectArray.msg
+++ b/autoware.ai/src/autoware/messages/rubis_msgs/msg/DetectedObjectArray.msg
@@ -1,2 +1,3 @@
 uint64 instance
-autoware_msgs/DetectedObjectArray object_array
\ No newline at end of file
+autoware_msgs/DetectedObjectArray object_array
+uint64 obj_instance
\ No newline at end of file
diff --git a/autoware.ai/src/autoware/messages/rubis_msgs/msg/LaneArrayWithPoseTwist.msg b/autoware.ai/src/autoware/messages/rubis_msgs/msg/LaneArrayWithPoseTwist.msg
new file mode 100644
index 00000000..a7c1df6f
--- /dev/null
+++ b/autoware.ai/src/autoware/messages/rubis_msgs/msg/LaneArrayWithPoseTwist.msg
@@ -0,0 +1,5 @@
+uint64 instance
+autoware_msgs/LaneArray lane_array
+geometry_msgs/PoseStamped pose
+geometry_msgs/TwistStamped twist
+uint64 obj_instance
\ No newline at end of file
diff --git a/autoware.ai/src/autoware/messages/rubis_msgs/msg/LaneWithPoseTwist.msg b/autoware.ai/src/autoware/messages/rubis_msgs/msg/LaneWithPoseTwist.msg
new file mode 100644
index 00000000..05da6d2a
--- /dev/null
+++ b/autoware.ai/src/autoware/messages/rubis_msgs/msg/LaneWithPoseTwist.msg
@@ -0,0 +1,5 @@
+uint64 instance
+autoware_msgs/Lane lane
+geometry_msgs/PoseStamped pose
+geometry_msgs/TwistStamped twist
+uint64 obj_instance
\ No newline at end of file
diff --git a/autoware.ai/src/autoware/messages/rubis_msgs/msg/PoseTwistStamped.msg b/autoware.ai/src/autoware/messages/rubis_msgs/msg/PoseTwistStamped.msg
new file mode 100644
index 00000000..03d0fa20
--- /dev/null
+++ b/autoware.ai/src/autoware/messages/rubis_msgs/msg/PoseTwistStamped.msg
@@ -0,0 +1,3 @@
+uint64 instance
+geometry_msgs/PoseStamped pose
+geometry_msgs/TwistStamped twist
\ No newline at end of file
diff --git a/autoware.ai/src/autoware/messages/rubis_msgs/msg/TwistStamped.msg b/autoware.ai/src/autoware/messages/rubis_msgs/msg/TwistStamped.msg
index b2cde46b..e4b90cd3 100644
--- a/autoware.ai/src/autoware/messages/rubis_msgs/msg/TwistStamped.msg
+++ b/autoware.ai/src/autoware/messages/rubis_msgs/msg/TwistStamped.msg
@@ -1,2 +1,3 @@
 uint64 instance
-geometry_msgs/TwistStamped msg
\ No newline at end of file
+geometry_msgs/TwistStamped msg
+uint64 obj_instance
\ No newline at end of file
diff --git a/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_gpu/_cubetown_autorunner_gpu_1_sensing.launch b/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_gpu/_cubetown_autorunner_gpu_1_sensing.launch
new file mode 100644
index 00000000..59c8f802
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_gpu/_cubetown_autorunner_gpu_1_sensing.launch
@@ -0,0 +1,43 @@
+<launch>
+  <rosparam command="load" file="$(env USER_HOME)/rubis_ws/src/rubis_autorunner/cfg/cubetown_autorunner/cubetown_autorunner_params.yaml" />
+
+  <arg name="lidar_input_topic" default="/points_raw_origin"/>
+  <arg name="lidar_output_topic" default="/points_raw"/>
+
+  <!-- Map TF Publisher -->	
+	<include file="$(env USER_HOME)/autoware.ai/autoware_files/data/tf/tf.launch" />
+  
+  <!-- Vector Map Loader -->
+	<node pkg="map_file" type="vector_map_loader" name="vector_map_loader" args="
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/cubetown_circle/dtlane.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/cubetown_circle/idx.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/cubetown_circle/lane.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/cubetown_circle/node.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/cubetown_circle/point.csv"/>
+
+  <!-- Point Map Loader -->
+	<include file="$(find map_file)/launch/points_map_loader.launch">
+    <arg name="scene_num" value="noupdate" />
+    <arg name="path_pcd" value="$(env USER_HOME)/autoware.ai/autoware_files/points_map/CubeTown.pcd"/>
+  </include>
+
+  <!-- Re-publishing simulator/camera_node/image/compressed topic to /image_raw as expected by Autoware -->
+  <node name="republish" type="republish" pkg="image_transport" output="screen" args="compressed in:=/simulator/camera_node/image raw out:=/image_raw"  />
+
+  <node pkg="rubis_pkg" type="lidar_republisher" name="lidar_republisher" output="screen">
+    <param name="/input_topic" value="$(arg lidar_input_topic)" />
+    <param name="/output_topic" value="$(arg lidar_output_topic)" />
+  </node>
+
+  <node pkg="tf" type="static_transform_publisher" name="base_link_to_velodyne" args="1.0510799 0 1.96 0 0 0 base_link velodyne 10"/>
+  <!-- <node pkg="tf" type="static_transform_publisher" name="gps_to_base_link" args="0 0 0 0 0 0 gps base_link 10"/> -->
+  <node pkg="tf" type="static_transform_publisher" name="lidar_to_camera" args="0.029 -0.574 -1.820 4.712 0.009 -1.883 velodyne camera 10" />
+
+  <!-- gnss localizer -->
+  <!-- <arg name="plane" default="0"/>
+  <node pkg="rubis_pkg" type="gnss_localizer" name="gnss_localizer" output="screen">
+    <param name="plane" value="$(arg plane)"/>
+  </node> -->
+
+</launch>
+
diff --git a/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_gpu/_cubetown_autorunner_gpu_2_localization.launch b/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_gpu/_cubetown_autorunner_gpu_2_localization.launch
new file mode 100644
index 00000000..a14b621b
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_gpu/_cubetown_autorunner_gpu_2_localization.launch
@@ -0,0 +1,48 @@
+<launch>
+  <!-- cubetown -->
+  <arg name="init_x" value="57.1" />
+  <arg name="init_y" value="1.38" />
+  <arg name="init_z" value="0.48" />
+  <arg name="init_roll" value="0.0" />
+  <arg name="init_pitch" value="0.0" />
+  <arg name="init_yaw" value="1.57" />
+
+  <!-- vel/pose connect -->
+  <arg name="topic_pose_stamped" default="/ndt_pose" />
+  <arg name="topic_twist_stamped" default="/estimate_twist" />
+
+  <!-- points downsampler -->
+  <include file="$(find points_downsampler)/launch/points_downsample.launch" />
+
+  <!-- ndt_matching --><!-- pcl_generic=0, pcl_anh=1, pcl_anh_gpu=2, pcl_openmp=3 -->
+  <include file="$(find lidar_localizer)/launch/ndt_matching.launch">
+    <arg name="method_type" value="0" /> 
+    <arg name="get_height" value="true" /> 
+  </include>
+
+  <!-- ndt config -->
+  <node pkg="rostopic" type="rostopic" name="config_ndt"
+  args="pub /config/ndt autoware_config_msgs/ConfigNDT
+  '{header: {seq: 8, stamp: {secs: 0, nsecs: 0}, frame_id: ''},
+    init_pos_gnss: 0,
+    x: $(arg init_x),
+    y: $(arg init_y),
+    z: $(arg init_z),
+    roll: $(arg init_roll), 
+    pitch: $(arg init_pitch),
+    yaw: $(arg init_yaw),
+    use_predict_pose: 1,
+    error_threshold: 0.01,
+    resolution: 3.0,
+    step_size: 0.5,
+    trans_epsilon: 0.01,
+    max_iterations: 1}
+  '"/>
+
+  <!-- vel_pose_mux -->
+  <include file="$(find autoware_connector)/launch/vel_pose_connect.launch">
+    <arg name="topic_pose_stamped" value="$(arg topic_pose_stamped)" />
+    <arg name="topic_twist_stamped" value="$(arg topic_twist_stamped)" />
+  </include>
+
+</launch>
diff --git a/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_gpu/_cubetown_autorunner_gpu_3_detection.launch b/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_gpu/_cubetown_autorunner_gpu_3_detection.launch
new file mode 100644
index 00000000..cd906d09
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_gpu/_cubetown_autorunner_gpu_3_detection.launch
@@ -0,0 +1,86 @@
+<launch>
+  <!-- Ground Filter -->
+  <!-- <include file="$(find points_preprocessor)/launch/compare_map_filter_params.launch">
+     <arg name="input_point_topic" value="/points_raw" />
+    <arg name="input_map_topic" value="/points_map" />
+    <arg name="output_match_topic" value="/points_ground_center" />
+    <arg name="output_unmatch_topic" value="/points_no_ground_center" />
+  </include> -->
+
+  <include file="$(find points_preprocessor)/launch/ray_ground_filter.launch">
+    <arg name="input_point_topic" value="/points_raw" />  <!-- input_point_topic, ground filtering will be performed over the pointcloud in this topic. -->
+    <arg name="base_frame" value="base_link" />  <!-- Coordinate system to perform transform (default base_link) -->
+    <arg name="max_clipping_height" value="1.5" />  <!-- Remove Points above this height value (default 2.0 meters) -->
+    <arg name="min_clipping_height" value="0.0" />  <!-- Remove Points below this height value (default -0.5 meters) -->
+    <arg name="min_point_distance" value="2.9" />  <!-- Removes Points closer than this distance from the sensor origin (default 1.85 meters) -->
+    <arg name="radial_divider_angle" value="0.08" />  <!-- Angle of each Radial division on the XY Plane (default 0.08 degrees)-->
+    <arg name="concentric_divider_distance" value="0.0" />  <!-- Distance of each concentric division on the XY Plane (default 0.0 meters) -->
+    <arg name="local_max_slope" value="3" />  <!-- Max Slope of the ground between Points (default 8 degrees) -->
+    <arg name="general_max_slope" value="9" />  <!-- Max Slope of the ground in the entire PointCloud, used when reclassification occurs (default 5 degrees)-->
+    <arg name="min_height_threshold" value="0.4" />  <!-- Minimum height threshold between points (default 0.05 meters)-->
+    <arg name="reclass_distance_threshold" value="0.01" />  <!-- Distance between points at which re classification will occur (default 0.2 meters)-->
+    <arg name="no_ground_point_topic" value="/points_no_ground" />
+    <arg name="ground_point_topic" value="/points_ground" />
+  </include>
+  
+  <!-- lidar_euclidean_cluster_detect-->
+  <include file="$(find lidar_euclidean_cluster_detect)/launch/lidar_euclidean_cluster_detect.launch">
+    <arg name="points_node" value="/points_no_ground_center" />
+    <arg name="remove_ground" value="true" />
+    <arg name="downsample_cloud" value="false" />
+    <arg name="leaf_size" value="0.68" />
+    <arg name="cluster_size_min" value="1" />
+    <arg name="cluster_size_max" value="100000" />
+    <arg name="sync" value="false" />
+    <arg name="use_diffnormals" value="false" />
+    <arg name="pose_estimation" value="false" />
+    <arg name="clip_min_height" value="-10.0" />
+    <arg name="clip_max_height" value="10" />
+    <arg name="keep_lanes" value="false" />
+    <arg name="keep_lane_left_distance" value="5" />
+    <arg name="keep_lane_right_distance" value="5" />
+    <arg name="cluster_merge_threshold" value="1.5" />
+    <arg name="clustering_distance" value="0.75" />
+    <arg name="use_vector_map" value="false" />
+    <arg name="wayarea_gridmap_layer" value="wayarea" />
+    <arg name="output_frame" value="velodyne" />
+    <arg name="remove_points_upto" value="0.0" />
+    <arg name="use_gpu" value="true" />    
+    <arg name="use_multiple_thres" value="false"/>
+    <arg name="clustering_ranges" value="[15,30,45,60]"/>
+    <arg name="clustering_distances"
+         value="[0.5,1.1,1.6,2.1,2.6]"/>    
+  </include>
+  
+  <!-- vision_darknet_detect -->
+  <include file="$(find vision_darknet_detect)/launch/vision_darknet_detect_parameter.launch">
+    <arg name="gpu_device_id" value="0"/>
+    <arg name="score_threshold" value="0.5"/>
+    <arg name="nms_threshold" value="0.45"/>
+    <arg name="names_file" value="$(find vision_darknet_detect)/darknet/cfg/coco.names"/>
+    <arg name="camera_id" value="/"/>
+    <arg name="image_src" value="/image_raw"/>    
+  </include>
+
+  <!-- imm_ukf_pda_track -->
+  <include file="$(find imm_ukf_pda_track)/launch/imm_ukf_pda_track.launch">
+    <arg name="namespace" default="/detection/object_tracker"/>
+    <arg name="tracker_input_topic" default="/detection/lidar_detector/objects_center" />
+    <arg name="tracker_output_topic" default="/detection/object_tracker/objects_center" />
+    <arg name="tracking_frame" default="/world" />
+    <arg name="gating_threshold" default="9.22" />
+    <arg name="gate_probability" default="0.99" />
+    <arg name="detection_probability" default="0.9" />
+    <arg name="life_time_threshold" default="8" />
+    <arg name="static_velocity_threshold" default="0.5" />
+    <arg name="static_num_history_threshold" default="3" />
+    <arg name="prevent_explosion_threshold" default="1000" />
+    <arg name="merge_distance_threshold" default="0.5"/>
+    <arg name="use_sukf" default="false" />
+    <arg name="use_map_info" default="false" />
+    <arg name="lane_direction_chi_threshold" default="2.71" />
+    <arg name="nearest_lane_distance_threshold" default="1.0" />
+    <arg name="vectormap_frame" default="/map" />
+  </include>
+
+</launch>
\ No newline at end of file
diff --git a/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_gpu/_cubetown_autorunner_gpu_4_planning.launch b/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_gpu/_cubetown_autorunner_gpu_4_planning.launch
new file mode 100644
index 00000000..cf4d32cc
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_gpu/_cubetown_autorunner_gpu_4_planning.launch
@@ -0,0 +1,105 @@
+<launch>
+  <!-- op_global_planning -->
+  <include file="$(find op_global_planner)/launch/op_global_planner.launch">
+    <arg name="pathDensity"           value="1" /> <!-- distance between each two waypoints-->
+    <arg name="enableSmoothing"       value="false" /> <!-- 1 or 0 -->
+    <arg name="enableLaneChange"      value="false" /> <!-- 1 or 0 -->
+    <arg name="enableRvizInput"       value="true" /> <!-- 1 or 0 -->
+    <arg name="enableReplan"          value="false" /> <!-- 1 or 0 -->  
+    <arg name="velocitySource"        value="1" /> <!-- read velocities from (0- Odometry, 1- autoware current_velocities, 2- car_info) "" -->
+    <arg name="mapSource"             value="0" /> <!-- Autoware=0, Vector Map Folder=1, kml file=2 -->
+    <arg name="mapFileName"           value="" /> <!-- incase of kml map source -->
+    <!-- Borregas Avenue -->
+    <arg name="use_static_goal"       value="true" />
+    <arg name="goal_pose_x"           value="57.0422019958" />
+    <arg name="goal_pose_y"           value="-5.43001270294" />
+    <arg name="goal_pose_z"           value="0.0" />
+    <arg name="goal_ori_x"            value="0.0" />
+    <arg name="goal_ori_y"            value="0.0" />
+    <arg name="goal_ori_z"            value="0.719615198264" />
+    <arg name="goal_ori_w"            value="0.694373074383" />
+  </include>
+
+  <!-- op_common_params  -->
+  <include file="$(find op_local_planner)/launch/op_common_params_parameter.launch">
+    <!-- Included in app window -->
+    <arg name="horizonDistance"                 default="120"  />     <!-- Horizon -->
+    <arg name="maxLocalPlanDistance"            default="80" />       <!-- Plan Distance-->
+    <arg name="pathDensity"                     default="0.5" />      <!-- Path Density-->
+    <arg name="enableFollowing"                 default="true" />     <!-- Enable Following -->
+    <arg name="enableSwerving"                  default="true"  />    <!-- Enable Avoidance -->
+    <arg name="minFollowingDistance"            default="30.0"  />    <!-- Follow Distance --> <!-- should be bigger than Distance to follow -->  
+    <arg name="minDistanceToAvoid"              default="20.0" />     <!-- Avoiding Distance --> <!-- should be smaller than minFollowingDistance and larger than maxDistanceToAvoid -->
+    <arg name="maxDistanceToAvoid"              default="0.1"  />     <!-- Avoidnace Limit--> <!-- should be smaller than minDistanceToAvoid -->
+    <arg name="enableStopSignBehavior"          default="false" />    <!-- Enable Stop Sign Stop-->
+    <arg name="enableTrafficLightBehavior"      default="true" />     <!-- Enable Traffic Light -->
+    <arg name="enableLaneChange"                default="false" />    <!-- Enable Lane Change -->
+    <arg name="horizontalSafetyDistance"        default="1"  />       <!-- Lateral Safety --> 
+    <arg name="verticalSafetyDistance"          default="2"  />       <!-- Longitudinal Safet y-->
+    <arg name="velocitySource"                  default="1" />        <!-- read velocities from (0- Odometry, 1- autoware current_velocities, 2- car_info) "" -->   
+    <!-- Vehicle Specification -->
+    <arg name="width"                           default="1.85"  />
+    <arg name="length"                          default="4.2"  />
+    <arg name="wheelBaseLength"                 default="2.7"  />
+    <arg name="turningRadius"                   default="5.2"  />
+    <arg name="maxSteerAngle"                   default="0.45" />
+    <arg name="steeringDelay"                   default="1.2" />
+    <!-- Not included in app window -->
+    <arg name="minPursuiteDistance"             default="3.0"  />
+    <arg name="additionalBrakingDistance"       default="5.0"  />
+    <arg name="giveUpDistance"                  default="-4.0"  />
+    <arg name="mapSource"                       default="0" />        <!-- Autoware=0, Vector Map Folder=1, kml=2 -->
+    <arg name="mapFileName"                     default="" />
+    <arg name="minVelocity"                     default="0.1" />  
+    <arg name="speedProfileFactor"              default="1.2"  />
+    <arg name="smoothingDataWeight"             default="0.45"  />
+    <arg name="smoothingSmoothWeight"           default="0.4"  />  
+  </include>
+
+  <!-- op_trajectory_generator -->
+  <include file="$(find op_local_planner)/launch/op_trajectory_generator.launch">
+    <arg name="samplingTipMargin"               default="4"  />       <!-- Tip Margin -->
+    <arg name="samplingOutMargin"               default="8" />        <!-- Roll In Margin -->
+    <arg name="samplingSpeedFactor"             default="0.25" />    
+    <arg name="enableHeadingSmoothing"          default="false" />
+  </include>
+
+  <!-- op_motion_predictor -->
+  <include file="$(find op_local_planner)/launch/op_motion_predictor.launch">
+    <!-- <arg name="input_object_list"               default="[/detection/fusion_tools/objects_center]" /> -->
+    <arg name="input_object_list"               default="[/detection/image_detector/objects,/detection/object_tracker/objects_center]" />
+    <arg name="object_tf_list"                  default="[camera,velodyne]" />
+    <arg name="enableCurbObstacles"             default="false" />    <!-- Detect curbs from map-->
+    <arg name="enableGenrateBranches"           default="false"/>     <!-- Enable Branching -->
+    <arg name="max_distance_to_lane"            default="2.0"/>       <!-- Distance to closest lane-->
+    <arg name="prediction_distance"             default="25.0"/>      <!-- Prediction distance-->
+    <arg name="enableStepByStepSignal"          default="false" />    <!-- Enable Step by Step Test-->
+    <arg name="enableParticleFilterPrediction"  default="false" />    <!-- Enable Particle Filter prediction -->
+    <!-- Not included in app window -->   
+    <arg name="distanceBetweenCurbs"            default="1.5" />
+    <arg name="visualizationTime"               default="0.25" />
+  </include>
+
+  <!-- op_trajectory_evaluator -->
+  <include file="$(find op_local_planner)/launch/op_trajectory_evaluator_parameter.launch">
+    <arg name="enablePrediction"                default="false" />                
+    <arg name="horizontalSafetyDistance"        default="1.2" />
+    <arg name="verticalSafetyDistance"          default="0.8" />
+    <arg name="LateralSkipDistance"             default="5.0" />
+    
+    <arg name="PedestrianRightThreshold" default="4.0" />
+    <arg name="PedestrianLeftThreshold" default="4.0" />
+    <arg name="PedestrianImageDetectionRange" default="0.75" /> <!-- (Ratio If pedestrian's center point is located in this range, our car will be stopped -->               
+    <arg name="VehicleImageDetectionRange" default="0.3" /> <!-- (Ratio) If vehicle's center point is not located in this range, our car set speed as max velocity --> 
+    <arg name="VehicleImageWidthThreshold" default="0.018" /> <!-- (Ratio) If vehilce's width ratio is lower than this, it will be not detected -->
+
+    <arg name="intersectionFile"                default="crossing_test/crossing_intersection.yaml" />
+  </include>
+
+  <!-- op_behavior_selector -->
+  <include file="$(find op_local_planner)/launch/op_behavior_selector_parameter.launch">
+    <arg name="evidence_tust_number"            default="25"/>
+    <arg name="trafficLightFile"                default="crossing_test/crossing_traffic_light.yaml" />
+    <arg name="stopLineFile"                    default="crossing_test/crossing_stop_line.yaml" />
+  </include>
+</launch>
\ No newline at end of file
diff --git a/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_gpu/_cubetown_autorunner_gpu_5_control.launch b/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_gpu/_cubetown_autorunner_gpu_5_control.launch
new file mode 100644
index 00000000..1fa79612
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_gpu/_cubetown_autorunner_gpu_5_control.launch
@@ -0,0 +1,32 @@
+<launch>
+  <!--  Dynamic Pure Pursuit Param -->
+  <rosparam command="load" file="$(env USER_HOME)/autoware.ai/autoware_files/lgsvl_file/parameter/lgsvl_pure_pursuit.yaml" />
+  
+  <!-- pure_pursuit  -->
+  <include file="$(find pure_pursuit)/launch/pure_pursuit.launch">    
+    <!-- Core Parameter -->
+    <arg name="lookahead_ratio"               value="1.5"/>
+    <arg name="minimum_lookahead_distance"    value="12.0"/>
+    
+    <arg name="const_velocity"                value="5.0"/>     
+    <arg name="const_lookahead_distance"      value="4.0"/>
+    <arg name="is_linear_interpolation"       value="True"/>
+    <arg name="publishes_for_steering_robot"  value="True"/>
+    <arg name="add_virtual_end_waypoints"     value="False"/>
+  </include>
+
+  <!-- twist_filter -->
+  <include file="$(find twist_filter)/launch/twist_filter.launch">    
+    <!-- For twist_filter -->
+    <arg name="wheel_base" default="2.7" />
+    <arg name="lateral_accel_limit" default="5.0" />
+    <arg name="lateral_jerk_limit" default="5.0" />
+    <arg name="lowpass_gain_linear_x" default="0.0" />
+    <arg name="lowpass_gain_angular_z" default="0.0" />
+    <arg name="lowpass_gain_steering_angle" default="0.0" />
+    <arg name="max_stop_count" default="40" /> <!-- 10 = 1 second -->  
+    <!-- For twist_gate -->
+    <arg name="loop_rate" default="30.0" />
+    <arg name="use_decision_maker" default="false" />
+  </include>
+</launch>
\ No newline at end of file
diff --git a/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_vgicp/_cubetown_autorunner_1_sensing.launch b/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_vgicp/_cubetown_autorunner_1_sensing.launch
new file mode 100644
index 00000000..ee554f3a
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_vgicp/_cubetown_autorunner_1_sensing.launch
@@ -0,0 +1,44 @@
+<launch>
+  <rosparam command="load" file="$(env USER_HOME)/rubis_ws/src/rubis_autorunner/cfg/cubetown_autorunner/cubetown_autorunner_params.yaml" />
+
+  <arg name="lidar_input_topic" default="/points_raw_origin"/>
+  <arg name="lidar_output_topic" default="/points_raw"/>
+
+  <!-- Map TF Publisher -->	
+	<include file="$(env USER_HOME)/autoware.ai/autoware_files/data/tf/tf.launch" />
+  
+  <!-- Vector Map Loader -->
+	<node pkg="map_file" type="vector_map_loader" name="vector_map_loader" args="
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/cubetown_circle/dtlane.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/cubetown_circle/idx.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/cubetown_circle/lane.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/cubetown_circle/node.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/cubetown_circle/point.csv"/>
+
+  <!-- Point Map Loader -->
+	<include file="$(find map_file)/launch/points_map_loader.launch">
+    <arg name="scene_num" value="noupdate" />
+    <arg name="path_pcd" value="$(env USER_HOME)/autoware.ai/autoware_files/points_map/FMTC_merged.pcd"/>
+  </include>
+
+  <!-- Re-publishing simulator/camera_node/image/compressed topic to /image_raw as expected by Autoware -->
+  <node name="republish" type="republish" pkg="image_transport" output="screen" args="compressed in:=/simulator/camera_node/image raw out:=/image_raw"  />
+
+  <include file="$(find rubis_pkg)/launch/lidar_republisher_params.launch">
+    <arg name="input_topic" value="$(arg lidar_input_topic)" />
+    <arg name="output_topic" value="$(arg lidar_output_topic)" />
+  </include>
+
+  <node pkg="tf" type="static_transform_publisher" name="base_link_to_velodyne" args="3.3 -0.8 0.09 -0.68 0 0 base_link velodyne 10"/>
+  <!-- <node pkg="tf" type="static_transform_publisher" name="base_link_to_velodyne" args="1.2 0 2.0 0 0 0 base_link velodyne 10"/> -->
+  <node pkg="tf" type="static_transform_publisher" name="gps_to_base_link" args="0 0 0 0 0 0 gnss base_link 10"/>
+  <node pkg="tf" type="static_transform_publisher" name="lidar_to_camera" args="0.029 -0.574 -1.820 4.712 0.009 -1.883 velodyne camera 10" />
+
+  <!-- gnss localizer -->
+  <arg name="plane" default="0"/>
+  <node pkg="rubis_pkg" type="gnss_localizer" name="gnss_localizer" output="screen">
+    <param name="plane" value="$(arg plane)"/>
+  </node>
+
+</launch>
+
diff --git a/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_vgicp/_cubetown_autorunner_2_localization.launch b/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_vgicp/_cubetown_autorunner_2_localization.launch
new file mode 100644
index 00000000..59475396
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_vgicp/_cubetown_autorunner_2_localization.launch
@@ -0,0 +1,51 @@
+<launch>
+  <!-- cubetown -->
+  <arg name="init_x" value="162.6" />
+  <arg name="init_y" value="157.6" />
+  <arg name="init_z" value="0.48" />
+  <arg name="init_roll" value="0.0" />
+  <arg name="init_pitch" value="0.0" />
+  <arg name="init_yaw" value="0.0" />
+
+  <!-- vel/pose connect -->
+  <arg name="topic_pose_stamped" default="/gicp_pose" />
+  <arg name="topic_twist_stamped" default="/gicp_vel" /> 
+  <!-- <arg name="topic_twist_stamped" default="/odom_twist" /> -->
+
+  <!-- points downsampler -->
+  <include file="$(find points_downsampler)/launch/voxel_grid_filter_params.launch" />
+
+  <arg name="enable_gnss_backup" default="false" /> 
+
+  <arg name="base_frame" default="base_link" doc="Vehicle reference frame" />
+  <arg name="resolution" default="2.0" doc="The ND voxel grid resolution" />
+  <arg name="neighborSearchMethod" default="DIRECT7"/>
+
+  <arg name="numthreads" default="4" doc="vgicp threads num" />
+  <arg name="leafsize" default="0.1" doc="point map downsample leafsize" />
+
+  <node pkg="gicp_localizer" type="gicp_localizer_node" name="gicp_localizer_node" output="screen">
+    <param name="init_x" value="$(arg init_x)" />
+    <param name="init_y" value="$(arg init_y)" />
+    <param name="init_z" value="$(arg init_z)" />
+    <param name="init_roll" value="$(arg init_roll)" />
+    <param name="init_pitch" value="$(arg init_pitch)" />
+    <param name="init_yaw" value="$(arg init_yaw)" />
+
+    <param name="enable_gnss_backup" value="$(arg enable_gnss_backup)" />
+    <param name="gnss_backup_threshold" value="7.0" />
+
+    <param name="base_frame" value="$(arg base_frame)" />
+    <param name="resolution" value="$(arg resolution)" />
+    <param name="neighborSearchMethod" value="$(arg neighborSearchMethod)" />
+    <param name="numthreads" value="$(arg numthreads)" />
+    <param name="leafsize" value="$(arg leafsize)" />
+  </node>
+
+  <!-- vel_pose_mux -->
+  <include file="$(find rubis_pkg)/launch/vel_pose_connect_params.launch">
+    <arg name="topic_pose_stamped" value="$(arg topic_pose_stamped)" />
+    <arg name="topic_twist_stamped" value="$(arg topic_twist_stamped)" />
+  </include>
+
+</launch>
diff --git a/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_vgicp/_cubetown_autorunner_3_detection.launch b/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_vgicp/_cubetown_autorunner_3_detection.launch
new file mode 100644
index 00000000..66594cf2
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_vgicp/_cubetown_autorunner_3_detection.launch
@@ -0,0 +1,86 @@
+<launch>
+  <!-- Ground Filter -->
+  <!-- <include file="$(find points_preprocessor)/launch/compare_map_filter_params.launch">
+     <arg name="input_point_topic" value="/points_raw" />
+    <arg name="input_map_topic" value="/points_map" />
+    <arg name="output_match_topic" value="/points_ground_center" />
+    <arg name="output_unmatch_topic" value="/points_no_ground_center" />
+  </include> -->
+
+  <include file="$(find points_preprocessor)/launch/ray_ground_filter_params.launch">
+    <arg name="input_point_topic" value="/points_raw" />  <!-- input_point_topic, ground filtering will be performed over the pointcloud in this topic. -->
+    <arg name="base_frame" value="base_link" />  <!-- Coordinate system to perform transform (default base_link) -->
+    <arg name="max_clipping_height" value="5" />  <!-- Remove Points above this height value (default 2.0 meters) -->
+    <arg name="min_clipping_height" value="-0.5" />  <!-- Remove Points below this height value (default -0.5 meters) -->
+    <arg name="min_point_distance" value="3.5" />  <!-- Removes Points closer than this distance from the sensor origin (default 1.85 meters) -->
+    <arg name="radial_divider_angle" value="0.08" />  <!-- Angle of each Radial division on the XY Plane (default 0.08 degrees)-->
+    <arg name="concentric_divider_distance" value="0.0" />  <!-- Distance of each concentric division on the XY Plane (default 0.0 meters) -->
+    <arg name="local_max_slope" value="8" />  <!-- Max Slope of the ground between Points (default 8 degrees) -->
+    <arg name="general_max_slope" value="1" />  <!-- Max Slope of the ground in the entire PointCloud, used when reclassification occurs (default 5 degrees)-->
+    <arg name="min_height_threshold" value="0.05" />  <!-- Minimum height threshold between points (default 0.05 meters)-->
+    <arg name="reclass_distance_threshold" value="0.02" />  <!-- Distance between points at which re classification will occur (default 0.2 meters)-->
+    <arg name="no_ground_point_topic" value="/points_no_ground" />
+    <arg name="ground_point_topic" value="/points_ground" />
+  </include>
+  
+  <!-- lidar_euclidean_cluster_detect-->
+  <include file="$(find lidar_euclidean_cluster_detect)/launch/lidar_euclidean_cluster_detect.launch">
+    <arg name="points_node" value="/points_no_ground_center" />
+    <arg name="remove_ground" value="true" />
+    <arg name="downsample_cloud" value="false" />
+    <arg name="leaf_size" value="0.68" />
+    <arg name="cluster_size_min" value="1" />
+    <arg name="cluster_size_max" value="100000" />
+    <arg name="sync" value="false" />
+    <arg name="use_diffnormals" value="false" />
+    <arg name="pose_estimation" value="false" />
+    <arg name="clip_min_height" value="-10.0" />
+    <arg name="clip_max_height" value="10" />
+    <arg name="keep_lanes" value="false" />
+    <arg name="keep_lane_left_distance" value="5" />
+    <arg name="keep_lane_right_distance" value="5" />
+    <arg name="cluster_merge_threshold" value="1.5" />
+    <arg name="clustering_distance" value="0.75" />
+    <arg name="use_vector_map" value="false" />
+    <arg name="wayarea_gridmap_layer" value="wayarea" />
+    <arg name="output_frame" value="velodyne" />
+    <arg name="remove_points_upto" value="0.0" />
+    <arg name="use_gpu" value="true" />    
+    <arg name="use_multiple_thres" value="false"/>
+    <arg name="clustering_ranges" value="[15,30,45,60]"/>
+    <arg name="clustering_distances"
+         value="[0.5,1.1,1.6,2.1,2.6]"/>    
+  </include>
+  
+  <!-- vision_darknet_detect -->
+  <include file="$(find vision_darknet_detect)/launch/vision_darknet_detect_parameter.launch">
+    <arg name="gpu_device_id" value="0"/>
+    <arg name="score_threshold" value="0.5"/>
+    <arg name="nms_threshold" value="0.45"/>
+    <arg name="names_file" value="$(find vision_darknet_detect)/darknet/cfg/coco.names"/>
+    <arg name="camera_id" value="/"/>
+    <arg name="image_src" value="/image_raw"/>    
+  </include>
+
+  <!-- imm_ukf_pda_track -->
+  <include file="$(find imm_ukf_pda_track)/launch/imm_ukf_pda_track.launch">
+    <arg name="namespace" default="/detection/object_tracker"/>
+    <arg name="tracker_input_topic" default="/detection/lidar_detector/objects_center" />
+    <arg name="tracker_output_topic" default="/detection/object_tracker/objects_center" />
+    <arg name="tracking_frame" default="/world" />
+    <arg name="gating_threshold" default="9.22" />
+    <arg name="gate_probability" default="0.99" />
+    <arg name="detection_probability" default="0.9" />
+    <arg name="life_time_threshold" default="8" />
+    <arg name="static_velocity_threshold" default="0.5" />
+    <arg name="static_num_history_threshold" default="3" />
+    <arg name="prevent_explosion_threshold" default="1000" />
+    <arg name="merge_distance_threshold" default="0.5"/>
+    <arg name="use_sukf" default="false" />
+    <arg name="use_map_info" default="false" />
+    <arg name="lane_direction_chi_threshold" default="2.71" />
+    <arg name="nearest_lane_distance_threshold" default="1.0" />
+    <arg name="vectormap_frame" default="/map" />
+  </include>
+
+</launch>
\ No newline at end of file
diff --git a/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_vgicp/_cubetown_autorunner_4_planning.launch b/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_vgicp/_cubetown_autorunner_4_planning.launch
new file mode 100644
index 00000000..f25e94df
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_vgicp/_cubetown_autorunner_4_planning.launch
@@ -0,0 +1,120 @@
+<launch>
+  <!-- op_global_planning -->
+  <arg name="LaneInfoFile"          default="cubetown_autorunner/default_lane_info.yaml" />
+  <arg name="pathDensity"           value="1" /> <!-- distance between each two waypoints-->
+  <arg name="enableSmoothing"       value="false" /> <!-- 1 or 0 -->
+  <arg name="enableLaneChange"      value="false" /> <!-- 1 or 0 -->
+  <arg name="enableRvizInput"       value="true" /> <!-- 1 or 0 -->
+  <arg name="enableReplan"          value="false" /> <!-- 1 or 0 -->  
+  <arg name="velocitySource"        value="1" /> <!-- read velocities from (0- Odometry, 1- autoware current_velocities, 2- car_info) "" -->
+  <arg name="mapSource"             value="0" /> <!-- Autoware=0, Vector Map Folder=1, kml file=2 -->
+  <arg name="mapFileName"           value="" /> <!-- incase of kml map source -->
+  <arg name="enableDynamicMapUpdate"       default="false" />  
+  <!-- Borregas Avenue -->
+  <arg name="use_static_goal"       value="true" />
+  <arg name="goal_pose_x"           value="57.0422019958" />
+  <arg name="goal_pose_y"           value="-5.43001270294" />
+  <arg name="goal_pose_z"           value="0.0" />
+  <arg name="goal_ori_x"            value="0.0" />
+  <arg name="goal_ori_y"            value="0.0" />
+  <arg name="goal_ori_z"            value="0.719615198264" />
+  <arg name="goal_ori_w"            value="0.694373074383" />
+
+  <node pkg="op_global_planner" type="op_global_planner" name="op_global_planner" output="screen">    
+    <rosparam command="load" file="$(find rubis_autorunner)/cfg/$(arg LaneInfoFile)"/>
+    <param name="pathDensity"         value="$(arg pathDensity)" />
+    <param name="enableSmoothing"       value="$(arg enableSmoothing)" />
+    <param name="enableLaneChange"       value="$(arg enableLaneChange)" />
+    <param name="enableRvizInput"       value="$(arg enableRvizInput)" />
+    <param name="enableReplan"         value="$(arg enableReplan)" />        
+    <param name="velocitySource"       value="$(arg velocitySource)" />
+    <param name="mapSource"         value="$(arg mapSource)" />
+    <param name="mapFileName"         value="$(arg mapFileName)" />    
+    <param name="enableDynamicMapUpdate"   value="$(arg enableDynamicMapUpdate)" />    
+    <param name="use_static_goal"       value="$(arg use_static_goal)"/>
+    <param name="goal_pose_x"           value="$(arg goal_pose_x)" />
+    <param name="goal_pose_y"           value="$(arg goal_pose_y)" />
+    <param name="goal_pose_z"           value="$(arg goal_pose_z)" />
+    <param name="goal_ori_x"            value="$(arg goal_ori_x)" />
+    <param name="goal_ori_y"            value="$(arg goal_ori_y)" />
+    <param name="goal_ori_z"            value="$(arg goal_ori_z)" />
+    <param name="goal_ori_w"            value="$(arg goal_ori_w)" />      
+  </node> 
+
+  <!-- op_common_params  -->
+  <include file="$(find op_local_planner)/launch/op_common_params_parameter.launch">
+    <!-- Included in app window -->
+    <arg name="horizonDistance"                 default="120"  />     <!-- Horizon -->
+    <arg name="maxLocalPlanDistance"            default="80" />       <!-- Plan Distance-->
+    <arg name="pathDensity"                     default="0.5" />      <!-- Path Density-->
+    <arg name="enableFollowing"                 default="true" />     <!-- Enable Following -->
+    <arg name="enableSwerving"                  default="true"  />    <!-- Enable Avoidance -->
+    <arg name="minFollowingDistance"            default="30.0"  />    <!-- Follow Distance --> <!-- should be bigger than Distance to follow -->  
+    <arg name="minDistanceToAvoid"              default="20.0" />     <!-- Avoiding Distance --> <!-- should be smaller than minFollowingDistance and larger than maxDistanceToAvoid -->
+    <arg name="maxDistanceToAvoid"              default="0.1"  />     <!-- Avoidnace Limit--> <!-- should be smaller than minDistanceToAvoid -->
+    <arg name="enableStopSignBehavior"          default="false" />    <!-- Enable Stop Sign Stop-->
+    <arg name="enableTrafficLightBehavior"      default="true" />     <!-- Enable Traffic Light -->
+    <arg name="enableLaneChange"                default="false" />    <!-- Enable Lane Change -->
+    <arg name="horizontalSafetyDistance"        default="1"  />       <!-- Lateral Safety --> 
+    <arg name="verticalSafetyDistance"          default="2"  />       <!-- Longitudinal Safet y-->
+    <arg name="velocitySource"                  default="1" />        <!-- read velocities from (0- Odometry, 1- autoware current_velocities, 2- car_info) "" -->   
+    <!-- Vehicle Specification -->
+    <arg name="width"                           default="1.85"  />
+    <arg name="length"                          default="4.2"  />
+    <arg name="wheelBaseLength"                 default="2.7"  />
+    <arg name="turningRadius"                   default="5.2"  />
+    <arg name="maxSteerAngle"                   default="0.45" />
+    <arg name="steeringDelay"                   default="1.2" />
+    <!-- Not included in app window -->
+    <arg name="minPursuiteDistance"             default="3.0"  />
+    <arg name="additionalBrakingDistance"       default="5.0"  />
+    <arg name="giveUpDistance"                  default="-4.0"  />
+    <arg name="mapSource"                       default="0" />        <!-- Autoware=0, Vector Map Folder=1, kml=2 -->
+    <arg name="mapFileName"                     default="" />
+    <arg name="minVelocity"                     default="0.1" />  
+    <arg name="speedProfileFactor"              default="1.2"  />
+    <arg name="smoothingDataWeight"             default="0.45"  />
+    <arg name="smoothingSmoothWeight"           default="0.4"  />  
+  </include>
+
+  <!-- op_trajectory_generator -->
+  <include file="$(find op_local_planner)/launch/op_trajectory_generator.launch">
+    <arg name="samplingTipMargin"               default="4"  />       <!-- Tip Margin -->
+    <arg name="samplingOutMargin"               default="8" />        <!-- Roll In Margin -->
+    <arg name="samplingSpeedFactor"             default="0.25" />    
+    <arg name="enableHeadingSmoothing"          default="false" />
+  </include>
+
+  <!-- op_motion_predictor -->
+  <include file="$(find op_local_planner)/launch/op_motion_predictor.launch">
+    <!-- <arg name="input_object_list"               default="[/detection/fusion_tools/objects_center]" /> -->
+    <arg name="input_object_list"               default="[/detection/image_detector/objects,/detection/object_tracker/objects_center]" />
+    <arg name="object_tf_list"                  default="[camera,velodyne]" />
+    <arg name="enableCurbObstacles"             default="false" />    <!-- Detect curbs from map-->
+    <arg name="enableGenrateBranches"           default="false"/>     <!-- Enable Branching -->
+    <arg name="max_distance_to_lane"            default="2.0"/>       <!-- Distance to closest lane-->
+    <arg name="prediction_distance"             default="25.0"/>      <!-- Prediction distance-->
+    <arg name="enableStepByStepSignal"          default="false" />    <!-- Enable Step by Step Test-->
+    <arg name="enableParticleFilterPrediction"  default="false" />    <!-- Enable Particle Filter prediction -->
+    <!-- Not included in app window -->   
+    <arg name="distanceBetweenCurbs"            default="1.5" />
+    <arg name="visualizationTime"               default="0.25" />
+  </include>
+
+  <!-- op_trajectory_evaluator -->
+  <include file="$(find op_local_planner)/launch/op_trajectory_evaluator_parameter.launch">
+    <arg name="enablePrediction"                default="false" />                
+    <arg name="horizontalSafetyDistance"        default="1.2" />
+    <arg name="verticalSafetyDistance"          default="0.8" />
+    <arg name="LateralSkipDistance"             default="5.0" />
+
+    <arg name="intersectionFile"                default="crossing_test/crossing_intersection.yaml" />
+  </include>
+
+  <!-- op_behavior_selector -->
+  <include file="$(find op_local_planner)/launch/op_behavior_selector_parameter.launch">
+    <arg name="evidence_tust_number"            default="25"/>
+    <arg name="trafficLightFile"                default="crossing_test/crossing_traffic_light.yaml" />
+    <arg name="stopLineFile"                    default="crossing_test/crossing_stop_line.yaml" />
+  </include>
+</launch>
\ No newline at end of file
diff --git a/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_vgicp/_cubetown_autorunner_5_control.launch b/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_vgicp/_cubetown_autorunner_5_control.launch
new file mode 100644
index 00000000..f66cef13
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_vgicp/_cubetown_autorunner_5_control.launch
@@ -0,0 +1,29 @@
+<launch>
+  <!-- pure_pursuit  -->
+  <include file="$(find pure_pursuit)/launch/pure_pursuit_params.launch">   
+    <!-- Core Parameter -->
+    <arg name="lookahead_ratio"               value="1.5"/>
+    <arg name="minimum_lookahead_distance"    value="15.0"/>
+    
+    <arg name="const_velocity"                value="5.0"/>     
+    <arg name="const_lookahead_distance"      value="4.0"/>
+    <arg name="is_linear_interpolation"       value="True"/>
+    <arg name="publishes_for_steering_robot"  value="True"/>
+    <arg name="add_virtual_end_waypoints"     value="False"/>
+  </include>
+
+  <!-- twist_filter -->
+  <include file="$(find twist_filter)/launch/twist_filter_params.launch">    
+    <!-- For twist_filter -->
+    <arg name="wheel_base" default="2.7" />
+    <arg name="lateral_accel_limit" default="5.0" />
+    <arg name="lateral_jerk_limit" default="5.0" />
+    <arg name="lowpass_gain_linear_x" default="0.0" />
+    <arg name="lowpass_gain_angular_z" default="0.0" />
+    <arg name="lowpass_gain_steering_angle" default="0.0" />
+    <arg name="max_stop_count" default="40" /> <!-- 10 = 1 second -->  
+    <!-- For twist_gate -->
+    <arg name="loop_rate" default="30.0" />
+    <arg name="use_decision_maker" default="false" />
+  </include>
+</launch>
\ No newline at end of file
diff --git a/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_vgicp/terminate.sh b/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_vgicp/terminate.sh
new file mode 100644
index 00000000..242e6f2c
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/cubetown_autorunner_vgicp/terminate.sh
@@ -0,0 +1 @@
+rosnode kill /cubetown
\ No newline at end of file
diff --git a/rubis_ws/deprecated/autorunner_scripts/desktop_lane_keeping/desktop_lane_keeping_1_sensing.launch b/rubis_ws/deprecated/autorunner_scripts/desktop_lane_keeping/desktop_lane_keeping_1_sensing.launch
new file mode 100644
index 00000000..b410f94d
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/desktop_lane_keeping/desktop_lane_keeping_1_sensing.launch
@@ -0,0 +1,65 @@
+<launch>
+  <rosparam command="load" file="$(env USER_HOME)/rubis_ws/src/rubis_autorunner/cfg/desktop_lane_keeping/desktop_lene_keeping_params.yaml" />
+
+  <arg name="lidar_input_topic" default="/points_raw_origin"/>
+  <arg name="lidar_output_topic" default="/points_raw"/>
+  <arg name="image_input_topic" default="/image_raw_origin"/>
+
+  <!-- Map TF Publisher -->	
+	<include file="$(env USER_HOME)/autoware.ai/autoware_files/data/tf/tf.launch" />
+  
+  <!-- Vector Map Loader -->
+	<node pkg="map_file" type="vector_map_loader" name="vector_map_loader" args="
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/cubetown_circle/dtlane.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/cubetown_circle/idx.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/cubetown_circle/lane.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/cubetown_circle/node.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/cubetown_circle/point.csv"/>
+
+  <!-- Point Map Loader -->
+	<include file="$(find map_file)/launch/points_map_loader.launch">
+    <arg name="scene_num" value="noupdate" />
+    <arg name="path_pcd" value="$(env USER_HOME)/autoware.ai/autoware_files/points_map/CubeTown.pcd"/>
+  </include>
+
+  <!-- Re-publishing simulator/camera_node/image/compressed topic to /image_raw as expected by Autoware -->
+  <node name="republish" type="republish" pkg="image_transport" output="screen" args="compressed in:=/simulator/camera_node/image raw out:=/image_raw_origin"  />
+
+  <node pkg="rubis_pkg" type="lidar_republisher" name="lidar_republisher" output="screen">
+    <param name="/input_topic" value="$(arg lidar_input_topic)" />
+    <param name="/output_topic" value="$(arg lidar_output_topic)" />
+  </node>
+
+  <node pkg="rubis_pkg" type="camera_republisher" name="camera_republisher" output="screen">
+    <param name="/input_topic" value="$(arg image_input_topic)" />
+  </node>
+
+  <node pkg="tf" type="static_transform_publisher" name="base_link_to_velodyne" args="1.2 0 2.0 0 0 0 base_link velodyne 10"/>
+  <!-- <node pkg="tf" type="static_transform_publisher" name="gps_to_base_link" args="0 0 0 0 0 0 gps base_link 10"/> -->
+  <node pkg="tf" type="static_transform_publisher" name="lidar_to_camera" args="0.029 -0.574 -1.820 4.712 0.009 -1.883 velodyne camera 10" />
+
+  <!-- gnss localizer -->
+  <!-- <arg name="plane" default="0"/>
+  <node pkg="rubis_pkg" type="gnss_localizer" name="gnss_localizer" output="screen">
+    <param name="plane" value="$(arg plane)"/>
+  </node> -->
+
+  <!-- ray_ground_filter -->
+  <include file="$(find points_preprocessor)/launch/ray_ground_filter.launch">
+    <arg name="input_point_topic" value="/points_raw" />  <!-- input_point_topic, ground filtering will be performed over the pointcloud in this topic. -->
+    <arg name="base_frame" value="base_link" />  <!-- Coordinate system to perform transform (default base_link) -->
+    <arg name="max_clipping_height" value="1.5" />  <!-- Remove Points above this height value (default 2.0 meters) -->
+    <arg name="min_clipping_height" value="0.0" />  <!-- Remove Points below this height value (default -0.5 meters) -->
+    <arg name="min_point_distance" value="2.9" />  <!-- Removes Points closer than this distance from the sensor origin (default 1.85 meters) -->
+    <arg name="radial_divider_angle" value="0.08" />  <!-- Angle of each Radial division on the XY Plane (default 0.08 degrees)-->
+    <arg name="concentric_divider_distance" value="0.0" />  <!-- Distance of each concentric division on the XY Plane (default 0.0 meters) -->
+    <arg name="local_max_slope" value="3" />  <!-- Max Slope of the ground between Points (default 8 degrees) -->
+    <arg name="general_max_slope" value="9" />  <!-- Max Slope of the ground in the entire PointCloud, used when reclassification occurs (default 5 degrees)-->
+    <arg name="min_height_threshold" value="0.4" />  <!-- Minimum height threshold between points (default 0.05 meters)-->
+    <arg name="reclass_distance_threshold" value="0.01" />  <!-- Distance between points at which re classification will occur (default 0.2 meters)-->
+    <arg name="no_ground_point_topic" value="/points_no_ground" />
+    <arg name="ground_point_topic" value="/points_ground" />
+  </include>
+
+</launch>
+
diff --git a/rubis_ws/deprecated/autorunner_scripts/desktop_lane_keeping/desktop_lane_keeping_2_localization.launch b/rubis_ws/deprecated/autorunner_scripts/desktop_lane_keeping/desktop_lane_keeping_2_localization.launch
new file mode 100644
index 00000000..ab9971b3
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/desktop_lane_keeping/desktop_lane_keeping_2_localization.launch
@@ -0,0 +1,60 @@
+<launch>
+  <!-- testbed -->
+  <!-- <arg name="init_x" value="-8.72" />
+  <arg name="init_y" value="51.74" />
+  <arg name="init_z" value="-0.71" />
+  <arg name="init_roll" value="0.0" />
+  <arg name="init_pitch" value="0.0" />
+  <arg name="init_yaw" value="-1.8" /> -->
+  <!-- cubetown -->
+  <arg name="init_x" value="57.1" />
+  <arg name="init_y" value="1.38" />
+  <arg name="init_z" value="0.48" />
+  <arg name="init_roll" value="0.0" />
+  <arg name="init_pitch" value="0.0" />
+  <arg name="init_yaw" value="1.57" />
+
+  <!-- vel/pose connect -->
+  <arg name="topic_pose_stamped" default="/ndt_pose" />
+  <arg name="topic_twist_stamped" default="/estimate_twist" />
+
+  <!-- points downsampler -->
+  <include file="$(find points_downsampler)/launch/points_downsample.launch" />
+
+  <!-- nmea2tfpose -->
+  <!-- <include file="$(find gnss_localizer)/launch/nmea2tfpose.launch">
+    <arg name="plane" value="0" />
+  </include> -->
+
+  <!-- ndt_matching --><!-- pcl_generic=0, pcl_anh=1, pcl_anh_gpu=2, pcl_openmp=3 -->
+  <include file="$(find lidar_localizer)/launch/ndt_matching.launch">
+    <arg name="method_type" value="0" /> 
+    <arg name="get_height" value="true" /> 
+  </include>
+
+  <!-- ndt config -->
+  <node pkg="rostopic" type="rostopic" name="config_ndt"
+  args="pub /config/ndt autoware_config_msgs/ConfigNDT
+  '{header: {seq: 8, stamp: {secs: 0, nsecs: 0}, frame_id: ''},
+    init_pos_gnss: 0,
+    x: $(arg init_x),
+    y: $(arg init_y),
+    z: $(arg init_z),
+    roll: $(arg init_roll),
+    pitch: $(arg init_pitch),
+    yaw: $(arg init_yaw),
+    use_predict_pose: 1,
+    error_threshold: 0.01,
+    resolution: 3.0,
+    step_size: 0.5,
+    trans_epsilon: 0.01,
+    max_iterations: 5}
+  '"/>
+
+  <!-- vel_pose_mux -->
+  <include file="$(find autoware_connector)/launch/vel_pose_connect.launch">
+    <arg name="topic_pose_stamped" value="$(arg topic_pose_stamped)" />
+    <arg name="topic_twist_stamped" value="$(arg topic_twist_stamped)" />
+  </include>
+
+</launch>
diff --git a/rubis_ws/deprecated/autorunner_scripts/desktop_lane_keeping/desktop_lane_keeping_3_planning.launch b/rubis_ws/deprecated/autorunner_scripts/desktop_lane_keeping/desktop_lane_keeping_3_planning.launch
new file mode 100644
index 00000000..6f2849ef
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/desktop_lane_keeping/desktop_lane_keeping_3_planning.launch
@@ -0,0 +1,116 @@
+<launch>
+  <!-- op_global_planning -->
+  <include file="$(find op_global_planner)/launch/op_global_planner.launch">
+    <arg name="pathDensity"           value="1" /> <!-- distance between each two waypoints-->
+    <arg name="enableSmoothing"       value="false" /> <!-- 1 or 0 -->
+    <arg name="enableLaneChange"      value="false" /> <!-- 1 or 0 -->
+    <arg name="enableRvizInput"       value="true" /> <!-- 1 or 0 -->
+    <arg name="enableReplan"          value="false" /> <!-- 1 or 0 -->  
+    <arg name="velocitySource"        value="1" /> <!-- read velocities from (0- Odometry, 1- autoware current_velocities, 2- car_info) "" -->
+    <arg name="mapSource"             value="0" /> <!-- Autoware=0, Vector Map Folder=1, kml file=2 -->
+    <arg name="mapFileName"           value="" /> <!-- incase of kml map source -->
+    <!-- Borregas Avenue -->
+    <!-- <arg name="use_static_goal"       value="true" />
+    <arg name="goal_pose_x"           value="57.0422019958" />
+    <arg name="goal_pose_y"           value="-5.43001270294" />
+    <arg name="goal_pose_z"           value="0.0" />
+    <arg name="goal_ori_x"            value="0.0" />
+    <arg name="goal_ori_y"            value="0.0" />
+    <arg name="goal_ori_z"            value="0.719615198264" />
+    <arg name="goal_ori_w"            value="0.694373074383" /> -->
+    <!-- CubeTown -->
+    <arg name="use_static_goal"       value="true" />
+    <arg name="goal_pose_x"           value="55.9" />
+    <arg name="goal_pose_y"           value="-18.8" />
+    <arg name="goal_pose_z"           value="0.0" />
+    <arg name="goal_ori_x"            value="0.0" />
+    <arg name="goal_ori_y"            value="0.0" />
+    <arg name="goal_ori_z"            value="0.70" />
+    <arg name="goal_ori_w"            value="0.70" />
+  </include>
+
+  <!-- op_common_params  -->
+  <include file="$(find op_local_planner)/launch/op_common_params_parameter.launch">
+    <!-- Included in app window -->
+    <arg name="horizonDistance"                 default="120"  />     <!-- Horizon -->
+    <arg name="maxLocalPlanDistance"            default="80" />       <!-- Plan Distance-->
+    <arg name="pathDensity"                     default="0.5" />      <!-- Path Density-->
+    <arg name="enableFollowing"                 default="true" />     <!-- Enable Following -->
+    <arg name="enableSwerving"                  default="true"  />    <!-- Enable Avoidance -->
+    <arg name="minFollowingDistance"            default="30.0"  />    <!-- Follow Distance --> <!-- should be bigger than Distance to follow -->  
+    <arg name="minDistanceToAvoid"              default="20.0" />     <!-- Avoiding Distance --> <!-- should be smaller than minFollowingDistance and larger than maxDistanceToAvoid -->
+    <arg name="maxDistanceToAvoid"              default="0.1"  />     <!-- Avoidnace Limit--> <!-- should be smaller than minDistanceToAvoid -->
+    <arg name="enableStopSignBehavior"          default="false" />    <!-- Enable Stop Sign Stop-->
+    <arg name="enableTrafficLightBehavior"      default="true" />     <!-- Enable Traffic Light -->
+    <arg name="enableLaneChange"                default="false" />    <!-- Enable Lane Change -->
+    <arg name="horizontalSafetyDistance"        default="1"  />       <!-- Lateral Safety --> 
+    <arg name="verticalSafetyDistance"          default="2"  />       <!-- Longitudinal Safet y-->
+    <arg name="velocitySource"                  default="1" />        <!-- read velocities from (0- Odometry, 1- autoware current_velocities, 2- car_info) "" -->   
+    <!-- Vehicle Specification -->
+    <arg name="width"                           default="1.85"  />
+    <arg name="length"                          default="4.2"  />
+    <arg name="wheelBaseLength"                 default="2.7"  />
+    <arg name="turningRadius"                   default="5.2"  />
+    <arg name="maxSteerAngle"                   default="0.45" />
+    <arg name="steeringDelay"                   default="1.2" />
+    <!-- Not included in app window -->
+    <arg name="minPursuiteDistance"             default="3.0"  />
+    <arg name="additionalBrakingDistance"       default="5.0"  />
+    <arg name="giveUpDistance"                  default="-4.0"  />
+    <arg name="mapSource"                       default="0" />        <!-- Autoware=0, Vector Map Folder=1, kml=2 -->
+    <arg name="mapFileName"                     default="" />
+    <arg name="minVelocity"                     default="0.1" />  
+    <arg name="speedProfileFactor"              default="1.2"  />
+    <arg name="smoothingDataWeight"             default="0.45"  />
+    <arg name="smoothingSmoothWeight"           default="0.4"  />
+    <arg name="enableSlowDownOnCurve"           default="true" />
+  </include>
+
+  <!-- op_trajectory_generator -->
+  <include file="$(find op_local_planner)/launch/op_trajectory_generator.launch">
+    <arg name="samplingTipMargin"               default="4"  />       <!-- Tip Margin -->
+    <arg name="samplingOutMargin"               default="8" />        <!-- Roll In Margin -->
+    <arg name="samplingSpeedFactor"             default="0.25" />    
+    <arg name="enableHeadingSmoothing"          default="false" />
+  </include>
+
+  <!-- op_motion_predictor -->
+  <include file="$(find op_local_planner)/launch/op_motion_predictor.launch">
+    <!-- <arg name="input_object_list"               default="[/detection/fusion_tools/objects_center]" /> -->
+    <arg name="input_object_list"               default="[/detection/fusion_tools/objects_center]" />
+    <arg name="object_tf_list"                  default="[velodyne]" />
+    <arg name="enableCurbObstacles"             default="false" />    <!-- Detect curbs from map-->
+    <arg name="enableGenrateBranches"           default="false"/>     <!-- Enable Branching -->
+    <arg name="max_distance_to_lane"            default="2.0"/>       <!-- Distance to closest lane-->
+    <arg name="prediction_distance"             default="25.0"/>      <!-- Prediction distance-->
+    <arg name="enableStepByStepSignal"          default="false" />    <!-- Enable Step by Step Test-->
+    <arg name="enableParticleFilterPrediction"  default="false" />    <!-- Enable Particle Filter prediction -->
+    <!-- Not included in app window -->   
+    <arg name="distanceBetweenCurbs"            default="1.5" />
+    <arg name="visualizationTime"               default="0.25" />
+  </include>
+
+  <!-- op_trajectory_evaluator -->
+  <include file="$(find op_local_planner)/launch/op_trajectory_evaluator_parameter.launch">
+    <arg name="enablePrediction"                default="false" />                
+    <arg name="horizontalSafetyDistance"        default="1.2" />
+    <arg name="verticalSafetyDistance"          default="0.8" />
+    <arg name="LateralSkipDistance"             default="5.0" />
+    
+    <arg name="PedestrianRightThreshold" default="4.0" />
+    <arg name="PedestrianLeftThreshold" default="4.0" />
+    <arg name="PedestrianImageDetectionRange" default="0.75" /> <!-- (Ratio If pedestrian's center point is located in this range, our car will be stopped -->               
+    <arg name="VehicleImageDetectionRange" default="0.3" /> <!-- (Ratio) If vehicle's center point is not located in this range, our car set speed as max velocity --> 
+    <arg name="VehicleImageWidthThreshold" default="0.018" /> <!-- (Ratio) If vehilce's width ratio is lower than this, it will be not detected -->
+
+    <arg name="intersectionFile"                default="crossing_test/crossing_intersection.yaml" />
+  </include>
+
+  <!-- op_behavior_selector -->
+  <include file="$(find op_local_planner)/launch/op_behavior_selector_parameter.launch">
+    <arg name="evidence_tust_number"            default="25"/>
+    <arg name="trafficLightFile"                default="crossing_test/crossing_traffic_light.yaml" />
+    <arg name="stopLineFile"                    default="crossing_test/crossing_stop_line.yaml" />
+    <!-- <arg name="intersectionFile"                default="crossing_test/crossing_intersection.yaml" /> -->
+  </include>
+</launch>
\ No newline at end of file
diff --git a/rubis_ws/deprecated/autorunner_scripts/desktop_lane_keeping/desktop_lane_keeping_4_control.launch b/rubis_ws/deprecated/autorunner_scripts/desktop_lane_keeping/desktop_lane_keeping_4_control.launch
new file mode 100644
index 00000000..3653c630
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/desktop_lane_keeping/desktop_lane_keeping_4_control.launch
@@ -0,0 +1,32 @@
+<launch>
+  <!--  Dynamic Pure Pursuit Param -->
+  <rosparam command="load" file="$(env USER_HOME)/autoware.ai/autoware_files/lgsvl_file/parameter/lgsvl_pure_pursuit.yaml" />
+  
+  <!-- pure_pursuit  -->
+  <include file="$(find pure_pursuit)/launch/pure_pursuit.launch">    
+    <!-- Core Parameter -->
+    <arg name="lookahead_ratio"               value="1.2"/>
+    <arg name="minimum_lookahead_distance"    value="3.0"/>
+    
+    <arg name="const_velocity"                value="5.0"/>     
+    <arg name="const_lookahead_distance"      value="4.0"/>
+    <arg name="is_linear_interpolation"       value="True"/>
+    <arg name="publishes_for_steering_robot"  value="True"/>
+    <arg name="add_virtual_end_waypoints"     value="False"/>
+  </include>
+
+  <!-- twist_filter -->
+  <include file="$(find twist_filter)/launch/twist_filter_params.launch">    
+    <!-- For twist_filter -->
+    <arg name="wheel_base" default="2.7" />
+    <arg name="lateral_accel_limit" default="5.0" />
+    <arg name="lateral_jerk_limit" default="5.0" />
+    <arg name="lowpass_gain_linear_x" default="0.0" />
+    <arg name="lowpass_gain_angular_z" default="0.0" />
+    <arg name="lowpass_gain_steering_angle" default="0.0" />
+    <arg name="max_stop_count" default="40" /> <!-- 10 = 1 second -->  
+    <!-- For twist_gate -->
+    <arg name="loop_rate" default="30.0" />
+    <arg name="use_decision_maker" default="false" />
+  </include>
+</launch>
\ No newline at end of file
diff --git a/rubis_ws/deprecated/autorunner_scripts/desktop_lane_keeping/terminate.sh b/rubis_ws/deprecated/autorunner_scripts/desktop_lane_keeping/terminate.sh
new file mode 100644
index 00000000..230ba421
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/desktop_lane_keeping/terminate.sh
@@ -0,0 +1 @@
+rosnode kill /desktop_lane_keeping
\ No newline at end of file
diff --git a/rubis_ws/deprecated/autorunner_scripts/desktop_lane_keeping/test.launch b/rubis_ws/deprecated/autorunner_scripts/desktop_lane_keeping/test.launch
new file mode 100644
index 00000000..1f08cd4a
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/desktop_lane_keeping/test.launch
@@ -0,0 +1,26 @@
+<launch>
+  <rosparam command="load" file="$(env USER_HOME)/autoware.ai/autoware_files/data/yaml/desktop_lgsvl_params.yaml" />
+
+  <arg name="lidar_input_topic" default="/points_raw_origin"/>
+  <arg name="lidar_output_topic" default="/points_raw"/>
+  <arg name="image_input_topic" default="/image_raw_origin"/>
+
+  <!-- Map TF Publisher -->	
+	<include file="$(env USER_HOME)/autoware.ai/autoware_files/data/tf/tf.launch" />
+  
+  <!-- Vector Map Loader -->
+	<node pkg="map_file" type="vector_map_loader" name="vector_map_loader" args="
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/cubetown_circle/dtlane.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/cubetown_circle/idx.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/cubetown_circle/lane.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/cubetown_circle/node.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/cubetown_circle/point.csv"/>
+
+  <!-- Point Map Loader -->
+	<include file="$(find map_file)/launch/points_map_loader.launch">
+    <arg name="scene_num" value="noupdate" />
+    <arg name="path_pcd" value="$(env USER_HOME)/autoware.ai/autoware_files/points_map/CubeTown.pcd"/>
+  </include>
+
+</launch>
+
diff --git a/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_double_curve_autorunner (copy)/_ionic_autorunner_1_sensing.launch b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_double_curve_autorunner (copy)/_ionic_autorunner_1_sensing.launch
new file mode 100644
index 00000000..a62287b4
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_double_curve_autorunner (copy)/_ionic_autorunner_1_sensing.launch	
@@ -0,0 +1,58 @@
+<launch>
+  <rosparam command="load" file="$(env USER_HOME)/rubis_ws/src/rubis_autorunner/cfg/ionic_autorunner/ionic_autorunner_params.yaml" />
+
+  <arg name="lidar_input_topic" default="/points_raw_origin"/>
+  <arg name="lidar_output_topic" default="/points_raw"/>
+
+  <!-- Map TF Publisher -->	
+	<include file="$(env USER_HOME)/autoware.ai/autoware_files/data/tf/tf.launch" />
+  
+  <!-- Vector Map Loader -->
+	<node pkg="map_file" type="vector_map_loader" name="vector_map_loader" args="
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/220118_138ground/double_curve/dtlane.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/220118_138ground/double_curve/idx.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/220118_138ground/double_curve/lane.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/220118_138ground/double_curve/node.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/220118_138ground/double_curve/point.csv"/>
+
+  <!-- Point Map Loader -->
+	<include file="$(find map_file)/launch/points_map_loader.launch">
+    <arg name="scene_num" value="noupdate" />
+    <arg name="path_pcd" value="$(env USER_HOME)/autoware.ai/autoware_files/points_map/220111_138ground_leaf1.pcd"/>
+  </include>
+
+  <!-- Re-publishing simulator/camera_node/image/compressed topic to /image_raw as expected by Autoware -->
+  <!-- <node name="republish" type="republish" pkg="image_transport" output="screen" args="compressed in:=/simulator/camera_node/image raw out:=/image_raw"  /> -->
+
+<!-- Lidar Launch File -->
+  <include file="$(find runtime_manager)/launch_files/velodyne_vlp16_hires.launch" />
+  
+  <!-- <include file="$(find rubis_pkg)/launch/lidar_republisher_params.launch">
+    <arg name="input_topic" value="$(arg lidar_input_topic)" />
+    <arg name="output_topic" value="$(arg lidar_output_topic)" />
+  </include> -->
+
+<!-- TF -->
+  <node pkg="tf" type="static_transform_publisher" name="base_link_to_velodyne" args="3.3 -0.8 0.09 -0.53 0 0 base_link velodyne 10"/>
+  <!-- <node pkg="tf" type="static_transform_publisher" name="gps_to_base_link" args="0 0 0 0 0 0 gps base_link 10"/> -->
+  <!-- <node pkg="tf" type="static_transform_publisher" name="lidar_to_camera" args="0.029 -0.574 -1.820 4.712 0.009 -1.883 velodyne camera 10" /> -->
+
+  <!-- gnss localizer -->
+  <!-- <arg name="plane" default="0"/>
+  <node pkg="rubis_pkg" type="gnss_localizer" name="gnss_localizer" output="screen">
+    <param name="plane" value="$(arg plane)"/>
+  </node> -->
+
+  <!-- CAN Interface -->
+  <include file="$(find can_translate)/launch/can_translate.launch" />
+
+  <!-- INS-D Sensor -->
+  <!-- <include file="$(find inertiallabs_ins)/launch/ins.launch" />   -->
+
+  <!-- INS twist generator -->
+  <include file="$(find ins_twist_generator)/launch/ins_twist_generator.launch">
+    <arg name="yaw_offset" value="-115.139" />
+  </include>
+
+</launch>
+
diff --git a/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_double_curve_autorunner (copy)/_ionic_autorunner_2_localization.launch b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_double_curve_autorunner (copy)/_ionic_autorunner_2_localization.launch
new file mode 100644
index 00000000..49a153d4
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_double_curve_autorunner (copy)/_ionic_autorunner_2_localization.launch	
@@ -0,0 +1,57 @@
+<launch>
+  <!--TODO: Set LidAR Inital Pose-->
+  <arg name="init_x" value="57.1" />
+  <arg name="init_y" value="1.38" />
+  <arg name="init_z" value="0.48" />
+  <arg name="init_roll" value="0.0" />
+  <arg name="init_pitch" value="0.0" />
+  <arg name="init_yaw" value="1.57" />
+
+  <!-- vel/pose connect -->
+  <arg name="topic_pose_stamped" default="/ndt_pose" />
+  <arg name="topic_twist_stamped" default="/estimate_twist" /> 
+  <!-- <arg name="topic_twist_stamped" default="/odom_twist" /> -->
+
+  <!-- points downsampler -->
+  <include file="$(find points_downsampler)/launch/voxel_grid_filter_params.launch" />
+
+  <!-- ndt matching kalman filter parameters -->
+  <rosparam command="load" file="$(env USER_HOME)/rubis_ws/src/rubis_autorunner/cfg/ionic_autorunner/kalman_filter.yaml" />
+
+  <!-- ndt_matching --><!-- pcl_generic=0, pcl_anh=1, pcl_anh_gpu=2, pcl_openmp=3 -->
+  <include file="$(find lidar_localizer)/launch/ndt_matching_params.launch">
+    <arg name="method_type" value="0" /> 
+    <arg name="get_height" value="true" /> 
+    <arg name="init_match_threshold" value="0.5" /> 
+    <arg name="failure_score_diff_threshold" value="10.0" /> 
+    <arg name="recovery_score_diff_threshold" value="1.0" /> 
+    <arg name="failure_pose_diff_threshold" value="4.0" /> 
+    <arg name="recovery_pose_diff_threshold" value="1.0" /> 
+  </include>
+
+  <!-- ndt config -->
+  <node pkg="rostopic" type="rostopic" name="config_ndt"
+  args="pub /config/ndt autoware_config_msgs/ConfigNDT
+  '{header: {seq: 8, stamp: {secs: 0, nsecs: 0}, frame_id: ''},
+    init_pos_gnss: 0,
+    x: $(arg init_x),
+    y: $(arg init_y),
+    z: $(arg init_z),
+    roll: $(arg init_roll), 
+    pitch: $(arg init_pitch),
+    yaw: $(arg init_yaw),
+    use_predict_pose: 1,
+    error_threshold: 1.2,
+    resolution: 4.0,
+    step_size: 0.5,
+    trans_epsilon: 0.05,
+    max_iterations: 10}
+  '"/> 
+  
+  <!-- vel_pose_mux -->
+  <include file="$(find rubis_pkg)/launch/vel_pose_connect_params.launch">
+    <arg name="topic_pose_stamped" value="$(arg topic_pose_stamped)" />
+    <arg name="topic_twist_stamped" value="$(arg topic_twist_stamped)" />
+  </include>
+
+</launch>
diff --git a/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_double_curve_autorunner (copy)/_ionic_autorunner_3_detection.launch b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_double_curve_autorunner (copy)/_ionic_autorunner_3_detection.launch
new file mode 100644
index 00000000..66594cf2
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_double_curve_autorunner (copy)/_ionic_autorunner_3_detection.launch	
@@ -0,0 +1,86 @@
+<launch>
+  <!-- Ground Filter -->
+  <!-- <include file="$(find points_preprocessor)/launch/compare_map_filter_params.launch">
+     <arg name="input_point_topic" value="/points_raw" />
+    <arg name="input_map_topic" value="/points_map" />
+    <arg name="output_match_topic" value="/points_ground_center" />
+    <arg name="output_unmatch_topic" value="/points_no_ground_center" />
+  </include> -->
+
+  <include file="$(find points_preprocessor)/launch/ray_ground_filter_params.launch">
+    <arg name="input_point_topic" value="/points_raw" />  <!-- input_point_topic, ground filtering will be performed over the pointcloud in this topic. -->
+    <arg name="base_frame" value="base_link" />  <!-- Coordinate system to perform transform (default base_link) -->
+    <arg name="max_clipping_height" value="5" />  <!-- Remove Points above this height value (default 2.0 meters) -->
+    <arg name="min_clipping_height" value="-0.5" />  <!-- Remove Points below this height value (default -0.5 meters) -->
+    <arg name="min_point_distance" value="3.5" />  <!-- Removes Points closer than this distance from the sensor origin (default 1.85 meters) -->
+    <arg name="radial_divider_angle" value="0.08" />  <!-- Angle of each Radial division on the XY Plane (default 0.08 degrees)-->
+    <arg name="concentric_divider_distance" value="0.0" />  <!-- Distance of each concentric division on the XY Plane (default 0.0 meters) -->
+    <arg name="local_max_slope" value="8" />  <!-- Max Slope of the ground between Points (default 8 degrees) -->
+    <arg name="general_max_slope" value="1" />  <!-- Max Slope of the ground in the entire PointCloud, used when reclassification occurs (default 5 degrees)-->
+    <arg name="min_height_threshold" value="0.05" />  <!-- Minimum height threshold between points (default 0.05 meters)-->
+    <arg name="reclass_distance_threshold" value="0.02" />  <!-- Distance between points at which re classification will occur (default 0.2 meters)-->
+    <arg name="no_ground_point_topic" value="/points_no_ground" />
+    <arg name="ground_point_topic" value="/points_ground" />
+  </include>
+  
+  <!-- lidar_euclidean_cluster_detect-->
+  <include file="$(find lidar_euclidean_cluster_detect)/launch/lidar_euclidean_cluster_detect.launch">
+    <arg name="points_node" value="/points_no_ground_center" />
+    <arg name="remove_ground" value="true" />
+    <arg name="downsample_cloud" value="false" />
+    <arg name="leaf_size" value="0.68" />
+    <arg name="cluster_size_min" value="1" />
+    <arg name="cluster_size_max" value="100000" />
+    <arg name="sync" value="false" />
+    <arg name="use_diffnormals" value="false" />
+    <arg name="pose_estimation" value="false" />
+    <arg name="clip_min_height" value="-10.0" />
+    <arg name="clip_max_height" value="10" />
+    <arg name="keep_lanes" value="false" />
+    <arg name="keep_lane_left_distance" value="5" />
+    <arg name="keep_lane_right_distance" value="5" />
+    <arg name="cluster_merge_threshold" value="1.5" />
+    <arg name="clustering_distance" value="0.75" />
+    <arg name="use_vector_map" value="false" />
+    <arg name="wayarea_gridmap_layer" value="wayarea" />
+    <arg name="output_frame" value="velodyne" />
+    <arg name="remove_points_upto" value="0.0" />
+    <arg name="use_gpu" value="true" />    
+    <arg name="use_multiple_thres" value="false"/>
+    <arg name="clustering_ranges" value="[15,30,45,60]"/>
+    <arg name="clustering_distances"
+         value="[0.5,1.1,1.6,2.1,2.6]"/>    
+  </include>
+  
+  <!-- vision_darknet_detect -->
+  <include file="$(find vision_darknet_detect)/launch/vision_darknet_detect_parameter.launch">
+    <arg name="gpu_device_id" value="0"/>
+    <arg name="score_threshold" value="0.5"/>
+    <arg name="nms_threshold" value="0.45"/>
+    <arg name="names_file" value="$(find vision_darknet_detect)/darknet/cfg/coco.names"/>
+    <arg name="camera_id" value="/"/>
+    <arg name="image_src" value="/image_raw"/>    
+  </include>
+
+  <!-- imm_ukf_pda_track -->
+  <include file="$(find imm_ukf_pda_track)/launch/imm_ukf_pda_track.launch">
+    <arg name="namespace" default="/detection/object_tracker"/>
+    <arg name="tracker_input_topic" default="/detection/lidar_detector/objects_center" />
+    <arg name="tracker_output_topic" default="/detection/object_tracker/objects_center" />
+    <arg name="tracking_frame" default="/world" />
+    <arg name="gating_threshold" default="9.22" />
+    <arg name="gate_probability" default="0.99" />
+    <arg name="detection_probability" default="0.9" />
+    <arg name="life_time_threshold" default="8" />
+    <arg name="static_velocity_threshold" default="0.5" />
+    <arg name="static_num_history_threshold" default="3" />
+    <arg name="prevent_explosion_threshold" default="1000" />
+    <arg name="merge_distance_threshold" default="0.5"/>
+    <arg name="use_sukf" default="false" />
+    <arg name="use_map_info" default="false" />
+    <arg name="lane_direction_chi_threshold" default="2.71" />
+    <arg name="nearest_lane_distance_threshold" default="1.0" />
+    <arg name="vectormap_frame" default="/map" />
+  </include>
+
+</launch>
\ No newline at end of file
diff --git a/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_double_curve_autorunner (copy)/_ionic_autorunner_4_planning.launch b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_double_curve_autorunner (copy)/_ionic_autorunner_4_planning.launch
new file mode 100644
index 00000000..92401e07
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_double_curve_autorunner (copy)/_ionic_autorunner_4_planning.launch	
@@ -0,0 +1,105 @@
+<launch>
+  <!-- op_global_planning -->
+  <include file="$(find op_global_planner)/launch/op_global_planner.launch">
+    <arg name="pathDensity"           value="1" /> <!-- distance between each two waypoints-->
+    <arg name="enableSmoothing"       value="false" /> <!-- 1 or 0 -->
+    <arg name="enableLaneChange"      value="false" /> <!-- 1 or 0 -->
+    <arg name="enableRvizInput"       value="true" /> <!-- 1 or 0 -->
+    <arg name="enableReplan"          value="false" /> <!-- 1 or 0 -->  
+    <arg name="velocitySource"        value="1" /> <!-- read velocities from (0- Odometry, 1- autoware current_velocities, 2- car_info) "" -->
+    <arg name="mapSource"             value="0" /> <!-- Autoware=0, Vector Map Folder=1, kml file=2 -->
+    <arg name="mapFileName"           value="" /> <!-- incase of kml map source -->
+    <!-- 138ground single curve -->
+    <arg name="use_static_goal"       value="false" />
+    <arg name="goal_pose_x"           value="57.0422019958" />
+    <arg name="goal_pose_y"           value="-5.43001270294" />
+    <arg name="goal_pose_z"           value="0.0" />
+    <arg name="goal_ori_x"            value="0.0" />
+    <arg name="goal_ori_y"            value="0.0" />
+    <arg name="goal_ori_z"            value="0.719615198264" />
+    <arg name="goal_ori_w"            value="0.694373074383" />
+  </include>
+
+  <!-- op_common_params  -->
+  <include file="$(find op_local_planner)/launch/op_common_params_parameter.launch">
+    <!-- Included in app window -->
+    <arg name="horizonDistance"                 default="120"  />     <!-- Horizon -->
+    <arg name="maxLocalPlanDistance"            default="80" />       <!-- Plan Distance-->
+    <arg name="pathDensity"                     default="0.5" />      <!-- Path Density-->
+    <arg name="enableFollowing"                 default="true" />     <!-- Enable Following -->
+    <arg name="enableSwerving"                  default="true"  />    <!-- Enable Avoidance -->
+    <arg name="minFollowingDistance"            default="30.0"  />    <!-- Follow Distance --> <!-- should be bigger than Distance to follow -->  
+    <arg name="minDistanceToAvoid"              default="20.0" />     <!-- Avoiding Distance --> <!-- should be smaller than minFollowingDistance and larger than maxDistanceToAvoid -->
+    <arg name="maxDistanceToAvoid"              default="0.1"  />     <!-- Avoidnace Limit--> <!-- should be smaller than minDistanceToAvoid -->
+    <arg name="enableStopSignBehavior"          default="false" />    <!-- Enable Stop Sign Stop-->
+    <arg name="enableTrafficLightBehavior"      default="true" />     <!-- Enable Traffic Light -->
+    <arg name="enableLaneChange"                default="false" />    <!-- Enable Lane Change -->
+    <arg name="horizontalSafetyDistance"        default="1"  />       <!-- Lateral Safety --> 
+    <arg name="verticalSafetyDistance"          default="2"  />       <!-- Longitudinal Safet y-->
+    <arg name="velocitySource"                  default="1" />        <!-- read velocities from (0- Odometry, 1- autoware current_velocities, 2- car_info) "" -->   
+    <!-- Vehicle Specification -->
+    <arg name="width"                           default="1.82"  />
+    <arg name="length"                          default="4.47"  />
+    <arg name="wheelBaseLength"                 default="2.7"  />
+    <arg name="turningRadius"                   default="3.52826"  />
+    <arg name="maxSteerAngle"                   default="0.65319" />
+    <arg name="steeringDelay"                   default="1.2" />
+    <!-- Not included in app window -->
+    <arg name="minPursuiteDistance"             default="3.0"  />
+    <arg name="additionalBrakingDistance"       default="5.0"  />
+    <arg name="giveUpDistance"                  default="-4.0"  />
+    <arg name="mapSource"                       default="0" />        <!-- Autoware=0, Vector Map Folder=1, kml=2 -->
+    <arg name="mapFileName"                     default="" />
+    <arg name="minVelocity"                     default="0.1" />  
+    <arg name="speedProfileFactor"              default="1.2"  />
+    <arg name="smoothingDataWeight"             default="0.45"  />
+    <arg name="smoothingSmoothWeight"           default="0.4"  />  
+  </include>
+
+  <!-- op_trajectory_generator -->
+  <include file="$(find op_local_planner)/launch/op_trajectory_generator.launch">
+    <arg name="samplingTipMargin"               default="4"  />       <!-- Tip Margin -->
+    <arg name="samplingOutMargin"               default="8" />        <!-- Roll In Margin -->
+    <arg name="samplingSpeedFactor"             default="0.25" />    
+    <arg name="enableHeadingSmoothing"          default="false" />
+  </include>
+
+  <!-- op_motion_predictor -->
+  <include file="$(find op_local_planner)/launch/op_motion_predictor.launch">
+    <!-- <arg name="input_object_list"               default="[/detection/fusion_tools/objects_center]" /> -->
+    <arg name="input_object_list"               default="[/detection/image_detector/objects,/detection/object_tracker/objects_center]" />
+    <arg name="object_tf_list"                  default="[camera,velodyne]" />
+    <arg name="enableCurbObstacles"             default="false" />    <!-- Detect curbs from map-->
+    <arg name="enableGenrateBranches"           default="false"/>     <!-- Enable Branching -->
+    <arg name="max_distance_to_lane"            default="2.0"/>       <!-- Distance to closest lane-->
+    <arg name="prediction_distance"             default="25.0"/>      <!-- Prediction distance-->
+    <arg name="enableStepByStepSignal"          default="false" />    <!-- Enable Step by Step Test-->
+    <arg name="enableParticleFilterPrediction"  default="false" />    <!-- Enable Particle Filter prediction -->
+    <!-- Not included in app window -->   
+    <arg name="distanceBetweenCurbs"            default="1.5" />
+    <arg name="visualizationTime"               default="0.25" />
+  </include>
+
+  <!-- op_trajectory_evaluator -->
+  <include file="$(find op_local_planner)/launch/op_trajectory_evaluator_parameter.launch">
+    <arg name="enablePrediction"                default="false" />                
+    <arg name="horizontalSafetyDistance"        default="1.2" />
+    <arg name="verticalSafetyDistance"          default="0.8" />
+    <arg name="LateralSkipDistance"             default="5.0" />
+    
+    <arg name="PedestrianRightThreshold" default="4.0" />
+    <arg name="PedestrianLeftThreshold" default="4.0" />
+    <arg name="PedestrianImageDetectionRange" default="0.75" /> <!-- (Ratio If pedestrian's center point is located in this range, our car will be stopped -->               
+    <arg name="VehicleImageDetectionRange" default="0.3" /> <!-- (Ratio) If vehicle's center point is not located in this range, our car set speed as max velocity --> 
+    <arg name="VehicleImageWidthThreshold" default="0.018" /> <!-- (Ratio) If vehilce's width ratio is lower than this, it will be not detected -->
+
+    <arg name="intersectionFile"                default="crossing_test/crossing_intersection.yaml" />
+  </include>
+
+  <!-- op_behavior_selector -->
+  <include file="$(find op_local_planner)/launch/op_behavior_selector_parameter.launch">
+    <arg name="evidence_tust_number"            default="25"/>
+    <arg name="trafficLightFile"                default="crossing_test/crossing_traffic_light.yaml" />
+    <arg name="stopLineFile"                    default="crossing_test/crossing_stop_line.yaml" />
+  </include>
+</launch>
\ No newline at end of file
diff --git a/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_double_curve_autorunner (copy)/_ionic_autorunner_5_control.launch b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_double_curve_autorunner (copy)/_ionic_autorunner_5_control.launch
new file mode 100644
index 00000000..41114441
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_double_curve_autorunner (copy)/_ionic_autorunner_5_control.launch	
@@ -0,0 +1,38 @@
+<launch>
+  <!--  Dynamic Pure Pursuit Param -->
+  <rosparam command="load" file="$(env USER_HOME)/rubis_ws/src/rubis_autorunner/cfg/ionic_autorunner/ionic_pure_pursuit_params.yaml" />
+  <rosparam command="load" file="$(env USER_HOME)/rubis_ws/src/rubis_autorunner/cfg/ionic_autorunner/138ground_double_curve_vel.yaml" />
+  
+  <!-- TODO: param tunning -->
+  <!-- pure_pursuit  -->
+  <include file="$(find pure_pursuit)/launch/pure_pursuit_params.launch">   
+    <!-- Core Parameter -->
+    <arg name="lookahead_ratio"               value="1.5"/>
+    <arg name="minimum_lookahead_distance"    value="12.0"/>
+    
+    <arg name="const_velocity"                value="5.0"/>     
+    <arg name="const_lookahead_distance"      value="4.0"/>
+    <arg name="is_linear_interpolation"       value="True"/>
+    <arg name="publishes_for_steering_robot"  value="True"/>
+    <arg name="add_virtual_end_waypoints"     value="False"/>
+  </include>
+
+  <!-- twist_filter -->
+  <include file="$(find twist_filter)/launch/twist_filter_params.launch">    
+    <!-- For twist_filter -->
+    <arg name="wheel_base" default="2.7" />
+    <arg name="lateral_accel_limit" default="5.0" />
+    <arg name="lateral_jerk_limit" default="5.0" />
+    <arg name="lowpass_gain_linear_x" default="0.0" />
+    <arg name="lowpass_gain_angular_z" default="0.0" />
+    <arg name="lowpass_gain_steering_angle" default="0.0" />
+    <arg name="max_stop_count" default="40" /> <!-- 10 = 1 second -->  
+    <!-- For twist_gate -->
+    <arg name="loop_rate" default="30.0" />
+    <arg name="use_decision_maker" default="false" />
+  </include>
+
+  <!-- controller -->
+  <include file="$(find controller)/launch/pid_controller.launch" />
+
+</launch>
\ No newline at end of file
diff --git a/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_gps_test/_ionic_autorunner_1_sensing.launch b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_gps_test/_ionic_autorunner_1_sensing.launch
new file mode 100644
index 00000000..be1dd9e2
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_gps_test/_ionic_autorunner_1_sensing.launch
@@ -0,0 +1,46 @@
+<launch>
+  <rosparam command="load" file="$(env USER_HOME)/rubis_ws/src/rubis_autorunner/cfg/ionic_autorunner/ionic_autorunner_params.yaml" />
+
+  <arg name="lidar_input_topic" default="/points_raw_origin"/>
+  <arg name="lidar_output_topic" default="/points_raw"/>
+
+  <!-- Map TF Publisher -->	
+	<include file="$(env USER_HOME)/autoware.ai/autoware_files/data/tf/tf.launch" />
+  
+  <!-- Vector Map Loader -->
+	<node pkg="map_file" type="vector_map_loader" name="vector_map_loader" args="
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/220503_138gound_gps/dtlane.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/220503_138gound_gps/idx.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/220503_138gound_gps/lane.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/220503_138gound_gps/node.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/220503_138gound_gps/point.csv"/>
+
+  <!-- Point Map Loader -->
+	<!-- <include file="$(find map_file)/launch/points_map_loader.launch">
+    <arg name="scene_num" value="noupdate" />
+    <arg name="path_pcd" value="$(env USER_HOME)/autoware.ai/autoware_files/points_map/FMTC_merged.pcd"/>
+  </include>   -->
+
+<!-- Lidar Launch File -->
+  <!-- <include file="$(find runtime_manager)/launch_files/velodyne_vlp16_hires.launch" /> -->
+  
+
+<!-- TF -->
+  <!-- <node pkg="tf" type="static_transform_publisher" name="base_link_to_velodyne" args="3.3 -0.8 0.09 -0.53 0 0 base_link velodyne 10"/> -->
+  <node pkg="tf" type="static_transform_publisher" name="base_link_to_velodyne" args="3.3 -0.8 0.09 -0.40 0 0 base_link velodyne 10"/>
+  <node pkg="tf" type="static_transform_publisher" name="base_link_to_gnss" args="0.08 0.39 0 0 0 0 base_link gnss 10" />
+
+  <!-- CAN Interface -->
+  <include file="$(find can_translate)/launch/can_translate.launch" />
+
+  <!-- INS twist generator -->
+  <include file="$(find ins_twist_generator)/launch/ins_twist_generator.launch">
+    <arg name="yaw_offset" value="0.0" />
+  </include>
+
+  <!-- GNSS Module-->
+  <include file="$(find gnss_module)/launch/gnss_module.launch">
+  </include>
+
+</launch>
+
diff --git a/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_gps_test/_ionic_autorunner_2_localization.launch b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_gps_test/_ionic_autorunner_2_localization.launch
new file mode 100644
index 00000000..7d14bf71
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_gps_test/_ionic_autorunner_2_localization.launch
@@ -0,0 +1,20 @@
+<launch>
+  <!--TODO: Set LidAR Inital Pose-->
+  <arg name="init_x" value="57.1" />
+  <arg name="init_y" value="1.38" />
+  <arg name="init_z" value="0.48" />
+  <arg name="init_roll" value="0.0" />
+  <arg name="init_pitch" value="0.0" />
+  <arg name="init_yaw" value="1.57" />
+
+  <!-- vel/pose connect -->
+  <arg name="topic_pose_stamped" default="/gnss_pose" />
+  <arg name="topic_twist_stamped" default="/ins_twist" /> 
+  
+  <!-- vel_pose_mux -->
+  <include file="$(find rubis_pkg)/launch/vel_pose_connect_params.launch">
+    <arg name="topic_pose_stamped" value="$(arg topic_pose_stamped)" />
+    <arg name="topic_twist_stamped" value="$(arg topic_twist_stamped)" />
+  </include>
+
+</launch>
diff --git a/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_gps_test/_ionic_autorunner_3_detection.launch b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_gps_test/_ionic_autorunner_3_detection.launch
new file mode 100644
index 00000000..66594cf2
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_gps_test/_ionic_autorunner_3_detection.launch
@@ -0,0 +1,86 @@
+<launch>
+  <!-- Ground Filter -->
+  <!-- <include file="$(find points_preprocessor)/launch/compare_map_filter_params.launch">
+     <arg name="input_point_topic" value="/points_raw" />
+    <arg name="input_map_topic" value="/points_map" />
+    <arg name="output_match_topic" value="/points_ground_center" />
+    <arg name="output_unmatch_topic" value="/points_no_ground_center" />
+  </include> -->
+
+  <include file="$(find points_preprocessor)/launch/ray_ground_filter_params.launch">
+    <arg name="input_point_topic" value="/points_raw" />  <!-- input_point_topic, ground filtering will be performed over the pointcloud in this topic. -->
+    <arg name="base_frame" value="base_link" />  <!-- Coordinate system to perform transform (default base_link) -->
+    <arg name="max_clipping_height" value="5" />  <!-- Remove Points above this height value (default 2.0 meters) -->
+    <arg name="min_clipping_height" value="-0.5" />  <!-- Remove Points below this height value (default -0.5 meters) -->
+    <arg name="min_point_distance" value="3.5" />  <!-- Removes Points closer than this distance from the sensor origin (default 1.85 meters) -->
+    <arg name="radial_divider_angle" value="0.08" />  <!-- Angle of each Radial division on the XY Plane (default 0.08 degrees)-->
+    <arg name="concentric_divider_distance" value="0.0" />  <!-- Distance of each concentric division on the XY Plane (default 0.0 meters) -->
+    <arg name="local_max_slope" value="8" />  <!-- Max Slope of the ground between Points (default 8 degrees) -->
+    <arg name="general_max_slope" value="1" />  <!-- Max Slope of the ground in the entire PointCloud, used when reclassification occurs (default 5 degrees)-->
+    <arg name="min_height_threshold" value="0.05" />  <!-- Minimum height threshold between points (default 0.05 meters)-->
+    <arg name="reclass_distance_threshold" value="0.02" />  <!-- Distance between points at which re classification will occur (default 0.2 meters)-->
+    <arg name="no_ground_point_topic" value="/points_no_ground" />
+    <arg name="ground_point_topic" value="/points_ground" />
+  </include>
+  
+  <!-- lidar_euclidean_cluster_detect-->
+  <include file="$(find lidar_euclidean_cluster_detect)/launch/lidar_euclidean_cluster_detect.launch">
+    <arg name="points_node" value="/points_no_ground_center" />
+    <arg name="remove_ground" value="true" />
+    <arg name="downsample_cloud" value="false" />
+    <arg name="leaf_size" value="0.68" />
+    <arg name="cluster_size_min" value="1" />
+    <arg name="cluster_size_max" value="100000" />
+    <arg name="sync" value="false" />
+    <arg name="use_diffnormals" value="false" />
+    <arg name="pose_estimation" value="false" />
+    <arg name="clip_min_height" value="-10.0" />
+    <arg name="clip_max_height" value="10" />
+    <arg name="keep_lanes" value="false" />
+    <arg name="keep_lane_left_distance" value="5" />
+    <arg name="keep_lane_right_distance" value="5" />
+    <arg name="cluster_merge_threshold" value="1.5" />
+    <arg name="clustering_distance" value="0.75" />
+    <arg name="use_vector_map" value="false" />
+    <arg name="wayarea_gridmap_layer" value="wayarea" />
+    <arg name="output_frame" value="velodyne" />
+    <arg name="remove_points_upto" value="0.0" />
+    <arg name="use_gpu" value="true" />    
+    <arg name="use_multiple_thres" value="false"/>
+    <arg name="clustering_ranges" value="[15,30,45,60]"/>
+    <arg name="clustering_distances"
+         value="[0.5,1.1,1.6,2.1,2.6]"/>    
+  </include>
+  
+  <!-- vision_darknet_detect -->
+  <include file="$(find vision_darknet_detect)/launch/vision_darknet_detect_parameter.launch">
+    <arg name="gpu_device_id" value="0"/>
+    <arg name="score_threshold" value="0.5"/>
+    <arg name="nms_threshold" value="0.45"/>
+    <arg name="names_file" value="$(find vision_darknet_detect)/darknet/cfg/coco.names"/>
+    <arg name="camera_id" value="/"/>
+    <arg name="image_src" value="/image_raw"/>    
+  </include>
+
+  <!-- imm_ukf_pda_track -->
+  <include file="$(find imm_ukf_pda_track)/launch/imm_ukf_pda_track.launch">
+    <arg name="namespace" default="/detection/object_tracker"/>
+    <arg name="tracker_input_topic" default="/detection/lidar_detector/objects_center" />
+    <arg name="tracker_output_topic" default="/detection/object_tracker/objects_center" />
+    <arg name="tracking_frame" default="/world" />
+    <arg name="gating_threshold" default="9.22" />
+    <arg name="gate_probability" default="0.99" />
+    <arg name="detection_probability" default="0.9" />
+    <arg name="life_time_threshold" default="8" />
+    <arg name="static_velocity_threshold" default="0.5" />
+    <arg name="static_num_history_threshold" default="3" />
+    <arg name="prevent_explosion_threshold" default="1000" />
+    <arg name="merge_distance_threshold" default="0.5"/>
+    <arg name="use_sukf" default="false" />
+    <arg name="use_map_info" default="false" />
+    <arg name="lane_direction_chi_threshold" default="2.71" />
+    <arg name="nearest_lane_distance_threshold" default="1.0" />
+    <arg name="vectormap_frame" default="/map" />
+  </include>
+
+</launch>
\ No newline at end of file
diff --git a/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_gps_test/_ionic_autorunner_4_planning.launch b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_gps_test/_ionic_autorunner_4_planning.launch
new file mode 100644
index 00000000..c15f91ce
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_gps_test/_ionic_autorunner_4_planning.launch
@@ -0,0 +1,106 @@
+<launch>
+  <!-- op_global_planning -->
+  <include file="$(find op_global_planner)/launch/op_global_planner.launch">
+    <arg name="pathDensity"           value="1" /> <!-- distance between each two waypoints-->
+    <arg name="enableSmoothing"       value="false" /> <!-- 1 or 0 -->
+    <arg name="enableLaneChange"      value="false" /> <!-- 1 or 0 -->
+    <arg name="enableRvizInput"       value="true" /> <!-- 1 or 0 -->
+    <arg name="enableReplan"          value="false" /> <!-- 1 or 0 -->  
+    <arg name="velocitySource"        value="1" /> <!-- read velocities from (0- Odometry, 1- autoware current_velocities, 2- car_info) "" -->
+    <arg name="mapSource"             value="0" /> <!-- Autoware=0, Vector Map Folder=1, kml file=2 -->
+    <arg name="mapFileName"           value="" /> <!-- incase of kml map source -->
+    <!-- 138ground single curve -->
+    <arg name="use_static_goal"       value="false" />
+    <arg name="goal_pose_x"           value="57.0422019958" />
+    <arg name="goal_pose_y"           value="-5.43001270294" />
+    <arg name="goal_pose_z"           value="0.0" />
+    <arg name="goal_ori_x"            value="0.0" />
+    <arg name="goal_ori_y"            value="0.0" />
+    <arg name="goal_ori_z"            value="0.719615198264" />
+    <arg name="goal_ori_w"            value="0.694373074383" />
+  </include>
+
+  <!-- op_common_params  -->
+  <include file="$(find op_local_planner)/launch/op_common_params_parameter.launch">
+    <!-- Included in app window -->
+    <arg name="horizonDistance"                 default="120"  />     <!-- Horizon -->
+    <arg name="maxLocalPlanDistance"            default="80" />       <!-- Plan Distance-->
+    <arg name="pathDensity"                     default="0.5" />      <!-- Path Density-->
+    <arg name="enableFollowing"                 default="true" />     <!-- Enable Following -->
+    <arg name="enableSwerving"                  default="true"  />    <!-- Enable Avoidance -->
+    <arg name="minFollowingDistance"            default="30.0"  />    <!-- Follow Distance --> <!-- should be bigger than Distance to follow -->  
+    <arg name="minDistanceToAvoid"              default="20.0" />     <!-- Avoiding Distance --> <!-- should be smaller than minFollowingDistance and larger than maxDistanceToAvoid -->
+    <arg name="maxDistanceToAvoid"              default="0.1"  />     <!-- Avoidnace Limit--> <!-- should be smaller than minDistanceToAvoid -->
+    <arg name="enableStopSignBehavior"          default="false" />    <!-- Enable Stop Sign Stop-->
+    <arg name="enableTrafficLightBehavior"      default="true" />     <!-- Enable Traffic Light -->
+    <arg name="enableLaneChange"                default="false" />    <!-- Enable Lane Change -->
+    <arg name="horizontalSafetyDistance"        default="1"  />       <!-- Lateral Safety --> 
+    <arg name="verticalSafetyDistance"          default="2"  />       <!-- Longitudinal Safet y-->
+    <arg name="velocitySource"                  default="1" />        <!-- read velocities from (0- Odometry, 1- autoware current_velocities, 2- car_info) "" -->   
+    <!-- Vehicle Specification -->
+    <arg name="width"                           default="1.82"  />
+    <arg name="length"                          default="4.47"  />
+    <arg name="wheelBaseLength"                 default="2.7"  />
+    <arg name="turningRadius"                   default="3.52826"  />
+    <arg name="maxSteerAngle"                   default="0.65319" />
+    <arg name="steeringDelay"                   default="1.2" />
+    <!-- Not included in app window -->
+    <arg name="minPursuiteDistance"             default="3.0"  />
+    <arg name="additionalBrakingDistance"       default="30.0"  />
+    <arg name="giveUpDistance"                  default="-4.0"  />
+    <arg name="mapSource"                       default="0" />        <!-- Autoware=0, Vector Map Folder=1, kml=2 -->
+    <arg name="mapFileName"                     default="" />
+    <arg name="minVelocity"                     default="0.1" />  
+    <arg name="speedProfileFactor"              default="1.2"  />
+    <arg name="smoothingDataWeight"             default="0.45"  />
+    <arg name="smoothingSmoothWeight"           default="0.4"  />
+    <arg name="enableSlowDownOnCurve"           default="true" />
+  </include>
+
+  <!-- op_trajectory_generator -->
+  <include file="$(find op_local_planner)/launch/op_trajectory_generator.launch">
+    <arg name="samplingTipMargin"               default="4"  />       <!-- Tip Margin -->
+    <arg name="samplingOutMargin"               default="8" />        <!-- Roll In Margin -->
+    <arg name="samplingSpeedFactor"             default="0.25" />    
+    <arg name="enableHeadingSmoothing"          default="false" />
+  </include>
+
+  <!-- op_motion_predictor -->
+  <include file="$(find op_local_planner)/launch/op_motion_predictor.launch">
+    <!-- <arg name="input_object_list"               default="[/detection/fusion_tools/objects_center]" /> -->
+    <arg name="input_object_list"               default="[/detection/image_detector/objects,/detection/object_tracker/objects_center]" />
+    <arg name="object_tf_list"                  default="[camera,velodyne]" />
+    <arg name="enableCurbObstacles"             default="false" />    <!-- Detect curbs from map-->
+    <arg name="enableGenrateBranches"           default="false"/>     <!-- Enable Branching -->
+    <arg name="max_distance_to_lane"            default="2.0"/>       <!-- Distance to closest lane-->
+    <arg name="prediction_distance"             default="25.0"/>      <!-- Prediction distance-->
+    <arg name="enableStepByStepSignal"          default="false" />    <!-- Enable Step by Step Test-->
+    <arg name="enableParticleFilterPrediction"  default="false" />    <!-- Enable Particle Filter prediction -->
+    <!-- Not included in app window -->   
+    <arg name="distanceBetweenCurbs"            default="1.5" />
+    <arg name="visualizationTime"               default="0.25" />
+  </include>
+
+  <!-- op_trajectory_evaluator -->
+  <include file="$(find op_local_planner)/launch/op_trajectory_evaluator_parameter.launch">
+    <arg name="enablePrediction"                default="false" />                
+    <arg name="horizontalSafetyDistance"        default="1.2" />
+    <arg name="verticalSafetyDistance"          default="0.8" />
+    <arg name="LateralSkipDistance"             default="5.0" />
+    
+    <arg name="PedestrianRightThreshold" default="4.0" />
+    <arg name="PedestrianLeftThreshold" default="4.0" />
+    <arg name="PedestrianImageDetectionRange" default="0.75" /> <!-- (Ratio If pedestrian's center point is located in this range, our car will be stopped -->               
+    <arg name="VehicleImageDetectionRange" default="0.3" /> <!-- (Ratio) If vehicle's center point is not located in this range, our car set speed as max velocity --> 
+    <arg name="VehicleImageWidthThreshold" default="0.018" /> <!-- (Ratio) If vehilce's width ratio is lower than this, it will be not detected -->
+
+    <arg name="intersectionFile"                default="crossing_test/crossing_intersection.yaml" />
+  </include>
+
+  <!-- op_behavior_selector -->
+  <include file="$(find op_local_planner)/launch/op_behavior_selector_parameter.launch">
+    <arg name="evidence_tust_number"            default="25"/>
+    <arg name="trafficLightFile"                default="crossing_test/crossing_traffic_light.yaml" />
+    <arg name="stopLineFile"                    default="crossing_test/crossing_stop_line.yaml" />
+  </include>
+</launch>
\ No newline at end of file
diff --git a/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_gps_test/_ionic_autorunner_5_control.launch b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_gps_test/_ionic_autorunner_5_control.launch
new file mode 100644
index 00000000..7585a0a9
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_gps_test/_ionic_autorunner_5_control.launch
@@ -0,0 +1,38 @@
+<launch>
+  <!--  Dynamic Pure Pursuit Param -->
+  <rosparam command="load" file="$(env USER_HOME)/rubis_ws/src/rubis_autorunner/cfg/ionic_autorunner/ionic_pure_pursuit_params.yaml" />
+  <rosparam command="load" file="$(env USER_HOME)/rubis_ws/src/rubis_autorunner/cfg/ionic_autorunner/ionic_FMTC_red_course_vel.yaml" />
+
+  <!-- TODO: param tunning -->
+  <!-- pure_pursuit  -->
+  <include file="$(find pure_pursuit)/launch/pure_pursuit_params.launch">   
+    <!-- Core Parameter -->
+    <arg name="lookahead_ratio"               value="1.6"/>
+    <arg name="minimum_lookahead_distance"    value="4.0"/>
+    
+    <arg name="const_velocity"                value="5.0"/>     
+    <arg name="const_lookahead_distance"      value="4.0"/>
+    <arg name="is_linear_interpolation"       value="True"/>
+    <arg name="publishes_for_steering_robot"  value="True"/>
+    <arg name="add_virtual_end_waypoints"     value="False"/>
+  </include>
+
+  <!-- twist_filter -->
+  <include file="$(find twist_filter)/launch/twist_filter_params.launch">    
+    <!-- For twist_filter -->
+    <arg name="wheel_base" default="2.7" />
+    <arg name="lateral_accel_limit" default="5.0" />
+    <arg name="lateral_jerk_limit" default="5.0" />
+    <arg name="lowpass_gain_linear_x" default="0.0" />
+    <arg name="lowpass_gain_angular_z" default="0.0" />
+    <arg name="lowpass_gain_steering_angle" default="0.0" />
+    <arg name="max_stop_count" default="40" /> <!-- 10 = 1 second -->  
+    <!-- For twist_gate -->
+    <arg name="loop_rate" default="30.0" />
+    <arg name="use_decision_maker" default="false" />
+  </include>
+
+  <!-- controller -->
+  <include file="$(find controller)/launch/pid_controller.launch" />
+
+</launch>
\ No newline at end of file
diff --git a/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_single_curve_autorunner/_ionic_autorunner_1_sensing.launch b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_single_curve_autorunner/_ionic_autorunner_1_sensing.launch
new file mode 100644
index 00000000..8d85ce76
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_single_curve_autorunner/_ionic_autorunner_1_sensing.launch
@@ -0,0 +1,57 @@
+<launch>
+  <rosparam command="load" file="$(env USER_HOME)/rubis_ws/src/rubis_autorunner/cfg/ionic_autorunner/ionic_autorunner_params.yaml" />
+
+  <arg name="lidar_input_topic" default="/points_raw_origin"/>
+  <arg name="lidar_output_topic" default="/points_raw"/>
+
+  <!-- Map TF Publisher -->	
+	<include file="$(env USER_HOME)/autoware.ai/autoware_files/data/tf/tf.launch" />
+  
+  <!-- Vector Map Loader -->
+	<node pkg="map_file" type="vector_map_loader" name="vector_map_loader" args="
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/220118_138ground/long_circle/dtlane.csv
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/220118_138ground/long_circle/lane.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/220118_138ground/long_circle/node.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/220118_138ground/long_circle/point.csv"/>
+
+  <!-- Point Map Loader -->
+	<include file="$(find map_file)/launch/points_map_loader.launch">
+    <arg name="scene_num" value="noupdate" />
+    <arg name="path_pcd" value="$(env USER_HOME)/autoware.ai/autoware_files/points_map/220111_138ground_leaf1.pcd"/>
+  </include>
+
+  <!-- Re-publishing simulator/camera_node/image/compressed topic to /image_raw as expected by Autoware -->
+  <!-- <node name="republish" type="republish" pkg="image_transport" output="screen" args="compressed in:=/simulator/camera_node/image raw out:=/image_raw"  /> -->
+
+<!-- Lidar Launch File -->
+  <include file="$(find runtime_manager)/launch_files/velodyne_vlp16_hires.launch" />
+  
+  <!-- <include file="$(find rubis_pkg)/launch/lidar_republisher_params.launch">
+    <arg name="input_topic" value="$(arg lidar_input_topic)" />
+    <arg name="output_topic" value="$(arg lidar_output_topic)" />
+  </include> -->
+
+<!-- TF -->
+  <node pkg="tf" type="static_transform_publisher" name="base_link_to_velodyne" args="3.3 -0.8 0.09 -0.53 0 0 base_link velodyne 10"/>
+  <!-- <node pkg="tf" type="static_transform_publisher" name="gps_to_base_link" args="0 0 0 0 0 0 gps base_link 10"/> -->
+  <!-- <node pkg="tf" type="static_transform_publisher" name="lidar_to_camera" args="0.029 -0.574 -1.820 4.712 0.009 -1.883 velodyne camera 10" /> -->
+
+  <!-- gnss localizer -->
+  <!-- <arg name="plane" default="0"/>
+  <node pkg="rubis_pkg" type="gnss_localizer" name="gnss_localizer" output="screen">
+    <param name="plane" value="$(arg plane)"/>
+  </node> -->
+
+  <!-- CAN Interface -->
+  <include file="$(find can_translate)/launch/can_translate.launch" />
+
+  <!-- INS-D Sensor -->
+  <!-- <include file="$(find inertiallabs_ins)/launch/ins.launch" />   -->
+
+  <!-- INS twist generator -->
+  <include file="$(find ins_twist_generator)/launch/ins_twist_generator.launch">
+    <arg name="yaw_offset" value="-84.5828" />
+  </include>
+
+</launch>
+
diff --git a/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_single_curve_autorunner/_ionic_autorunner_2_localization.launch b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_single_curve_autorunner/_ionic_autorunner_2_localization.launch
new file mode 100644
index 00000000..af5aafc3
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_single_curve_autorunner/_ionic_autorunner_2_localization.launch
@@ -0,0 +1,57 @@
+<launch>
+  <!--TODO: Set LidAR Inital Pose-->
+  <arg name="init_x" value="57.1" />
+  <arg name="init_y" value="1.38" />
+  <arg name="init_z" value="0.48" />
+  <arg name="init_roll" value="0.0" />
+  <arg name="init_pitch" value="0.0" />
+  <arg name="init_yaw" value="1.57" />
+
+  <!-- vel/pose connect -->
+  <arg name="topic_pose_stamped" default="/ndt_pose" />
+  <arg name="topic_twist_stamped" default="/estimate_twist" /> 
+  <!-- <arg name="topic_twist_stamped" default="/odom_twist" /> -->
+
+  <!-- points downsampler -->
+  <include file="$(find points_downsampler)/launch/voxel_grid_filter_params.launch" />
+
+  <!-- ndt matching kalman filter parameters -->
+  <rosparam command="load" file="$(env USER_HOME)/rubis_ws/src/rubis_autorunner/cfg/ionic_autorunner/kalman_filter.yaml" />
+
+  <!-- ndt_matching --><!-- pcl_generic=0, pcl_anh=1, pcl_anh_gpu=2, pcl_openmp=3 -->
+  <include file="$(find lidar_localizer)/launch/ndt_matching_params.launch">
+    <arg name="method_type" value="0" /> 
+    <arg name="get_height" value="true" />
+    <arg name="init_match_threshold" value="8.0" /> 
+    <arg name="failure_score_diff_threshold" value="10.0" /> 
+    <arg name="recovery_score_diff_threshold" value="1.0" /> 
+    <arg name="failure_pose_diff_threshold" value="4.0" /> 
+    <arg name="recovery_pose_diff_threshold" value="1.0" /> 
+  </include>
+
+  <!-- ndt config -->
+  <node pkg="rostopic" type="rostopic" name="config_ndt"
+  args="pub /config/ndt autoware_config_msgs/ConfigNDT
+  '{header: {seq: 8, stamp: {secs: 0, nsecs: 0}, frame_id: ''},
+    init_pos_gnss: 0,
+    x: $(arg init_x),
+    y: $(arg init_y),
+    z: $(arg init_z),
+    roll: $(arg init_roll), 
+    pitch: $(arg init_pitch),
+    yaw: $(arg init_yaw),
+    use_predict_pose: 1,
+    error_threshold: 1.2,
+    resolution: 4.0,
+    step_size: 0.5,
+    trans_epsilon: 0.05,
+    max_iterations: 10}
+  '"/> 
+  
+  <!-- vel_pose_mux -->
+  <include file="$(find rubis_pkg)/launch/vel_pose_connect_params.launch">
+    <arg name="topic_pose_stamped" value="$(arg topic_pose_stamped)" />
+    <arg name="topic_twist_stamped" value="$(arg topic_twist_stamped)" />
+  </include>
+
+</launch>
diff --git a/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_single_curve_autorunner/_ionic_autorunner_3_detection.launch b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_single_curve_autorunner/_ionic_autorunner_3_detection.launch
new file mode 100644
index 00000000..66594cf2
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_single_curve_autorunner/_ionic_autorunner_3_detection.launch
@@ -0,0 +1,86 @@
+<launch>
+  <!-- Ground Filter -->
+  <!-- <include file="$(find points_preprocessor)/launch/compare_map_filter_params.launch">
+     <arg name="input_point_topic" value="/points_raw" />
+    <arg name="input_map_topic" value="/points_map" />
+    <arg name="output_match_topic" value="/points_ground_center" />
+    <arg name="output_unmatch_topic" value="/points_no_ground_center" />
+  </include> -->
+
+  <include file="$(find points_preprocessor)/launch/ray_ground_filter_params.launch">
+    <arg name="input_point_topic" value="/points_raw" />  <!-- input_point_topic, ground filtering will be performed over the pointcloud in this topic. -->
+    <arg name="base_frame" value="base_link" />  <!-- Coordinate system to perform transform (default base_link) -->
+    <arg name="max_clipping_height" value="5" />  <!-- Remove Points above this height value (default 2.0 meters) -->
+    <arg name="min_clipping_height" value="-0.5" />  <!-- Remove Points below this height value (default -0.5 meters) -->
+    <arg name="min_point_distance" value="3.5" />  <!-- Removes Points closer than this distance from the sensor origin (default 1.85 meters) -->
+    <arg name="radial_divider_angle" value="0.08" />  <!-- Angle of each Radial division on the XY Plane (default 0.08 degrees)-->
+    <arg name="concentric_divider_distance" value="0.0" />  <!-- Distance of each concentric division on the XY Plane (default 0.0 meters) -->
+    <arg name="local_max_slope" value="8" />  <!-- Max Slope of the ground between Points (default 8 degrees) -->
+    <arg name="general_max_slope" value="1" />  <!-- Max Slope of the ground in the entire PointCloud, used when reclassification occurs (default 5 degrees)-->
+    <arg name="min_height_threshold" value="0.05" />  <!-- Minimum height threshold between points (default 0.05 meters)-->
+    <arg name="reclass_distance_threshold" value="0.02" />  <!-- Distance between points at which re classification will occur (default 0.2 meters)-->
+    <arg name="no_ground_point_topic" value="/points_no_ground" />
+    <arg name="ground_point_topic" value="/points_ground" />
+  </include>
+  
+  <!-- lidar_euclidean_cluster_detect-->
+  <include file="$(find lidar_euclidean_cluster_detect)/launch/lidar_euclidean_cluster_detect.launch">
+    <arg name="points_node" value="/points_no_ground_center" />
+    <arg name="remove_ground" value="true" />
+    <arg name="downsample_cloud" value="false" />
+    <arg name="leaf_size" value="0.68" />
+    <arg name="cluster_size_min" value="1" />
+    <arg name="cluster_size_max" value="100000" />
+    <arg name="sync" value="false" />
+    <arg name="use_diffnormals" value="false" />
+    <arg name="pose_estimation" value="false" />
+    <arg name="clip_min_height" value="-10.0" />
+    <arg name="clip_max_height" value="10" />
+    <arg name="keep_lanes" value="false" />
+    <arg name="keep_lane_left_distance" value="5" />
+    <arg name="keep_lane_right_distance" value="5" />
+    <arg name="cluster_merge_threshold" value="1.5" />
+    <arg name="clustering_distance" value="0.75" />
+    <arg name="use_vector_map" value="false" />
+    <arg name="wayarea_gridmap_layer" value="wayarea" />
+    <arg name="output_frame" value="velodyne" />
+    <arg name="remove_points_upto" value="0.0" />
+    <arg name="use_gpu" value="true" />    
+    <arg name="use_multiple_thres" value="false"/>
+    <arg name="clustering_ranges" value="[15,30,45,60]"/>
+    <arg name="clustering_distances"
+         value="[0.5,1.1,1.6,2.1,2.6]"/>    
+  </include>
+  
+  <!-- vision_darknet_detect -->
+  <include file="$(find vision_darknet_detect)/launch/vision_darknet_detect_parameter.launch">
+    <arg name="gpu_device_id" value="0"/>
+    <arg name="score_threshold" value="0.5"/>
+    <arg name="nms_threshold" value="0.45"/>
+    <arg name="names_file" value="$(find vision_darknet_detect)/darknet/cfg/coco.names"/>
+    <arg name="camera_id" value="/"/>
+    <arg name="image_src" value="/image_raw"/>    
+  </include>
+
+  <!-- imm_ukf_pda_track -->
+  <include file="$(find imm_ukf_pda_track)/launch/imm_ukf_pda_track.launch">
+    <arg name="namespace" default="/detection/object_tracker"/>
+    <arg name="tracker_input_topic" default="/detection/lidar_detector/objects_center" />
+    <arg name="tracker_output_topic" default="/detection/object_tracker/objects_center" />
+    <arg name="tracking_frame" default="/world" />
+    <arg name="gating_threshold" default="9.22" />
+    <arg name="gate_probability" default="0.99" />
+    <arg name="detection_probability" default="0.9" />
+    <arg name="life_time_threshold" default="8" />
+    <arg name="static_velocity_threshold" default="0.5" />
+    <arg name="static_num_history_threshold" default="3" />
+    <arg name="prevent_explosion_threshold" default="1000" />
+    <arg name="merge_distance_threshold" default="0.5"/>
+    <arg name="use_sukf" default="false" />
+    <arg name="use_map_info" default="false" />
+    <arg name="lane_direction_chi_threshold" default="2.71" />
+    <arg name="nearest_lane_distance_threshold" default="1.0" />
+    <arg name="vectormap_frame" default="/map" />
+  </include>
+
+</launch>
\ No newline at end of file
diff --git a/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_single_curve_autorunner/_ionic_autorunner_4_planning.launch b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_single_curve_autorunner/_ionic_autorunner_4_planning.launch
new file mode 100644
index 00000000..899f293d
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_single_curve_autorunner/_ionic_autorunner_4_planning.launch
@@ -0,0 +1,106 @@
+<launch>
+  <!-- op_global_planning -->
+  <include file="$(find op_global_planner)/launch/op_global_planner.launch">
+    <arg name="pathDensity"           value="1" /> <!-- distance between each two waypoints-->
+    <arg name="enableSmoothing"       value="false" /> <!-- 1 or 0 -->
+    <arg name="enableLaneChange"      value="false" /> <!-- 1 or 0 -->
+    <arg name="enableRvizInput"       value="true" /> <!-- 1 or 0 -->
+    <arg name="enableReplan"          value="false" /> <!-- 1 or 0 -->  
+    <arg name="velocitySource"        value="1" /> <!-- read velocities from (0- Odometry, 1- autoware current_velocities, 2- car_info) "" -->
+    <arg name="mapSource"             value="0" /> <!-- Autoware=0, Vector Map Folder=1, kml file=2 -->
+    <arg name="mapFileName"           value="" /> <!-- incase of kml map source -->
+    <!-- 138ground single curve -->
+    <arg name="use_static_goal"       value="false" />
+    <arg name="goal_pose_x"           value="57.0422019958" />
+    <arg name="goal_pose_y"           value="-5.43001270294" />
+    <arg name="goal_pose_z"           value="0.0" />
+    <arg name="goal_ori_x"            value="0.0" />
+    <arg name="goal_ori_y"            value="0.0" />
+    <arg name="goal_ori_z"            value="0.719615198264" />
+    <arg name="goal_ori_w"            value="0.694373074383" />
+  </include>
+
+  <!-- op_common_params  -->
+  <include file="$(find op_local_planner)/launch/op_common_params_parameter.launch">
+    <!-- Included in app window -->
+    <arg name="horizonDistance"                 default="120"  />     <!-- Horizon -->
+    <arg name="maxLocalPlanDistance"            default="80" />       <!-- Plan Distance-->
+    <arg name="pathDensity"                     default="0.5" />      <!-- Path Density-->
+    <arg name="enableFollowing"                 default="true" />     <!-- Enable Following -->
+    <arg name="enableSwerving"                  default="true"  />    <!-- Enable Avoidance -->
+    <arg name="minFollowingDistance"            default="30.0"  />    <!-- Follow Distance --> <!-- should be bigger than Distance to follow -->  
+    <arg name="minDistanceToAvoid"              default="20.0" />     <!-- Avoiding Distance --> <!-- should be smaller than minFollowingDistance and larger than maxDistanceToAvoid -->
+    <arg name="maxDistanceToAvoid"              default="0.1"  />     <!-- Avoidnace Limit--> <!-- should be smaller than minDistanceToAvoid -->
+    <arg name="enableStopSignBehavior"          default="false" />    <!-- Enable Stop Sign Stop-->
+    <arg name="enableTrafficLightBehavior"      default="true" />     <!-- Enable Traffic Light -->
+    <arg name="enableLaneChange"                default="false" />    <!-- Enable Lane Change -->
+    <arg name="horizontalSafetyDistance"        default="1"  />       <!-- Lateral Safety --> 
+    <arg name="verticalSafetyDistance"          default="2"  />       <!-- Longitudinal Safet y-->
+    <arg name="velocitySource"                  default="1" />        <!-- read velocities from (0- Odometry, 1- autoware current_velocities, 2- car_info) "" -->   
+    <!-- Vehicle Specification -->
+    <arg name="width"                           default="1.82"  />
+    <arg name="length"                          default="4.47"  />
+    <arg name="wheelBaseLength"                 default="2.7"  />
+    <arg name="turningRadius"                   default="3.52826"  />
+    <arg name="maxSteerAngle"                   default="0.65319" />
+    <arg name="steeringDelay"                   default="1.2" />
+    <!-- Not included in app window -->
+    <arg name="minPursuiteDistance"             default="3.0"  />
+    <arg name="additionalBrakingDistance"       default="5.0"  />
+    <arg name="giveUpDistance"                  default="-4.0"  />
+    <arg name="mapSource"                       default="0" />        <!-- Autoware=0, Vector Map Folder=1, kml=2 -->
+    <arg name="mapFileName"                     default="" />
+    <arg name="minVelocity"                     default="0.1" />  
+    <arg name="speedProfileFactor"              default="1.2"  />
+    <arg name="smoothingDataWeight"             default="0.45"  />
+    <arg name="smoothingSmoothWeight"           default="0.4"  />
+    <arg name="enableSlowDownOnCurve"           default="true" />
+  </include>
+
+  <!-- op_trajectory_generator -->
+  <include file="$(find op_local_planner)/launch/op_trajectory_generator.launch">
+    <arg name="samplingTipMargin"               default="4"  />       <!-- Tip Margin -->
+    <arg name="samplingOutMargin"               default="8" />        <!-- Roll In Margin -->
+    <arg name="samplingSpeedFactor"             default="0.25" />    
+    <arg name="enableHeadingSmoothing"          default="false" />
+  </include>
+
+  <!-- op_motion_predictor -->
+  <include file="$(find op_local_planner)/launch/op_motion_predictor.launch">
+    <!-- <arg name="input_object_list"               default="[/detection/fusion_tools/objects_center]" /> -->
+    <arg name="input_object_list"               default="[/detection/image_detector/objects,/detection/object_tracker/objects_center]" />
+    <arg name="object_tf_list"                  default="[camera,velodyne]" />
+    <arg name="enableCurbObstacles"             default="false" />    <!-- Detect curbs from map-->
+    <arg name="enableGenrateBranches"           default="false"/>     <!-- Enable Branching -->
+    <arg name="max_distance_to_lane"            default="2.0"/>       <!-- Distance to closest lane-->
+    <arg name="prediction_distance"             default="25.0"/>      <!-- Prediction distance-->
+    <arg name="enableStepByStepSignal"          default="false" />    <!-- Enable Step by Step Test-->
+    <arg name="enableParticleFilterPrediction"  default="false" />    <!-- Enable Particle Filter prediction -->
+    <!-- Not included in app window -->   
+    <arg name="distanceBetweenCurbs"            default="1.5" />
+    <arg name="visualizationTime"               default="0.25" />
+  </include>
+
+  <!-- op_trajectory_evaluator -->
+  <include file="$(find op_local_planner)/launch/op_trajectory_evaluator_parameter.launch">
+    <arg name="enablePrediction"                default="false" />                
+    <arg name="horizontalSafetyDistance"        default="1.2" />
+    <arg name="verticalSafetyDistance"          default="0.8" />
+    <arg name="LateralSkipDistance"             default="5.0" />
+    
+    <arg name="PedestrianRightThreshold" default="4.0" />
+    <arg name="PedestrianLeftThreshold" default="4.0" />
+    <arg name="PedestrianImageDetectionRange" default="0.75" /> <!-- (Ratio If pedestrian's center point is located in this range, our car will be stopped -->               
+    <arg name="VehicleImageDetectionRange" default="0.3" /> <!-- (Ratio) If vehicle's center point is not located in this range, our car set speed as max velocity --> 
+    <arg name="VehicleImageWidthThreshold" default="0.018" /> <!-- (Ratio) If vehilce's width ratio is lower than this, it will be not detected -->
+
+    <arg name="intersectionFile"                default="crossing_test/crossing_intersection.yaml" />
+  </include>
+
+  <!-- op_behavior_selector -->
+  <include file="$(find op_local_planner)/launch/op_behavior_selector_parameter.launch">
+    <arg name="evidence_tust_number"            default="25"/>
+    <arg name="trafficLightFile"                default="crossing_test/crossing_traffic_light.yaml" />
+    <arg name="stopLineFile"                    default="crossing_test/crossing_stop_line.yaml" />
+  </include>
+</launch>
\ No newline at end of file
diff --git a/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_single_curve_autorunner/_ionic_autorunner_5_control.launch b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_single_curve_autorunner/_ionic_autorunner_5_control.launch
new file mode 100644
index 00000000..1b3fd1e0
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_single_curve_autorunner/_ionic_autorunner_5_control.launch
@@ -0,0 +1,38 @@
+<launch>
+  <!--  Dynamic Pure Pursuit Param -->
+  <rosparam command="load" file="$(env USER_HOME)/rubis_ws/src/rubis_autorunner/cfg/ionic_autorunner/ionic_pure_pursuit_params.yaml" />
+  <rosparam command="load" file="$(env USER_HOME)/rubis_ws/src/rubis_autorunner/cfg/ionic_autorunner/138ground_single_curve_vel.yaml" />
+  
+  <!-- TODO: param tunning -->
+  <!-- pure_pursuit  -->
+  <include file="$(find pure_pursuit)/launch/pure_pursuit_params.launch">   
+    <!-- Core Parameter -->
+    <arg name="lookahead_ratio"               value="1.6"/>
+    <arg name="minimum_lookahead_distance"    value="4.0"/>
+    
+    <arg name="const_velocity"                value="5.0"/>     
+    <arg name="const_lookahead_distance"      value="4.0"/>
+    <arg name="is_linear_interpolation"       value="True"/>
+    <arg name="publishes_for_steering_robot"  value="True"/>
+    <arg name="add_virtual_end_waypoints"     value="False"/>
+  </include>
+
+  <!-- twist_filter -->
+  <include file="$(find twist_filter)/launch/twist_filter_params.launch">    
+    <!-- For twist_filter -->
+    <arg name="wheel_base" default="2.7" />
+    <arg name="lateral_accel_limit" default="5.0" />
+    <arg name="lateral_jerk_limit" default="5.0" />
+    <arg name="lowpass_gain_linear_x" default="0.0" />
+    <arg name="lowpass_gain_angular_z" default="0.0" />
+    <arg name="lowpass_gain_steering_angle" default="0.0" />
+    <arg name="max_stop_count" default="40" /> <!-- 10 = 1 second -->  
+    <!-- For twist_gate -->
+    <arg name="loop_rate" default="30.0" />
+    <arg name="use_decision_maker" default="false" />
+  </include>
+
+  <!-- controller -->
+  <include file="$(find controller)/launch/pid_controller.launch" />
+
+</launch>
\ No newline at end of file
diff --git a/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_single_curve_autorunner/_ionic_autorunner_test.launch b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_single_curve_autorunner/_ionic_autorunner_test.launch
new file mode 100644
index 00000000..c788f638
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/ionic_138ground_single_curve_autorunner/_ionic_autorunner_test.launch
@@ -0,0 +1,35 @@
+<launch>
+  <rosparam command="load" file="$(env USER_HOME)/rubis_ws/src/rubis_autorunner/cfg/ionic_autorunner/ionic_autorunner_params.yaml" />
+
+  <arg name="lidar_input_topic" default="/points_raw_origin"/>
+  <arg name="lidar_output_topic" default="/points_raw"/>
+
+  <!-- Map TF Publisher -->	
+	<include file="$(env USER_HOME)/autoware.ai/autoware_files/data/tf/tf.launch" />
+  
+  <!-- Vector Map Loader -->
+	<node pkg="map_file" type="vector_map_loader" name="vector_map_loader" args="
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/220118_138ground/long_circle/dtlane.csv
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/220118_138ground/long_circle/lane.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/220118_138ground/long_circle/node.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/220118_138ground/long_circle/point.csv"/>
+
+  <!-- Point Map Loader -->
+	<include file="$(find map_file)/launch/points_map_loader.launch">
+    <arg name="scene_num" value="noupdate" />
+    <arg name="path_pcd" value="$(env USER_HOME)/autoware.ai/autoware_files/points_map/220111_138ground_leaf1.pcd"/>
+  </include>
+
+
+<!-- Lidar Launch File -->
+  <include file="$(find runtime_manager)/launch_files/velodyne_vlp16_hires.launch" />
+  
+
+<!-- TF -->
+  <node pkg="tf" type="static_transform_publisher" name="base_link_to_velodyne" args="3.3 -0.8 0.09 -0.4 0 0 base_link velodyne 10"/>
+  <node pkg="tf" type="static_transform_publisher" name="base_link_to_gnss" args="0.0 0.0 0.00 0.0 0 0 base_link gnss 10"/>
+  <!-- <node pkg="tf" type="static_transform_publisher" name="gps_to_base_link" args="0 0 0 0 0 0 gps base_link 10"/> -->
+  <!-- <node pkg="tf" type="static_transform_publisher" name="lidar_to_camera" args="0.029 -0.574 -1.820 4.712 0.009 -1.883 velodyne camera 10" /> -->
+
+</launch>
+
diff --git a/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/_cubetown_autorunner_4_planning.launch b/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/_cubetown_autorunner_4_planning.launch
new file mode 100644
index 00000000..cf4d32cc
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/_cubetown_autorunner_4_planning.launch
@@ -0,0 +1,105 @@
+<launch>
+  <!-- op_global_planning -->
+  <include file="$(find op_global_planner)/launch/op_global_planner.launch">
+    <arg name="pathDensity"           value="1" /> <!-- distance between each two waypoints-->
+    <arg name="enableSmoothing"       value="false" /> <!-- 1 or 0 -->
+    <arg name="enableLaneChange"      value="false" /> <!-- 1 or 0 -->
+    <arg name="enableRvizInput"       value="true" /> <!-- 1 or 0 -->
+    <arg name="enableReplan"          value="false" /> <!-- 1 or 0 -->  
+    <arg name="velocitySource"        value="1" /> <!-- read velocities from (0- Odometry, 1- autoware current_velocities, 2- car_info) "" -->
+    <arg name="mapSource"             value="0" /> <!-- Autoware=0, Vector Map Folder=1, kml file=2 -->
+    <arg name="mapFileName"           value="" /> <!-- incase of kml map source -->
+    <!-- Borregas Avenue -->
+    <arg name="use_static_goal"       value="true" />
+    <arg name="goal_pose_x"           value="57.0422019958" />
+    <arg name="goal_pose_y"           value="-5.43001270294" />
+    <arg name="goal_pose_z"           value="0.0" />
+    <arg name="goal_ori_x"            value="0.0" />
+    <arg name="goal_ori_y"            value="0.0" />
+    <arg name="goal_ori_z"            value="0.719615198264" />
+    <arg name="goal_ori_w"            value="0.694373074383" />
+  </include>
+
+  <!-- op_common_params  -->
+  <include file="$(find op_local_planner)/launch/op_common_params_parameter.launch">
+    <!-- Included in app window -->
+    <arg name="horizonDistance"                 default="120"  />     <!-- Horizon -->
+    <arg name="maxLocalPlanDistance"            default="80" />       <!-- Plan Distance-->
+    <arg name="pathDensity"                     default="0.5" />      <!-- Path Density-->
+    <arg name="enableFollowing"                 default="true" />     <!-- Enable Following -->
+    <arg name="enableSwerving"                  default="true"  />    <!-- Enable Avoidance -->
+    <arg name="minFollowingDistance"            default="30.0"  />    <!-- Follow Distance --> <!-- should be bigger than Distance to follow -->  
+    <arg name="minDistanceToAvoid"              default="20.0" />     <!-- Avoiding Distance --> <!-- should be smaller than minFollowingDistance and larger than maxDistanceToAvoid -->
+    <arg name="maxDistanceToAvoid"              default="0.1"  />     <!-- Avoidnace Limit--> <!-- should be smaller than minDistanceToAvoid -->
+    <arg name="enableStopSignBehavior"          default="false" />    <!-- Enable Stop Sign Stop-->
+    <arg name="enableTrafficLightBehavior"      default="true" />     <!-- Enable Traffic Light -->
+    <arg name="enableLaneChange"                default="false" />    <!-- Enable Lane Change -->
+    <arg name="horizontalSafetyDistance"        default="1"  />       <!-- Lateral Safety --> 
+    <arg name="verticalSafetyDistance"          default="2"  />       <!-- Longitudinal Safet y-->
+    <arg name="velocitySource"                  default="1" />        <!-- read velocities from (0- Odometry, 1- autoware current_velocities, 2- car_info) "" -->   
+    <!-- Vehicle Specification -->
+    <arg name="width"                           default="1.85"  />
+    <arg name="length"                          default="4.2"  />
+    <arg name="wheelBaseLength"                 default="2.7"  />
+    <arg name="turningRadius"                   default="5.2"  />
+    <arg name="maxSteerAngle"                   default="0.45" />
+    <arg name="steeringDelay"                   default="1.2" />
+    <!-- Not included in app window -->
+    <arg name="minPursuiteDistance"             default="3.0"  />
+    <arg name="additionalBrakingDistance"       default="5.0"  />
+    <arg name="giveUpDistance"                  default="-4.0"  />
+    <arg name="mapSource"                       default="0" />        <!-- Autoware=0, Vector Map Folder=1, kml=2 -->
+    <arg name="mapFileName"                     default="" />
+    <arg name="minVelocity"                     default="0.1" />  
+    <arg name="speedProfileFactor"              default="1.2"  />
+    <arg name="smoothingDataWeight"             default="0.45"  />
+    <arg name="smoothingSmoothWeight"           default="0.4"  />  
+  </include>
+
+  <!-- op_trajectory_generator -->
+  <include file="$(find op_local_planner)/launch/op_trajectory_generator.launch">
+    <arg name="samplingTipMargin"               default="4"  />       <!-- Tip Margin -->
+    <arg name="samplingOutMargin"               default="8" />        <!-- Roll In Margin -->
+    <arg name="samplingSpeedFactor"             default="0.25" />    
+    <arg name="enableHeadingSmoothing"          default="false" />
+  </include>
+
+  <!-- op_motion_predictor -->
+  <include file="$(find op_local_planner)/launch/op_motion_predictor.launch">
+    <!-- <arg name="input_object_list"               default="[/detection/fusion_tools/objects_center]" /> -->
+    <arg name="input_object_list"               default="[/detection/image_detector/objects,/detection/object_tracker/objects_center]" />
+    <arg name="object_tf_list"                  default="[camera,velodyne]" />
+    <arg name="enableCurbObstacles"             default="false" />    <!-- Detect curbs from map-->
+    <arg name="enableGenrateBranches"           default="false"/>     <!-- Enable Branching -->
+    <arg name="max_distance_to_lane"            default="2.0"/>       <!-- Distance to closest lane-->
+    <arg name="prediction_distance"             default="25.0"/>      <!-- Prediction distance-->
+    <arg name="enableStepByStepSignal"          default="false" />    <!-- Enable Step by Step Test-->
+    <arg name="enableParticleFilterPrediction"  default="false" />    <!-- Enable Particle Filter prediction -->
+    <!-- Not included in app window -->   
+    <arg name="distanceBetweenCurbs"            default="1.5" />
+    <arg name="visualizationTime"               default="0.25" />
+  </include>
+
+  <!-- op_trajectory_evaluator -->
+  <include file="$(find op_local_planner)/launch/op_trajectory_evaluator_parameter.launch">
+    <arg name="enablePrediction"                default="false" />                
+    <arg name="horizontalSafetyDistance"        default="1.2" />
+    <arg name="verticalSafetyDistance"          default="0.8" />
+    <arg name="LateralSkipDistance"             default="5.0" />
+    
+    <arg name="PedestrianRightThreshold" default="4.0" />
+    <arg name="PedestrianLeftThreshold" default="4.0" />
+    <arg name="PedestrianImageDetectionRange" default="0.75" /> <!-- (Ratio If pedestrian's center point is located in this range, our car will be stopped -->               
+    <arg name="VehicleImageDetectionRange" default="0.3" /> <!-- (Ratio) If vehicle's center point is not located in this range, our car set speed as max velocity --> 
+    <arg name="VehicleImageWidthThreshold" default="0.018" /> <!-- (Ratio) If vehilce's width ratio is lower than this, it will be not detected -->
+
+    <arg name="intersectionFile"                default="crossing_test/crossing_intersection.yaml" />
+  </include>
+
+  <!-- op_behavior_selector -->
+  <include file="$(find op_local_planner)/launch/op_behavior_selector_parameter.launch">
+    <arg name="evidence_tust_number"            default="25"/>
+    <arg name="trafficLightFile"                default="crossing_test/crossing_traffic_light.yaml" />
+    <arg name="stopLineFile"                    default="crossing_test/crossing_stop_line.yaml" />
+  </include>
+</launch>
\ No newline at end of file
diff --git a/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_step1.launch b/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_step1.launch
new file mode 100755
index 00000000..38c45a8a
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_step1.launch
@@ -0,0 +1,50 @@
+<launch>
+	<!-- ROS-Bridge node for Simulator connection -->
+	<node name="websocket_bridge" pkg="rosbridge_server" type="rosbridge_websocket" output="screen" clear_params="true" required="true" />
+
+	<!-- Vector Map Loader -->
+	<node pkg="map_file" type="vector_map_loader" name="vector_map_loader" args="
+	    $(env HOME)/autoware.ai/autoware_files/lgsvl/vector_map/intersection_left_turn/dtlane.csv 
+	    $(env HOME)/autoware.ai/autoware_files/lgsvl/vector_map/intersection_left_turn/idx.csv 
+	    $(env HOME)/autoware.ai/autoware_files/lgsvl/vector_map/intersection_left_turn/lane.csv 
+	    $(env HOME)/autoware.ai/autoware_files/lgsvl/vector_map/intersection_left_turn/node.csv 
+	    $(env HOME)/autoware.ai/autoware_files/lgsvl/vector_map/intersection_left_turn/point.csv"/>
+	
+	<!-- Point Map Loader -->
+	<!-- <node pkg="map_file"type="points_map_loader" name="points_map_loader"
+		args="noupdate /home/nvidia/autoware_files/map/points_map/191028_rubis_track_origin.pcd"/> -->
+
+	<!-- Map TF Publisher -->	
+	<node pkg="tf" type="static_transform_publisher" name="world_to_map" args="0.0001 0 0 0 0 0 /world /map 10" />
+	<node pkg="tf" type="static_transform_publisher" name="map_to_mobility" args="0 0 0 0 0 0 /map /mobility 10" />
+
+	<!-- Re-publishing simulator/camera_node/image/compressed topic to /image_raw as expected by Autoware -->
+	<node name="image_republisher" type="republish" pkg="image_transport" output="screen" args="compressed in:=/simulator/camera_node/image raw out:=/image_raw_origin"  />
+
+	<!-- LiDAR Republisher -->
+	<include file="$(find rubis_pkg)/launch/lidar_republisher.launch">
+		<arg name="node_name" value="lidar_republisher_left" />
+		<arg name="input_topic" value="/points_raw_l_all_direction" />
+		<arg name="output_topic" value="/points_raw_l_republished" />
+	</include>
+
+	<include file="$(find rubis_pkg)/launch/lidar_republisher.launch">
+		<arg name="node_name" value="lidar_republisher_right" />
+		<arg name="input_topic" value="/points_raw_r_all_direction" />
+		<arg name="output_topic" value="/points_raw_r_republished" />
+	</include>
+
+	<include file="$(find rubis_pkg)/launch/lidar_republisher.launch">
+		<arg name="node_name" value="lidar_republisher_back" />
+		<arg name="input_topic" value="/points_raw_b_all_direction" />
+		<arg name="output_topic" value="/points_raw_b_republished" />
+	</include>
+
+	<include file="$(find rubis_pkg)/launch/camera_republisher.launch"/>
+	<include file="$(find rubis_pkg)/launch/gnss_republisher.launch"/>
+
+	<!-- Traffic Signal -->
+	<include file="$(find rubis_pkg)/launch/lgsvl_traffic_signal_test.launch">
+		<arg name="stopline_data" value="$(env HOME)/rubis_ws/src/rubis_pkg/cfg/testbed_stop_line.yaml"/>
+	</include>
+</launch>
diff --git a/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_step2.launch b/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_step2.launch
new file mode 100755
index 00000000..c9bb8c2b
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_step2.launch
@@ -0,0 +1,96 @@
+<launch>
+	<!-- static tf publisher between base_link and velodyne -->
+  <node pkg="tf" type="static_transform_publisher" name="base_link_to_gnss" args="0 0 0 0 0 0 gps base_link 10"/>
+  <node pkg="tf" type="static_transform_publisher" name="base_link_to_velodyne" args="0 0 0 0 0 0 base_link velodyne 10"/>
+  <node pkg="tf" type="static_transform_publisher" name="velodyne_to_velodyne_left" args="2.3 0.7 0.7 0 0 0 velodyne velodyne_left 10"/>
+  <node pkg="tf" type="static_transform_publisher" name="velodyne_to_velodyne_right" args="2.3 -0.7 0.7 0 0 0 velodyne velodyne_right 10"/>
+  <node pkg="tf" type="static_transform_publisher" name="velodyne_to_velodyne_back" args="-2.5 0.0 0.7 3.14 0 0 velodyne velodyne_back 10"/>
+
+  <include file="$(find rubis_pkg)/launch/pcd_clipper.launch">
+    <arg name="node_name" value="pcd_clipper_left"/>
+    <arg name="enableLocalize" value="false"/>
+    <arg name="input_topic" value="/points_raw_l_republished"/>
+    <arg name="clipped_point_output_topic" value="/points_raw_left"/>
+    <arg name="input_frame_id" value="velodyne_left" />
+    <arg name="clipped_center_angle" value="315"/>
+    <arg name="clipped_viewing_angle" value="210"/>
+  </include>
+
+  <include file="$(find rubis_pkg)/launch/pcd_clipper.launch">
+    <arg name="node_name" value="pcd_clipper_right"/>
+    <arg name="enableLocalize" value="true"/>
+    <arg name="input_topic" value="/points_raw_r_republished"/>        
+    <arg name="input_frame_id" value="velodyne_right" />
+    <arg name="clipped_center_angle" value="90"/>
+    <arg name="clipped_viewing_angle" value="120"/>    
+    <arg name="clipped_point_output_topic" value="/points_raw_right"/>
+    <arg name="localization_point_output_topic" value="/points_raw"/>
+    <arg name="localization_center_angle" value="45"/>
+    <arg name="localization_viewing_angle" value="210"/>
+  </include>
+
+    <include file="$(find rubis_pkg)/launch/pcd_clipper.launch">
+    <arg name="node_name" value="pcd_clipper_back"/>
+    <arg name="enableLocalize" value="true"/>
+    <arg name="input_topic" value="/points_raw_b_republished"/>        
+    <arg name="input_frame_id" value="velodyne_back" />
+    <arg name="clipped_center_angle" value="0"/>
+    <arg name="clipped_viewing_angle" value="180"/>    
+    <arg name="clipped_point_output_topic" value="/points_raw_back"/>
+    <arg name="localization_center_angle" value="45"/>
+    <arg name="localization_viewing_angle" value="210"/>
+  </include>
+
+  <!-- ray_ground_filter LEFT-->
+  <include file="$(find points_preprocessor)/launch/ray_ground_filter.launch">
+    <arg name="label" value="left" />
+    <arg name="input_point_topic" value="/points_raw_left" />  <!-- input_point_topic, ground filtering will be performed over the pointcloud in this topic. -->
+    <arg name="base_frame" value="velodyne_left" />  <!-- Coordinate system to perform transform (default base_link) -->
+    <arg name="max_clipping_height" value="5.0" />  <!-- Remove Points above this height value (default 2.0 meters) -->
+    <arg name="min_clipping_height" value="-0.5" />  <!-- Remove Points below this height value (default -0.5 meters) -->
+    <arg name="min_point_distance" value="2.9" />  <!-- Removes Points closer than this distance from the sensor origin (default 1.85 meters) -->
+    <arg name="radial_divider_angle" value="0.08" />  <!-- Angle of each Radial division on the XY Plane (default 0.08 degrees)-->
+    <arg name="concentric_divider_distance" value="0.71" />  <!-- Distance of each concentric division on the XY Plane (default 0.0 meters) -->
+    <arg name="local_max_slope" value="3" />  <!-- Max Slope of the ground between Points (default 8 degrees) -->
+    <arg name="general_max_slope" value="9" />  <!-- Max Slope of the ground in the entire PointCloud, used when reclassification occurs (default 5 degrees)-->
+    <arg name="min_height_threshold" value="0.4" />  <!-- Minimum height threshold between points (default 0.05 meters)-->
+    <arg name="reclass_distance_threshold" value="0.01" />  <!-- Distance between points at which re classification will occur (default 0.2 meters)-->
+  </include>
+
+    <!-- ray_ground_filter RIGHT-->
+  <include file="$(find points_preprocessor)/launch/ray_ground_filter.launch">
+    <arg name="label" value="right" />
+    <arg name="input_point_topic" value="/points_raw_right" />  <!-- input_point_topic, ground filtering will be performed over the pointcloud in this topic. -->
+    <arg name="base_frame" value="velodyne_right" />  <!-- Coordinate system to perform transform (default base_link) -->
+    <arg name="max_clipping_height" value="5.0" />  <!-- Remove Points above this height value (default 2.0 meters) -->
+    <arg name="min_clipping_height" value="-0.5" />  <!-- Remove Points below this height value (default -0.5 meters) -->
+    <arg name="min_point_distance" value="2.9" />  <!-- Removes Points closer than this distance from the sensor origin (default 1.85 meters) -->
+    <arg name="radial_divider_angle" value="0.08" />  <!-- Angle of each Radial division on the XY Plane (default 0.08 degrees)-->
+    <arg name="concentric_divider_distance" value="0.71" />  <!-- Distance of each concentric division on the XY Plane (default 0.0 meters) -->
+    <arg name="local_max_slope" value="3" />  <!-- Max Slope of the ground between Points (default 8 degrees) -->
+    <arg name="general_max_slope" value="9" />  <!-- Max Slope of the ground in the entire PointCloud, used when reclassification occurs (default 5 degrees)-->
+    <arg name="min_height_threshold" value="0.4" />  <!-- Minimum height threshold between points (default 0.05 meters)-->
+    <arg name="reclass_distance_threshold" value="0.01" />  <!-- Distance between points at which re classification will occur (default 0.2 meters)-->
+  </include>
+
+  <!-- ray_ground_filter BACK-->
+  <include file="$(find points_preprocessor)/launch/ray_ground_filter.launch">
+    <arg name="label" value="back" />
+    <arg name="input_point_topic" value="/points_raw_back" />  <!-- input_point_topic, ground filtering will be performed over the pointcloud in this topic. -->
+    <arg name="base_frame" value="velodyne_back" />  <!-- Coordinate system to perform transform (default base_link) -->
+    <arg name="max_clipping_height" value="5.0" />  <!-- Remove Points above this height value (default 2.0 meters) -->
+    <arg name="min_clipping_height" value="-0.5" />  <!-- Remove Points below this height value (default -0.5 meters) -->
+    <arg name="min_point_distance" value="2.9" />  <!-- Removes Points closer than this distance from the sensor origin (default 1.85 meters) -->
+    <arg name="radial_divider_angle" value="0.08" />  <!-- Angle of each Radial division on the XY Plane (default 0.08 degrees)-->
+    <arg name="concentric_divider_distance" value="0.71" />  <!-- Distance of each concentric division on the XY Plane (default 0.0 meters) -->
+    <arg name="local_max_slope" value="3" />  <!-- Max Slope of the ground between Points (default 8 degrees) -->
+    <arg name="general_max_slope" value="9" />  <!-- Max Slope of the ground in the entire PointCloud, used when reclassification occurs (default 5 degrees)-->
+    <arg name="min_height_threshold" value="0.4" />  <!-- Minimum height threshold between points (default 0.05 meters)-->
+    <arg name="reclass_distance_threshold" value="0.01" />  <!-- Distance between points at which re classification will occur (default 0.2 meters)-->
+  </include>
+
+
+  <!-- points downsampler -->
+  <include file="$(find points_downsampler)/launch/points_downsample.launch" />
+			
+</launch>
diff --git a/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_step3.launch b/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_step3.launch
new file mode 100755
index 00000000..06c2022c
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_step3.launch
@@ -0,0 +1,16 @@
+<launch>
+  <!-- nmea2tfpose -->
+  <include file="$(find rubis_pkg)/launch/gnss_localizer.launch">
+    <arg name="plane" value="0" />
+  </include>
+
+  <!-- vel/pose connect -->
+  <arg name="topic_twist_stamped" default="/gnss_vel" />
+  <arg name="topic_pose_stamped" default="/gnss_pose" />
+
+  <!-- vel_pose_mux -->
+  <include file="$(find autoware_connector)/launch/vel_pose_connect.launch">
+    <arg name="topic_pose_stamped" value="$(arg topic_pose_stamped)" />
+    <arg name="topic_twist_stamped" value="$(arg topic_twist_stamped)" />
+  </include>
+</launch>
diff --git a/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_step4.launch b/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_step4.launch
new file mode 100755
index 00000000..b1c32eae
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_step4.launch
@@ -0,0 +1,13 @@
+<launch>
+  <!-- vision_darknet_detect -->
+  <include file="$(find vision_darknet_detect)/launch/vision_yolo3_detect.launch">
+    <arg name="gpu_device_id" value="0"/>
+    <arg name="score_threshold" value="0.5"/>
+    <arg name="nms_threshold" value="0.45"/>
+    <arg name="network_definition_file" value="$(env HOME)/autoware.ai/autoware_files/vision/yolov3-320.cfg"/>
+    <arg name="pretrained_model_file" value="$(env HOME)/autoware.ai/autoware_files/vision/yolov3-320.weights"/>
+    <arg name="names_file" value="$(find vision_darknet_detect)/darknet/cfg/coco.names"/>
+    <arg name="camera_id" value="/"/>
+    <arg name="image_src" value="/image_raw"/>
+  </include>
+</launch>
diff --git a/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_step5.launch b/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_step5.launch
new file mode 100755
index 00000000..105bff0b
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_step5.launch
@@ -0,0 +1,225 @@
+<launch>
+  <!-- setting of this launch file -->
+  <arg name="car_detection" default="true" />
+  <arg name="pedestrian_detection" default="false" />
+  <arg name="use_gpu" default="false" />
+  <arg name="is_register_lidar2camera_tf" default="true" />
+  <arg name="is_publish_projection_matrix" default="true" />
+  <arg name="is_publish_camera_info" default="true" />
+  <arg name="left_calib" default="$(env HOME)/autoware.ai/autoware_files/lgsvl/data/calibration/double_lidar/left_calibration.yaml"/>
+  <arg name="right_calib" default="$(env HOME)/autoware.ai/autoware_files/lgsvl/data/calibration/double_lidar/right_calibration.yaml"/>
+
+  <!-- calibration_publisher LEFT -->
+  <node pkg="calibration_publisher" type="calibration_publisher" name="calibration_publisher_left" ns="/" output="screen">
+    <param name="register_lidar2camera_tf" type="bool" value="true"/>
+    <param name="publish_extrinsic_mat" type="bool" value="true"/>
+    <param name="publish_camera_info" type="bool" value="true"/>
+    <param name="calibration_file" type="str" value="$(arg left_calib)"/>
+    <param name="target_frame" type="str" value="/velodyne"/>
+    <param name="camera_frame" type="str" value="/camera"/>
+    <param name="image_topic_src" type="str" value="/image_raw"/>
+    <param name="camera_info_topic" type="str" value="/camera_info_left"/>
+    <param name="projection_matrix_topic" type="str" value="/projection_matrix_left"/>
+  </node>
+
+  <!-- lidar_euclidean_cluster_detect LEFT-->
+  <include file="$(find lidar_euclidean_cluster_detect)/launch/lidar_euclidean_cluster_detect.launch">
+    <arg name="points_node" value="/points_no_ground_left" /><!--CHANGE THIS TO READ WHETHER FROM VSCAN OR POINTS_RAW -->
+    <arg name="label" value="left" /><!-- Label of the topics -->
+    <arg name="output_frame" value="velodyne_left" />
+    <arg name="remove_ground" value="true" />
+    <arg name="downsample_cloud" value="false" /> <!-- Apply VoxelGrid Filter with the value given by "leaf_size"-->
+    <arg name="leaf_size" value="0.7" /><!-- Voxel Grid Filter leaf size-->
+    <arg name="cluster_size_min" value="1" /><!-- Minimum number of points to consider a cluster as valid-->
+    <arg name="cluster_size_max" value="100000" /><!-- Maximum number of points to allow inside a cluster-->
+    <arg name="sync" value="false" />
+    <arg name="use_diffnormals" value="false" />
+    <arg name="pose_estimation" value="false" />
+    <arg name="clip_min_height" value="-3.0" />
+    <arg name="clip_max_height" value="4" />
+    <arg name="keep_lanes" value="false" />
+    <arg name="keep_lane_left_distance" value="5" />
+    <arg name="keep_lane_right_distance" value="5" />
+    <arg name="cluster_merge_threshold" value="1.5" />
+    <arg name="clustering_distance" value="0.01" />
+    <arg name="use_vector_map" value="false" />
+    <arg name="wayarea_gridmap_layer" value="wayarea" />
+    <arg name="remove_points_upto" value="0.0" />
+    <arg name="use_gpu" value="$(arg use_gpu)" />
+    <arg name="use_multiple_thres" value="false"/>
+    <arg name="clustering_ranges" value="[15,30,45,60]"/><!-- Distances to segment pointcloud -->
+    <arg name="clustering_distances"
+         value="[0.5,1.1,1.6,2.1,2.6]"/><!-- Euclidean Clustering threshold distance for each segment -->
+  </include>
+
+  <!-- imm_ukf_pda_track LEFT-->
+  <include file="$(find imm_ukf_pda_track)/launch/imm_ukf_pda_track.launch">
+    <arg name="label" value="left" />
+    <arg name="namespace" value="/detection/object_tracker"/>
+    <arg name="tracker_input_topic" value="/detection/lidar_detector/objects_left" />
+    <arg name="tracker_output_topic" value="/detection/object_tracker/objects_left" />
+    <arg name="tracking_frame" value="/world" />
+    <arg name="gating_threshold" value="9.22" />
+    <arg name="gate_probability" value="0.99" />
+    <arg name="detection_probability" value="0.9" />
+    <arg name="life_time_threshold" value="8" />
+    <arg name="static_velocity_threshold" value="0.5" />
+    <arg name="static_num_history_threshold" value="3" />
+    <arg name="prevent_explosion_threshold" value="1000" />
+    <arg name="merge_distance_threshold" value="0.5"/>
+    <arg name="use_sukf" value="false" />
+    <arg name="use_map_info" value="false" />
+    <arg name="lane_direction_chi_threshold" value="2.71" />
+    <arg name="nearest_lane_distance_threshold" value="1.0" />
+    <arg name="vectormap_frame" value="/map" />
+  </include>
+
+  <!-- range fusion LEFT-->
+  <include file="$(find range_vision_fusion)/launch/range_vision_fusion.launch">
+    <arg name="label" default="left" />
+    <arg name="detected_objects_range" default="/detection/object_tracker/objects_left"/>
+    <arg name="detected_objects_vision" default="/detection/image_detector/objects"/>
+    <arg name="camera_info_src" default="/camera_info_left"/>
+    <arg name="min_car_dimensions" default="[3,2,2]"/>
+    <arg name="min_person_dimensions" default="[1,2,1]"/>
+    <arg name="min_truck_dimensions" default="[4,2,2]"/>
+    <arg name="sync_topics" default="true"/>
+    <arg name="overlap_threshold" default="0.000001"/>
+    <arg name="vision_area_ratio_threshold" default="0.000001"/>
+    <arg name="use_vector_map" default="false"/>
+    <arg name="namespace" default="/detection/fusion_tools"/>
+  </include>
+
+  <!-- calibration_publisher RIGHT -->
+  <node pkg="calibration_publisher" type="calibration_publisher" name="calibration_publisher_right" ns="/" output="screen">
+    <param name="register_lidar2camera_tf" type="bool" value="true"/>
+    <param name="publish_extrinsic_mat" type="bool" value="true"/>
+    <param name="publish_camera_info" type="bool" value="true"/>
+    <param name="calibration_file" type="str" value="$(arg right_calib)"/>
+    <param name="target_frame" type="str" value="/velodyne"/>
+    <param name="camera_frame" type="str" value="/camera"/>
+    <param name="image_topic_src" type="str" value="/image_raw"/>
+    <param name="camera_info_topic" type="str" value="/camera_info_right"/>
+    <param name="projection_matrix_topic" type="str" value="/projection_matrix_right"/>
+  </node>
+
+  <!-- lidar_euclidean_cluster_detect RIGHT-->
+  <include file="$(find lidar_euclidean_cluster_detect)/launch/lidar_euclidean_cluster_detect.launch">
+    <arg name="points_node" value="/points_no_ground_right" /><!--CHANGE THIS TO READ WHETHER FROM VSCAN OR POINTS_RAW -->
+    <arg name="label" value="right" /><!-- Label of the topics -->
+    <arg name="output_frame" value="velodyne_right" />
+    <arg name="remove_ground" value="true" />
+    <arg name="downsample_cloud" value="false" /> <!-- Apply VoxelGrid Filter with the value given by "leaf_size"-->
+    <arg name="leaf_size" value="0.7" /><!-- Voxel Grid Filter leaf size-->
+    <arg name="cluster_size_min" value="1" /><!-- Minimum number of points to consider a cluster as valid-->
+    <arg name="cluster_size_max" value="100000" /><!-- Maximum number of points to allow inside a cluster-->
+    <arg name="sync" value="false" />
+    <arg name="use_diffnormals" value="false" />
+    <arg name="pose_estimation" value="false" />
+    <arg name="clip_min_height" value="-3.0" />
+    <arg name="clip_max_height" value="4" />
+    <arg name="keep_lanes" value="false" />
+    <arg name="keep_lane_left_distance" value="5" />
+    <arg name="keep_lane_right_distance" value="5" />
+    <arg name="cluster_merge_threshold" value="1.5" />
+    <arg name="clustering_distance" value="0.01" />
+    <arg name="use_vector_map" value="false" />
+    <arg name="wayarea_gridmap_layer" value="wayarea" />
+    <arg name="remove_points_upto" value="0.0" />
+    <arg name="use_gpu" value="$(arg use_gpu)" />
+    <arg name="use_multiple_thres" value="false"/>
+    <arg name="clustering_ranges" value="[15,30,45,60]"/><!-- Distances to segment pointcloud -->
+    <arg name="clustering_distances"
+         value="[0.5,1.1,1.6,2.1,2.6]"/><!-- Euclidean Clustering threshold distance for each segment -->
+  </include>
+
+  <!-- imm_ukf_pda_track RIGHT-->
+  <include file="$(find imm_ukf_pda_track)/launch/imm_ukf_pda_track.launch">
+    <arg name="label" value="right" />
+    <arg name="namespace" value="/detection/object_tracker"/>
+    <arg name="tracker_input_topic" value="/detection/lidar_detector/objects_right" />
+    <arg name="tracker_output_topic" value="/detection/object_tracker/objects_right" />
+    <arg name="tracking_frame" value="/world" />
+    <arg name="gating_threshold" value="9.22" />
+    <arg name="gate_probability" value="0.99" />
+    <arg name="detection_probability" value="0.9" />
+    <arg name="life_time_threshold" value="8" />
+    <arg name="static_velocity_threshold" value="0.5" />
+    <arg name="static_num_history_threshold" value="3" />
+    <arg name="prevent_explosion_threshold" value="1000" />
+    <arg name="merge_distance_threshold" value="0.5"/>
+    <arg name="use_sukf" value="false" />
+    <arg name="use_map_info" value="false" />
+    <arg name="lane_direction_chi_threshold" value="2.71" />
+    <arg name="nearest_lane_distance_threshold" value="1.0" />
+    <arg name="vectormap_frame" value="/map" />
+  </include>
+
+  <!-- range fusion RIGHT-->
+  <include file="$(find range_vision_fusion)/launch/range_vision_fusion.launch">
+    <arg name="label" default="right" />
+    <arg name="detected_objects_range" default="/detection/object_tracker/objects_right"/>
+    <arg name="detected_objects_vision" default="/detection/image_detector/objects"/>
+    <arg name="camera_info_src" default="/camera_info_right"/>
+    <arg name="min_car_dimensions" default="[3,2,2]"/>
+    <arg name="min_person_dimensions" default="[1,2,1]"/>
+    <arg name="min_truck_dimensions" default="[4,2,2]"/>
+    <arg name="sync_topics" default="true"/>
+    <arg name="overlap_threshold" default="0.2"/>
+    <arg name="vision_area_ratio_threshold" default="0.0025"/>
+    <arg name="use_vector_map" default="false"/>
+    <arg name="namespace" default="/detection/fusion_tools"/>
+  </include>
+
+  <!-- lidar_euclidean_cluster_detect BACK-->
+  <include file="$(find lidar_euclidean_cluster_detect)/launch/lidar_euclidean_cluster_detect.launch">
+    <arg name="points_node" value="/points_no_ground_back" /><!--CHANGE THIS TO READ WHETHER FROM VSCAN OR POINTS_RAW -->
+    <arg name="label" value="back" /><!-- Label of the topics -->
+    <arg name="output_frame" value="velodyne_back" />
+    <arg name="remove_ground" value="true" />
+    <arg name="downsample_cloud" value="false" /> <!-- Apply VoxelGrid Filter with the value given by "leaf_size"-->
+    <arg name="leaf_size" value="0.7" /><!-- Voxel Grid Filter leaf size-->
+    <arg name="cluster_size_min" value="1" /><!-- Minimum number of points to consider a cluster as valid-->
+    <arg name="cluster_size_max" value="100000" /><!-- Maximum number of points to allow inside a cluster-->
+    <arg name="sync" value="false" />
+    <arg name="use_diffnormals" value="false" />
+    <arg name="pose_estimation" value="false" />
+    <arg name="clip_min_height" value="-3.0" />
+    <arg name="clip_max_height" value="4" />
+    <arg name="keep_lanes" value="false" />
+    <arg name="keep_lane_left_distance" value="5" />
+    <arg name="keep_lane_right_distance" value="5" />
+    <arg name="cluster_merge_threshold" value="1.5" />
+    <arg name="clustering_distance" value="0.01" />
+    <arg name="use_vector_map" value="false" />
+    <arg name="wayarea_gridmap_layer" value="wayarea" />
+    <arg name="remove_points_upto" value="0.0" />
+    <arg name="use_gpu" value="$(arg use_gpu)" />
+    <arg name="use_multiple_thres" value="false"/>
+    <arg name="clustering_ranges" value="[15,30,45,60]"/><!-- Distances to segment pointcloud -->
+    <arg name="clustering_distances"
+         value="[0.5,1.1,1.6,2.1,2.6]"/><!-- Euclidean Clustering threshold distance for each segment -->
+  </include>
+
+  <!-- imm_ukf_pda_track BACK-->
+  <include file="$(find imm_ukf_pda_track)/launch/imm_ukf_pda_track.launch">
+    <arg name="label" value="back" />
+    <arg name="namespace" value="/detection/object_tracker"/>
+    <arg name="tracker_input_topic" value="/detection/lidar_detector/objects_back" />
+    <arg name="tracker_output_topic" value="/detection/object_tracker/objects_back" />
+    <arg name="tracking_frame" value="/world" />
+    <arg name="gating_threshold" value="9.22" />
+    <arg name="gate_probability" value="0.99" />
+    <arg name="detection_probability" value="0.9" />
+    <arg name="life_time_threshold" value="8" />
+    <arg name="static_velocity_threshold" value="0.5" />
+    <arg name="static_num_history_threshold" value="3" />
+    <arg name="prevent_explosion_threshold" value="1000" />
+    <arg name="merge_distance_threshold" value="0.5"/>
+    <arg name="use_sukf" value="false" />
+    <arg name="use_map_info" value="false" />
+    <arg name="lane_direction_chi_threshold" value="2.71" />
+    <arg name="nearest_lane_distance_threshold" value="1.0" />
+    <arg name="vectormap_frame" value="/map" />
+  </include>
+</launch>
\ No newline at end of file
diff --git a/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_step6.launch b/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_step6.launch
new file mode 100755
index 00000000..1bd2b8cf
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_step6.launch
@@ -0,0 +1,40 @@
+<launch>
+  <!-- op_global_planning -->
+  <include file="$(find op_global_planner)/launch/op_global_planner.launch">
+    <arg name="pathDensity"           value="1" /> <!-- distance between each two waypoints-->
+    <arg name="enableSmoothing"       value="true" /> <!-- 1 or 0 -->
+    <arg name="enableLaneChange"      value="false" /> <!-- 1 or 0 -->
+    <arg name="enableRvizInput"       value="true" /> <!-- 1 or 0 -->
+    <arg name="enableReplan"          value="false" /> <!-- 1 or 0 -->  
+    <arg name="velocitySource"        value="1" /> <!-- read velocities from (0- Odometry, 1- autoware current_velocities, 2- car_info) "" -->
+    <arg name="mapSource"             value="0" /> <!-- Autoware=0, Vector Map Folder=1, kml file=2 -->
+    <arg name="mapFileName"           value="" /> <!-- incase of kml map source -->
+    <!-- Borregas Avenue -->
+    <!-- <arg name="use_static_goal"       value="true" />
+    <arg name="goal_pose_x"           value="-59.64" />
+    <arg name="goal_pose_y"           value="-153.71" />
+    <arg name="goal_pose_z"           value="0.0" />
+    <arg name="goal_ori_x"            value="0.0" />
+    <arg name="goal_ori_y"            value="0.0" />
+    <arg name="goal_ori_z"            value="-0.81" />
+    <arg name="goal_ori_w"            value="0.58" /> -->
+    <!-- TestBed Avenue -->
+    <!-- <arg name="use_static_goal"       value="true" />
+    <arg name="goal_pose_x"           value="651.96" />
+    <arg name="goal_pose_y"           value="-610.03" />
+    <arg name="goal_pose_z"           value="0.0" />
+    <arg name="goal_ori_x"            value="0.0" />
+    <arg name="goal_ori_y"            value="0.0" />
+    <arg name="goal_ori_z"            value="0.74" />
+    <arg name="goal_ori_w"            value="0.67" /> -->
+    <!-- TestBed LeftTurn Scenario -->
+    <arg name="use_static_goal"       value="true" />
+    <arg name="goal_pose_x"           value="560.744" />
+    <arg name="goal_pose_y"           value="-1122.939" />
+    <arg name="goal_pose_z"           value="0.0" />
+    <arg name="goal_ori_x"            value="0.0" />
+    <arg name="goal_ori_y"            value="0.0" />
+    <arg name="goal_ori_z"            value="-0.99" />
+    <arg name="goal_ori_w"            value="0.024" />
+  </include>
+</launch>
diff --git a/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_step7.launch b/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_step7.launch
new file mode 100755
index 00000000..5d64aed7
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_step7.launch
@@ -0,0 +1,89 @@
+<launch>
+    <!-- op_common_params  -->
+  <include file="$(find op_local_planner)/launch/op_common_params.launch">
+    <!-- Included in app window -->
+    <arg name="horizonDistance"                 default="120"  />     <!-- Horizon -->
+    <arg name="maxLocalPlanDistance"            default="80" />       <!-- Plan Distance-->
+    <arg name="pathDensity"                     default="0.5" />      <!-- Path Density-->
+    <arg name="rollOutDensity"                  default="5" />      <!-- Horizontal Density -->
+    <arg name="rollOutsNumber"                  default="1"    />     <!-- Rollouts Number -->
+    <arg name="maxVelocity"                     default="10.0" />     <!-- Max Velocity -->
+    <arg name="maxAcceleration"                 default="5.0" />      <!-- Acceleration -->
+    <arg name="maxDeceleration"                 default="-15.0" />    <!-- Deceleration -->
+    <arg name="enableFollowing"                 default="true" />     <!-- Enable Following -->
+    <arg name="enableSwerving"                  default="true"  />    <!-- Enable Avoidance -->
+    <arg name="minFollowingDistance"            default="30.0"  />    <!-- Follow Distance --> <!-- should be bigger than Distance to follow -->  
+    <arg name="minDistanceToAvoid"              default="20.0" />     <!-- Avoiding Distance --> <!-- should be smaller than minFollowingDistance and larger than maxDistanceToAvoid -->
+    <arg name="maxDistanceToAvoid"              default="0.1"  />     <!-- Avoidnace Limit--> <!-- should be smaller than minDistanceToAvoid -->
+    <arg name="enableStopSignBehavior"          default="false" />    <!-- Enable Stop Sign Stop-->
+    <arg name="enableTrafficLightBehavior"      default="true" />     <!-- Enable Traffic Light -->
+    <arg name="enableLaneChange"                default="false" />    <!-- Enable Lane Change -->
+    <arg name="horizontalSafetyDistance"        default="1"  />       <!-- Lateral Safety --> 
+    <arg name="verticalSafetyDistance"          default="2"  />       <!-- Longitudinal Safet y-->
+    <arg name="velocitySource"                  default="1" />        <!-- read velocities from (0- Odometry, 1- autoware current_velocities, 2- car_info) "" -->   
+    <!-- Vehicle Specification -->
+    <arg name="width"                           default="1.85"  />
+    <arg name="length"                          default="4.2"  />
+    <arg name="wheelBaseLength"                 default="2.7"  />
+    <arg name="turningRadius"                   default="5.2"  />
+    <arg name="maxSteerAngle"                   default="0.45" />
+    <arg name="steeringDelay"                   default="1.2" />
+    <!-- Not included in app window -->
+    <arg name="minPursuiteDistance"             default="3.0"  />
+    <arg name="additionalBrakingDistance"       default="5.0"  />
+    <arg name="giveUpDistance"                  default="-4.0"  />
+    <arg name="mapSource"                       default="0" />        <!-- Autoware=0, Vector Map Folder=1, kml=2 -->
+    <arg name="mapFileName"                     default="" />
+    <arg name="minVelocity"                     default="0.1" />  
+    <arg name="speedProfileFactor"              default="1.2"  />
+    <arg name="smoothingDataWeight"             default="0.45"  />
+    <arg name="smoothingSmoothWeight"           default="0.4"  />  
+  </include>
+
+  <!-- op_trajectory_generator -->
+  <include file="$(find op_local_planner)/launch/op_trajectory_generator.launch">
+    <arg name="samplingTipMargin"               default="4"  />       <!-- Tip Margin -->
+    <arg name="samplingOutMargin"               default="8" />        <!-- Roll In Margin -->
+    <arg name="samplingSpeedFactor"             default="0.25" />    
+    <arg name="enableHeadingSmoothing"          default="false" />
+  </include>
+
+  <!-- op_motion_predictor -->
+  <include file="$(find op_local_planner)/launch/op_motion_predictor.launch">
+    <arg name="input_object_list"               default="[/detection/fusion_tools/objects_left,/detection/fusion_tools/objects_right,/detection/object_tracker/objects_back]" />
+    <!-- <arg name="input_object_list"               default="[/detection/object_tracker/objects_left,/detection/object_tracker/objects_right,/detection/object_tracker/objects_back]" /> -->
+    <arg name="object_tf_list"                  default="[velodyne_left,velodyne_right,velodyne_back]" />
+    <arg name="enableCurbObstacles"             default="false" />    <!-- Detect curbs from map-->
+    <arg name="enableGenrateBranches"           default="false"/>     <!-- Enable Branching -->
+    <arg name="max_distance_to_lane"            default="2.0"/>       <!-- Distance to closest lane-->
+    <arg name="prediction_distance"             default="25.0"/>      <!-- Prediction distance-->
+    <arg name="enableStepByStepSignal"          default="false" />    <!-- Enable Step by Step Test-->
+    <arg name="enableParticleFilterPrediction"  default="false" />    <!-- Enable Particle Filter prediction -->
+    <!-- Not included in app window -->   
+    <arg name="distanceBetweenCurbs"            default="1.5" />
+    <arg name="visualizationTime"               default="0.25" />
+  </include>
+
+  <!-- op_trajectory_evaluator -->
+  <include file="$(find op_local_planner)/launch/op_trajectory_evaluator.launch">
+    <arg name="enablePrediction"                default="false" />                
+    <arg name="horizontalSafetyDistance"        default="1.2" />
+    <arg name="verticalSafetyDistance"          default="0.8" />
+    <arg name="weightPriority"                  default="0" />
+    <arg name="weightTransition"                default="3" />
+    <arg name="weightLong"                      default="4" />
+    <arg name="weightLat"                       default="10" />
+    <arg name="LateralSkipDistance"             default="5.0" />
+    
+    <arg name="ImageWidth" default="1920" />
+    <arg name="ImageHeight" default="1080" />
+    <arg name="PedestrianRightThreshold" default="4.0" />
+    <arg name="PedestrianLeftThreshold" default="4.0" />
+    <arg name="PedestrianImageDetectionRange" default="0.75" /> <!-- (Ratio If pedestrian's center point is located in this range, our car will be stopped -->               
+    <arg name="VehicleImageDetectionRange" default="0.3" /> <!-- (Ratio) If vehicle's center point is located in this range, our car set speed as max velocity --> 
+    <arg name="VehicleImageWidthThreshold" default="0.018" /> <!-- (Ratio) If vehilce's width ratio is lower than this, it will be not detected -->
+    <arg name="SprintDecisionTime" default="5.0" /> <!-- Seconds -->
+
+    <arg name="intersectionFile"                default="crossing_test/crossing_intersection.yaml" />
+  </include>
+</launch>
diff --git a/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_step8.launch b/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_step8.launch
new file mode 100755
index 00000000..6d826bb0
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_step8.launch
@@ -0,0 +1,13 @@
+<launch>
+    <!-- op_behavior_selector -->
+  <include file="$(find op_local_planner)/launch/op_behavior_selector.launch">
+    <arg name="evidence_tust_number"            default="25"/>
+    <arg name="distanceToPedestrianThreshold"   default="25.0" />
+    <arg name="sprintSpeed"                    default="13.5" />
+    <arg name="obstacleWaitingTimeinIntersection"  default="2.0" />
+    <arg name="turnThreshold"                   default="30.0" />
+    <arg name="trafficLightFile"                default="crossing_test/crossing_traffic_light.yaml" />
+    <arg name="stopLineFile"                    default="crossing_test/crossing_stop_line.yaml" />
+    <!-- <arg name="intersectionFile"                default="crossing_test/crossing_intersection.yaml" /> -->
+  </include>
+</launch>
diff --git a/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_step9.launch b/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_step9.launch
new file mode 100755
index 00000000..e11fc7dd
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_step9.launch
@@ -0,0 +1,30 @@
+<launch>
+  <!-- pure_pursuit  -->
+  <include file="$(find pure_pursuit)/launch/pure_pursuit.launch">    
+    <!-- Core Parameter -->
+    <arg name="lookahead_ratio"               value="1.0"/>
+    <arg name="minimum_lookahead_distance"    value="12.0"/>
+    
+    <arg name="const_velocity"                value="5.0"/>     
+    <arg name="const_lookahead_distance"      value="4.0"/>
+    <arg name="is_linear_interpolation"       value="True"/>
+    <arg name="publishes_for_steering_robot"  value="True"/>
+    <arg name="add_virtual_end_waypoints"     value="False"/>
+    <arg name="dynamic_params_path"           value="$(env HOME)/autoware.ai/autoware_files/lgsvl/parameter/lgsvl_triple_pure_pursuit.yaml" />
+  </include>
+
+  <!-- twist_filter -->
+  <include file="$(find twist_filter)/launch/twist_filter.launch">    
+    <!-- For twist_filter -->
+    <arg name="wheel_base" default="2.7" />
+    <arg name="lateral_accel_limit" default="5.0" />
+    <arg name="lateral_jerk_limit" default="5.0" />
+    <arg name="lowpass_gain_linear_x" default="0.0" />
+    <arg name="lowpass_gain_angular_z" default="0.0" />
+    <arg name="lowpass_gain_steering_angle" default="0.0" />
+    <arg name="max_stop_count" default="40" /> <!-- 10 = 1 second -->  
+    <!-- For twist_gate -->
+    <arg name="loop_rate" default="30.0" />
+    <arg name="use_decision_maker" default="false" />
+  </include>
+</launch>
\ No newline at end of file
diff --git a/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/terminate.sh b/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/terminate.sh
new file mode 100755
index 00000000..b2c331c0
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/lgsvl_triple_lidar_autorunner/terminate.sh
@@ -0,0 +1,56 @@
+rosnode kill /lgsvl_triple_lidar_autorunner
+# rosnode kill /websocket_bridge
+# rosnode kill /lgsvl_traffic_signal_test
+# rosnode kill /image_republisher
+# rosnode kill /lidar_republisher_left
+# rosnode kill /lidar_republisher_right
+# rosnode kill /lidar_republisher_back
+# rosnode kill /camera_republisher
+# rosnode kill /gnss_republisher
+# rosnode kill /base_link_to_gnss
+# rosnode kill /base_link_to_velodyne
+# rosnode kill /vector_map_loader
+# rosnode kill /world_to_map
+# rosnode kill /map_to_mobility
+# rosnode kill /velodyne_to_velodyne_left
+# rosnode kill /velodyne_to_velodyne_right
+# rosnode kill /velodyne_to_velodyne_back
+# rosnode kill /pcd_clipper_left
+# rosnode kill /pcd_clipper_right
+# rosnode kill /pcd_clipper_back
+# rosnode kill /ray_ground_filter_left
+# rosnode kill /ray_ground_filter_right
+# rosnode kill /ray_ground_filter_back
+# rosnode kill /voxel_grid_filter
+# rosnode kill /gnss_localizer
+# rosnode kill /pose_relay
+# rosnode kill /vel_relay
+# rosnode kill /vision_darknet_detect
+# rosnode kill /yolo3_rects
+# rosnode kill /calibration_publisher_left
+# rosnode kill /calibration_publisher_right
+# rosnode kill /lidar_euclidean_cluster_detect_left
+# rosnode kill /lidar_euclidean_cluster_detect_right
+# rosnode kill /lidar_euclidean_cluster_detect_back
+# rosnode kill /imm_ukf_pda_left
+# rosnode kill /imm_ukf_pda_right
+# rosnode kill /imm_ukf_pda_back
+# rosnode kill /range_vision_fusion_left
+# rosnode kill /range_vision_fusion_right
+# rosnode kill /detection/fusion_tools/range_fusion_visualization_left
+# rosnode kill /detection/fusion_tools/range_fusion_visualization_right
+# rosnode kill /detection/lidar_detector/cluster_detect_visualization_back
+# rosnode kill /detection/lidar_detector/cluster_detect_visualization_left
+# rosnode kill /detection/lidar_detector/cluster_detect_visualization_right
+# rosnode kill /detection/object_tracker/ukf_track_visualization_back
+# rosnode kill /detection/object_tracker/ukf_track_visualization_left
+# rosnode kill /detection/object_tracker/ukf_track_visualization_right
+# rosnode kill op_global_planner
+# rosnode kill op_common_params
+# rosnode kill op_trajectory_generator
+# rosnode kill op_motion_predictor
+# rosnode kill predicted_objects_visualizer
+# rosnode kill op_trajectory_evaluator
+# rosnode kill op_behavior_selector
+# rosnode kill pure_pursuit
+# rosnode kill twist_filter
\ No newline at end of file
diff --git a/rubis_ws/deprecated/autorunner_scripts/transformation_test/_transformation_test_1_sensing.launch b/rubis_ws/deprecated/autorunner_scripts/transformation_test/_transformation_test_1_sensing.launch
new file mode 100644
index 00000000..807e075f
--- /dev/null
+++ b/rubis_ws/deprecated/autorunner_scripts/transformation_test/_transformation_test_1_sensing.launch
@@ -0,0 +1,54 @@
+<launch>
+  <rosparam command="load" file="$(env USER_HOME)/rubis_ws/src/rubis_autorunner/cfg/cubetown_autorunner/cubetown_autorunner_params.yaml" />
+
+  <arg name="lidar_input_topic" default="/points_raw_origin"/>
+  <arg name="lidar_output_topic" default="/points_raw"/>
+
+  <!-- Map TF Publisher -->	
+	<include file="$(env USER_HOME)/autoware.ai/autoware_files/data/tf/tf.launch" />
+  
+  <!-- Vector Map Loader -->
+	<node pkg="map_file" type="vector_map_loader" name="vector_map_loader" args="
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/cubetown_circle/dtlane.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/cubetown_circle/idx.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/cubetown_circle/lane.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/cubetown_circle/node.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/cubetown_circle/point.csv"/>
+
+  <!-- Point Map Loader -->
+	<include file="$(find map_file)/launch/points_map_loader.launch">
+    <arg name="scene_num" value="noupdate" />
+    <arg name="path_pcd" value="$(env USER_HOME)/autoware.ai/autoware_files/points_map/CubeTown.pcd"/>
+  </include>
+
+  <!-- Re-publishing simulator/camera_node/image/compressed topic to /image_raw as expected by Autoware -->
+  <node name="republish" type="republish" pkg="image_transport" output="screen" args="compressed in:=/simulator/camera_node/image raw out:=/image_raw"  />
+
+  <include file="$(find rubis_pkg)/launch/lidar_republisher_params.launch">
+    <arg name="input_topic" value="$(arg lidar_input_topic)" />
+    <arg name="output_topic" value="$(arg lidar_output_topic)" />
+  </include>
+
+  <!-- TF -->
+  <node pkg="tf" type="static_transform_publisher" name="base_link_to_velodyne" args="1.2 0 2.0 0 0 0 base_link velodyne 10"/>
+  <node pkg="tf" type="static_transform_publisher" name="base_link_to_gnss" args="0.24 0.39 1.135 0 0 0 base_link gnss 10"/>
+  <node pkg="tf" type="static_transform_publisher" name="lidar_to_camera" args="0.029 -0.574 -1.820 4.712 0.009 -1.883 velodyne camera 10" />
+
+
+  <!-- gnss module -->
+  <include file="$(find gnss_module)/launch/gnss_module.launch">
+        <arg name="pose_topic_name" value="/gnss_test_pose" />
+        <arg name="x_offset" value="0.0" />
+        <arg name="y_offset" value="0.0" />
+        <arg name="z_offset" value="-1463" />
+        <arg name="yaw_offset" value="0.0" />    
+        <arg name="use_gnss_tf" value="false" />  <!-- true: base_link TF is published based on gnss_pose-->
+        <arg name="use_sync" value="false" />     <!-- false: use gps data only -->
+        <arg name="use_kalman_filter" value="false" />
+        <arg name="kalman_filter_params" value="$(find gnss_module)/cfg/kalman_filter.yaml" />
+        <arg name="transformation_params" value="$(env USER_HOME)/autoware.ai/autoware_files/transformation/none.yaml" />
+        <arg name="debug" value="false" />        
+  </include>
+
+</launch>
+
diff --git a/rubis_ws/scripts/carla_test.launch b/rubis_ws/scripts/carla_test.launch
index 24a95b77..deb37689 100755
--- a/rubis_ws/scripts/carla_test.launch
+++ b/rubis_ws/scripts/carla_test.launch
@@ -11,7 +11,15 @@
   <!-- walker mission coordinate reference point 205.0, 297.0, 0.3, 0, 0, 87 -->
   <!-- lr du height roll pitch yaw  -->
   
-  <arg name="spawn_point" default="258.5, 208.2, 0.3, 0, 0, 90"/>
+  <!-- default -->
+  <!-- <arg name="spawn_point" default="258.5, 208.2, 0.3, 0, 0, 90"/> -->
+  <!-- Straight -->
+  <!-- <arg name="spawn_point" default="258.5, 127.05, 0.3, 0, 0, 90"/> -->
+  <!-- new -->
+  <arg name="spawn_point" default="314.065, 129.676, 0.3, 0, 0, 90"/>
+
+
+
   <arg name='role_name_obstacle' default='obstacle'/>
   <!-- <arg name="spawn_point_obstacle" default="324.4, 346.1, 0.3, 0, 0, -32"/> -->
   <arg name="spawn_point_obstacle" default="-10, 214, 0.3, 0, 0, -90"/>
diff --git a/rubis_ws/src/camera_image/src/camera_image.cpp b/rubis_ws/src/camera_image/src/camera_image.cpp
index 0c747228..90d26635 100644
--- a/rubis_ws/src/camera_image/src/camera_image.cpp
+++ b/rubis_ws/src/camera_image/src/camera_image.cpp
@@ -11,8 +11,6 @@ static const std::string OPENCV_WINDOW = "Raw Image Window";
 
 static int camera_id = 0;
 static int frequency = 0;
-static int task_scheduling_flag = 0;
-static int task_profiling_flag = 0;
 static std::string task_response_time_filename;
 // static int rate = 0; // Frequency replaces rate
 static double task_minimum_inter_release_time = 0;
@@ -65,15 +63,13 @@ int main(int argc, char** argv){
 
     pnh.param<int>("/camera_image/camera_id", camera_id, 0);
     pnh.param<int>("/camera_image/frequency", frequency, 10);
-    pnh.param<int>("/camera_image/task_scheduling_flag", task_scheduling_flag, 0);
-    pnh.param<int>("/camera_image/task_profiling_flag", task_profiling_flag, 0);
     pnh.param<std::string>("/camera_image/task_response_time_filename", task_response_time_filename, "~/Documents/profiling/response_time/camera_image.csv");
     // pnh.param<int>("/camera_image/rate", rate, 10); // Frequency replaces rate
     pnh.param("/camera_image/task_minimum_inter_release_time", task_minimum_inter_release_time, (double)100000000);
     pnh.param("/camera_image/task_execution_time", task_execution_time, (double)100000000);
     pnh.param("/camera_image/task_relative_deadline", task_relative_deadline, (double)100000000);
     
-    if(task_profiling_flag) rubis::sched::init_task_profiling(task_response_time_filename);
+    rubis::init_task_profiling(task_response_time_filename);
 
     ROS_INFO("camera_id : %d / frequency : %d",camera_id, frequency);
     if(!frequency){
@@ -104,12 +100,7 @@ void CameraImage::sendImage(){
         
     while(nh_.ok()){
 
-        if(task_profiling_flag) rubis::sched::start_task_profiling();   
-
-        if(rubis::sched::task_state_ == TASK_STATE_READY){            
-            if(task_scheduling_flag) rubis::sched::request_task_scheduling(task_minimum_inter_release_time, task_execution_time, task_relative_deadline);
-            rubis::sched::task_state_ = TASK_STATE_RUNNING;
-        }
+        rubis::start_task_profiling();   
 
         cap >> frame;
         if(!frame.empty()){
@@ -118,17 +109,12 @@ void CameraImage::sendImage(){
             msg = cv_bridge::CvImage(std_msgs::Header(), "bgr8", frame).toImageMsg();
             msg->header.frame_id="camera";
             camera_image_pub_.publish(msg);
-            rubis::sched::is_task_ready_ = TASK_STATE_DONE;            
         }                        
         // int ckey = cv::waitKey(1);
         // if(ckey == 27)break;
 
-        if(task_profiling_flag) rubis::sched::stop_task_profiling(0, rubis::sched::task_state_);
+        rubis::stop_task_profiling(0, 0);
 
-        if(rubis::sched::task_state_ == TASK_STATE_DONE){            
-            if(task_scheduling_flag) rubis::sched::yield_task_scheduling();
-            rubis::sched::task_state_ = TASK_STATE_READY;
-        }
         loop_rate.sleep();
     }
 }
diff --git a/rubis_ws/src/carla_autoware_bridge/launch/carla_autoware_bridge_common.launch b/rubis_ws/src/carla_autoware_bridge/launch/carla_autoware_bridge_common.launch
index d7e1860a..7ea93364 100755
--- a/rubis_ws/src/carla_autoware_bridge/launch/carla_autoware_bridge_common.launch
+++ b/rubis_ws/src/carla_autoware_bridge/launch/carla_autoware_bridge_common.launch
@@ -28,14 +28,14 @@
     remap carla lidar to autoware.
     @todo: to reduce load, Autoware should directly use the Carla-topic.
   -->
-  <node pkg="topic_tools" type="relay" name="points_relay" args="/carla/$(arg role_name)/lidar /points_raw"/>
+  <node pkg="topic_tools" type="relay" name="points_relay" args="/carla/$(arg role_name)/lidar /points_raw_origin"/>
 
   <!-- 
     # CAMERA #
     remap carla front camera to autoware
     @todo: to reduce load, Autoware should directly use the Carla-topic.
   -->
-  <node pkg="topic_tools" type="relay" name="imag_relay" args="/carla/$(arg role_name)/rgb_front/image /image_raw"/>
+  <node pkg="topic_tools" type="relay" name="imag_relay" args="/carla/$(arg role_name)/rgb_front/image /image_raw_origin"/>
 
   <!-- 
     # GNSS #
diff --git a/rubis_ws/src/carla_autoware_bridge/launch/carla_town04.launch b/rubis_ws/src/carla_autoware_bridge/launch/carla_town04.launch
new file mode 100755
index 00000000..deb37689
--- /dev/null
+++ b/rubis_ws/src/carla_autoware_bridge/launch/carla_town04.launch
@@ -0,0 +1,65 @@
+<!-- -->
+<launch>
+  <arg name='host' default='localhost'/>
+  <arg name='port' default='2000'/>
+  <arg name='town' default='Town04'/>
+  <arg name='role_name' default='ego_vehicle'/>
+  
+  <!-- default -->
+  <!-- <arg name="spawn_point" default="258.5, 208.2, 0.3, 0, 0, 90"/> -->
+  
+  <!-- walker mission coordinate reference point 205.0, 297.0, 0.3, 0, 0, 87 -->
+  <!-- lr du height roll pitch yaw  -->
+  
+  <!-- default -->
+  <!-- <arg name="spawn_point" default="258.5, 208.2, 0.3, 0, 0, 90"/> -->
+  <!-- Straight -->
+  <!-- <arg name="spawn_point" default="258.5, 127.05, 0.3, 0, 0, 90"/> -->
+  <!-- new -->
+  <arg name="spawn_point" default="314.065, 129.676, 0.3, 0, 0, 90"/>
+
+
+
+  <arg name='role_name_obstacle' default='obstacle'/>
+  <!-- <arg name="spawn_point_obstacle" default="324.4, 346.1, 0.3, 0, 0, -32"/> -->
+  <arg name="spawn_point_obstacle" default="-10, 214, 0.3, 0, 0, -90"/>
+
+
+  <!-- <arg name="spawn_point_walker" default="212.0, 297.0, 0.3, 0, 0, 180"/> -->
+  <arg name="spawn_point_walker" default="-10, 214, 5, 0, 0, -90"/>
+  <arg name="walker_point1" default="206.0, 297.0, 0.3, 0, 0, 180"/>
+  <arg name="walker_point2" default="204.0, 297.0, 0.3, 0, 0, 180"/>
+  <arg name="walker_point3" default="198.0, 297.0, 0.3, 0, 0, 180"/>
+  <arg name="walker_target_speed" default="2"/>
+  
+  <!-- walker default spawn point 210.0, 297.0, 0.3, 0, 0, 180 -->
+  <!-- walker collision point 206.0 - 204.0, 297.0, 0.3, 0, 0, 180 -->
+
+  <arg name="enable_openplanner_simulation" default="false"/>
+  <arg name="enable_object_insert" default="false"/>
+  <arg name="spawn_sensors_only" default="false"/>
+
+  <include file="$(find carla_autoware_bridge)/launch/carla_autoware_bridge_with_manual_control.launch">
+    <arg name='host' value='$(arg host)'/>
+    <arg name='port' value='$(arg port)'/>
+    <arg name='town' value='$(arg town)'/>
+    <arg name='role_name' value='$(arg role_name)'/>
+    <arg name="spawn_point" value="$(arg spawn_point)"/>
+    <arg name='role_name_obstacle' value='$(arg role_name_obstacle)'/>
+    <arg name="spawn_point_obstacle" value="$(arg spawn_point_obstacle)"/>     
+    <arg name="spawn_point_walker" value="$(arg spawn_point_walker)"/>
+    <arg name="walker_point1" value="$(arg walker_point1)"/>
+    <arg name="walker_point2" value="$(arg walker_point2)"/>
+    <arg name="walker_point3" value="$(arg walker_point3)"/>
+    <arg name="walker_target_speed" value="$(arg walker_target_speed)"/>
+
+    <arg name='spawn_sensors_only' value='$(arg spawn_sensors_only)'/>
+  </include>
+</launch>
+
+
+
+<!-- original -->
+<!-- <arg name="spawn_point" default="-10,214,0.3,0,0,-90"/> -->
+<!-- legacy -->
+<!-- <arg name="spawn_point" default="202.5, 188.0, 0.3, 0, 0, 90"/> -->
\ No newline at end of file
diff --git a/rubis_ws/src/carla_autoware_bridge/src/carla_autoware_bridge/vehiclecmd_to_ackermanndrive b/rubis_ws/src/carla_autoware_bridge/src/carla_autoware_bridge/vehiclecmd_to_ackermanndrive
index 3685e92d..69b53989 100755
--- a/rubis_ws/src/carla_autoware_bridge/src/carla_autoware_bridge/vehiclecmd_to_ackermanndrive
+++ b/rubis_ws/src/carla_autoware_bridge/src/carla_autoware_bridge/vehiclecmd_to_ackermanndrive
@@ -34,9 +34,10 @@ def callback(data):
     """
     global wheelbase
     msg = AckermannDrive()
-    msg.speed = data.twist_cmd.twist.linear.x
+    msg.speed = data.ctrl_cmd.linear_velocity
     msg.steering_angle = convert_trans_rot_vel_to_steering_angle(
         msg.speed, data.twist_cmd.twist.angular.z, wheelbase)
+    msg.acceleration = data.ctrl_cmd.linear_acceleration
     pub.publish(msg)
 
 def twist_to_ackermanndrive():
diff --git a/rubis_ws/src/gnss_converter/CMakeLists.txt b/rubis_ws/src/gnss_converter/CMakeLists.txt
new file mode 100755
index 00000000..8c7a4f57
--- /dev/null
+++ b/rubis_ws/src/gnss_converter/CMakeLists.txt
@@ -0,0 +1,97 @@
+cmake_minimum_required(VERSION 3.0.2)
+project(gnss_converter)
+
+if(NOT CMAKE_BUILD_TYPE)
+  set(CMAKE_BUILD_TYPE Release)
+endif()
+
+set(CMAKE_CXX_FLAGS_RELEASE "-Ofast")
+
+## Compile as C++11, supported in ROS Kinetic and newer
+# add_compile_options(-std=c++11)
+
+find_package(catkin REQUIRED COMPONENTS
+  roscpp
+  std_msgs
+  inertiallabs_msgs
+  geometry_msgs
+  message_filters
+  tf
+)
+
+find_package(Eigen3 REQUIRED)
+set(EIGEN_PACKAGE EIGEN3)
+if(NOT EIGEN3_FOUND)
+  find_package(cmake_modules REQUIRED)
+  find_package(Eigen REQUIRED)
+  set(EIGEN3_INCLUDE_DIRS ${EIGEN_INCLUDE_DIRS})
+  set(EIGEN3_LIBRARIES ${EIGEN_LIBRARIES})
+  set(EIGEN_PACKAGE Eigen)
+endif()
+
+find_package(OpenCV REQUIRED)
+
+catkin_package(
+#  INCLUDE_DIRS include
+#  LIBRARIES gnss_converter
+#  CATKIN_DEPENDS roscpp std_msgs
+#  DEPENDS system_lib
+)
+
+include_directories(
+  include
+  ${catkin_INCLUDE_DIRS}
+  ${OpenCV_INCLUDE_DIRS}
+)
+
+
+add_executable(gnss_converter
+  include/gnss_converter/gnss_converter.h
+  include/gnss_converter/LLH2UTM.h
+  include/gnss_converter/quaternion_euler.h
+  src/gnss_converter.cpp
+  src/LLH2UTM.cpp
+  src/quaternion_euler.cpp
+)
+add_dependencies(gnss_converter ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})
+target_link_libraries(gnss_converter
+  ${catkin_LIBRARIES}
+  ${EIGEN3_LIBRARIES}
+  ${OpenCV_LIBS}
+)
+
+add_executable(gnss_pose_pub
+  include/gnss_converter/LLH2UTM.h
+  include/gnss_converter/quaternion_euler.h
+  src/gnss_pose_pub.cpp
+  src/LLH2UTM.cpp
+  src/quaternion_euler.cpp
+)
+add_dependencies(gnss_pose_pub ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})
+target_link_libraries(gnss_pose_pub
+  ${catkin_LIBRARIES}
+  ${EIGEN3_LIBRARIES}
+  ${OpenCV_LIBS}
+)
+
+install(
+  TARGETS
+    gnss_converter
+    gnss_pose_pub
+  ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
+  LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
+  RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
+)
+
+install(DIRECTORY include/
+  DESTINATION ${CATKIN_GLOBAL_INCLUDE_DESTINATION}
+  PATTERN ".svn" EXCLUDE
+)
+install(DIRECTORY launch/
+  DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION}/launch
+  PATTERN ".svn" EXCLUDE
+)
+
+install(DIRECTORY cfg/
+  DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION}/cfg
+)
diff --git a/rubis_ws/src/gnss_converter/README.md b/rubis_ws/src/gnss_converter/README.md
new file mode 100644
index 00000000..f3594dcb
--- /dev/null
+++ b/rubis_ws/src/gnss_converter/README.md
@@ -0,0 +1,43 @@
+# How to use gnss_converter (/gnss_pose publisher)
+### Case 1 : If you create a new map
+* Record /Inertial_Labs/gps_data, /Inertial_Labs/ins_data, /ndt_pose, /ndt_stat data while driving through the map (rosbag)
+```console
+~$ rosbag record /ndt_pose /ndt_stat /Inertial_Labs/gps_data /Inertial_Labs/ins_data -O [NAME]
+```
+* Set /gnss_converter/calculate_tf of gnss_converter/cfg/gnsss_converter.yaml to true.
+```yaml
+/gnss_converter/calculate_tf : true
+```
+* Set /gnss_converter/bag_file_path of gnss_converter/cfg/gnsss_converter.yaml to recorded rosbag file.
+```yaml
+/gnss_converter/bag_file_path : /home/sunhokim/Documents/RUBIS/data/220111_pose_gnss_138ground.bag   # example
+```
+* Run the following code
+```console
+~$ roslaunch gnss_converter gnss_converter.launch
+```
+* Wait about 40 seconds and a image showing the route of the vehicle will appear on the screen.
+* You can select the four points used to calculate the transformation matrix through the following method.
+  - To change the image size, use track bar to select a value and press enter.
+  - If you want to choose a point, press the number and click the point in the image. (RBUTTONDOWN)
+  - If you want to end, press the ESC button.
+  - **WARNING** : When performing angle transformation, linear transformation was assumed. However, since the angle has a value between -180 degrees and +180 degrees, if there is a discontinuous interval between the four points, the matrix is not properly calculated. Therefore, when selecting four points, it is necessary to make sure that there is no section where the change in angle is discontinuous. (If the first value of the ori_tf matrix is close to -1.0, the calculation was performed well.)
+* After the previous process, the transformation matrix calculation result is displayed on the screen.
+* The calculation result is transferred to gnss_converter/cfg/gnss_converter.yaml.
+```yaml
+# ========= position tf matrix =========
+/gnss_converter/pos_tf : [-1.372640, -1.384772, -27.949656, 13944.211735, 0.410968, -0.109160, -11.105078, -9490.840625, -0.318483, -0.086243, -6.272676, 453.012563, 0.000000, -0.000000, 0.000000, 1.000000] 
+
+# ========= orientation tf matrix =========
+/gnss_converter/ori_tf : [-1.000448, 0.345540, 0.569044, 0.987319, 0.021691, -2.279683, -4.681593, -0.067717, 0.056971, 1.608331, -3.444783, -0.114943, 0.000000, -0.000000, 0.000000, 1.000000]
+```
+* Move to Case 2
+### Case 2 : If you've already done Case 1
+* Set /gnss_converter/calculate_tf of gnss_converter/cfg/gnsss_converter.yaml to false.
+```yaml
+/gnss_converter/calculate_tf : false
+```
+* Execute gnss_converter launch file.
+```console
+~$ roslaunch gnss_converter gnss_converter.launch
+```
diff --git a/rubis_ws/src/gnss_converter/cfg/gnss_converter.yaml b/rubis_ws/src/gnss_converter/cfg/gnss_converter.yaml
new file mode 100644
index 00000000..fa359036
--- /dev/null
+++ b/rubis_ws/src/gnss_converter/cfg/gnss_converter.yaml
@@ -0,0 +1,13 @@
+# true : calculate tf matrix
+# false : publish /gnss_pose topic
+/gnss_converter/calculate_tf : true
+
+/gnss_converter/bag_file_path : /home/sunhokim/Documents/RUBIS/data/220111_pose_gnss_138ground.bag
+
+# map : 220111_138ground
+
+# ========= position tf matrix =========
+/gnss_converter/pos_tf : [-1.372640, -1.384772, -27.949656, 13944.211735, 0.410968, -0.109160, -11.105078, -9490.840625, -0.318483, -0.086243, -6.272676, 453.012563, 0.000000, -0.000000, 0.000000, 1.000000] 
+
+# ========= orientation tf matrix =========
+/gnss_converter/ori_tf : [-1.000448, 0.345540, 0.569044, 0.987319, 0.021691, -2.279683, -4.681593, -0.067717, 0.056971, 1.608331, -3.444783, -0.114943, 0.000000, -0.000000, 0.000000, 1.000000]
\ No newline at end of file
diff --git a/rubis_ws/src/gnss_converter/include/gnss_converter/LLH2UTM.h b/rubis_ws/src/gnss_converter/include/gnss_converter/LLH2UTM.h
new file mode 100644
index 00000000..68728bc5
--- /dev/null
+++ b/rubis_ws/src/gnss_converter/include/gnss_converter/LLH2UTM.h
@@ -0,0 +1,27 @@
+#include <iostream>
+#include <angles/angles.h>
+#include <cmath>
+
+#include <geometry_msgs/PoseStamped.h>
+
+/*************** parameters for LLH to UTM transformation ***************/
+
+#define WGS84_A		6378137.0		// major axis
+#define WGS84_B		6356752.31424518	// minor axis
+#define WGS84_F		0.0033528107		// ellipsoid flattening
+#define WGS84_E		0.0818191908		// first eccentricity
+#define WGS84_EP	0.0820944379		// second eccentricity
+
+// UTM Parameters
+#define UTM_K0		0.9996			// scale factor
+#define UTM_FE		500000.0		// false easting
+#define UTM_FN_N	0.0           // false northing, northern hemisphere
+#define UTM_FN_S	10000000.0    // false northing, southern hemisphere
+#define UTM_E2		(WGS84_E*WGS84_E)	// e^2
+#define UTM_E4		(UTM_E2*UTM_E2)		// e^4
+#define UTM_E6		(UTM_E4*UTM_E2)		// e^6
+#define UTM_EP2		(UTM_E2/(1-UTM_E2))	// e'^2
+
+/*************************************************************************/
+
+void LLH2UTM(double Lat, double Long, double H, geometry_msgs::PoseStamped& pose);
\ No newline at end of file
diff --git a/rubis_ws/src/gnss_converter/include/gnss_converter/gnss_converter.h b/rubis_ws/src/gnss_converter/include/gnss_converter/gnss_converter.h
new file mode 100644
index 00000000..410e74ad
--- /dev/null
+++ b/rubis_ws/src/gnss_converter/include/gnss_converter/gnss_converter.h
@@ -0,0 +1,70 @@
+#include <iostream>
+#include <angles/angles.h>
+#include <cmath>
+#include <vector>
+
+#include <ros/ros.h>
+#include <std_msgs/Header.h>
+#include <inertiallabs_msgs/gps_data.h>
+#include <inertiallabs_msgs/ins_data.h>
+#include <geometry_msgs/PoseStamped.h>
+#include <geometry_msgs/Quaternion.h>
+#include <geometry_msgs/Point.h>
+#include <geometry_msgs/Vector3.h>
+
+#include <eigen3/Eigen/Eigen>
+
+#include <tf/LinearMath/Quaternion.h>
+#include <tf/LinearMath/Transform.h>
+
+#include <message_filters/subscriber.h>
+#include <message_filters/time_synchronizer.h>
+#include <message_filters/sync_policies/approximate_time.h>
+#include <message_filters/sync_policies/exact_time.h>
+
+#include <opencv2/opencv.hpp>
+
+#include <unistd.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+
+using namespace std;
+using namespace message_filters;
+using namespace Eigen;
+
+#define ENTER_BUTTON 10
+#define ESC_BUTTON 27
+
+struct gps_stat
+{
+    std_msgs::Header header;
+    geometry_msgs::Point gps_pose;
+    geometry_msgs::Vector3 gps_ypr;
+    geometry_msgs::Point ndt_pose;
+    geometry_msgs::Vector3 ndt_ypr;
+    double ndt_score;
+};
+
+typedef sync_policies::ApproximateTime<inertiallabs_msgs::gps_data, inertiallabs_msgs::ins_data, geometry_msgs::PoseStamped> SyncPolicy_1;
+typedef sync_policies::ExactTime<inertiallabs_msgs::gps_data, inertiallabs_msgs::ins_data> SyncPolicy_2;
+
+static Matrix<double, 4, 4> pos_tf_, ori_tf_;
+
+static ros::Publisher gnss_pose_pub_;
+
+static vector<gps_stat> gps_backup_;
+static int ndt_pose_x_max_ = -9999999, ndt_pose_y_max_ = -9999999;
+static int ndt_pose_x_min_ = 9999999, ndt_pose_y_min_ = 9999999;
+static int scale_factor_ = 10;
+
+static int points_idx_;
+static gps_stat selected_points_[4];
+
+void gps_ndt_data_cb(const inertiallabs_msgs::gps_data::ConstPtr &msg_gps, const inertiallabs_msgs::ins_data::ConstPtr &msg_ins,
+                     const geometry_msgs::PoseStamped::ConstPtr &msg_ndt_pose);
+void pub_gnss_pose_cb(const inertiallabs_msgs::gps_data::ConstPtr &msg_gps, const inertiallabs_msgs::ins_data::ConstPtr &msg_ins);
+void track_bar_cb(int pos, void *userdata);
+void mouse_cb(int event, int x, int y, int flags, void *userdata);
+void points_select();
+void calculate_tf_matrix();
\ No newline at end of file
diff --git a/rubis_ws/src/gnss_converter/include/gnss_converter/quaternion_euler.h b/rubis_ws/src/gnss_converter/include/gnss_converter/quaternion_euler.h
new file mode 100644
index 00000000..50b0c39d
--- /dev/null
+++ b/rubis_ws/src/gnss_converter/include/gnss_converter/quaternion_euler.h
@@ -0,0 +1,7 @@
+#include <iostream>
+#include <cmath>
+
+#include <geometry_msgs/Quaternion.h>
+
+void ToEulerAngles(geometry_msgs::Quaternion q, double &yaw, double &pitch, double &roll);
+void ToQuaternion(double yaw, double pitch, double roll, geometry_msgs::Quaternion &q);
\ No newline at end of file
diff --git a/rubis_ws/src/gnss_converter/launch/gnss_converter.launch b/rubis_ws/src/gnss_converter/launch/gnss_converter.launch
new file mode 100644
index 00000000..658abfef
--- /dev/null
+++ b/rubis_ws/src/gnss_converter/launch/gnss_converter.launch
@@ -0,0 +1,4 @@
+<launch>
+    <rosparam file="$(find gnss_converter)/cfg/gnss_converter.yaml" />
+    <node pkg="gnss_converter" type="gnss_converter" name="gnss_converter" clear_params="true" output="screen" />
+</launch>
\ No newline at end of file
diff --git a/rubis_ws/src/gnss_converter/launch/gnss_pose_pub.launch b/rubis_ws/src/gnss_converter/launch/gnss_pose_pub.launch
new file mode 100644
index 00000000..8cdf1375
--- /dev/null
+++ b/rubis_ws/src/gnss_converter/launch/gnss_pose_pub.launch
@@ -0,0 +1,12 @@
+<launch>
+    <!-- 138ground offset -->
+    <!-- <arg name="x_offset" default="10011.0" />
+    <arg name="y_offset" default="12403.0" /> -->
+    
+    <arg name="x_offset" default="0.0" />
+    <arg name="y_offset" default="0.0" />
+    <node pkg="gnss_converter" type="gnss_pose_pub" name="gnss_pose_pub" output="screen">
+        <param name="x_offset" value="$(arg x_offset)"/>
+        <param name="y_offset" value="$(arg y_offset)"/>
+    </node>
+</launch>
\ No newline at end of file
diff --git a/rubis_ws/src/gnss_converter/package.xml b/rubis_ws/src/gnss_converter/package.xml
new file mode 100644
index 00000000..51cf2b79
--- /dev/null
+++ b/rubis_ws/src/gnss_converter/package.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0"?>
+<package format="2">
+  <name>gnss_converter</name>
+  <version>0.0.0</version>
+  <description>The gnss_converter package</description>
+
+  <maintainer email="sunhokim@todo.todo">sunhokim</maintainer>
+
+  <license>Apache 2</license>
+
+  <buildtool_depend>catkin</buildtool_depend>
+  <build_depend>roscpp</build_depend>
+  <build_depend>std_msgs</build_depend>
+  <build_export_depend>roscpp</build_export_depend>
+  <build_export_depend>std_msgs</build_export_depend>
+  <exec_depend>roscpp</exec_depend>
+  <exec_depend>std_msgs</exec_depend>
+  <depend>inertiallabs_msgs</depend>
+  <depend>message_filters</depend>
+  <depend>tf</depend>
+  <depend>eigen</depend>
+  <depend>libopencv-dev</depend>
+</package>
diff --git a/rubis_ws/src/gnss_converter/src/LLH2UTM.cpp b/rubis_ws/src/gnss_converter/src/LLH2UTM.cpp
new file mode 100644
index 00000000..a39d4698
--- /dev/null
+++ b/rubis_ws/src/gnss_converter/src/LLH2UTM.cpp
@@ -0,0 +1,54 @@
+#include <gnss_converter/LLH2UTM.h>
+
+void LLH2UTM(double Lat, double Long, double H, geometry_msgs::PoseStamped& pose){
+    double a = WGS84_A;
+    double eccSquared = UTM_E2;
+    double k0 = UTM_K0;
+    double LongOrigin;
+    double eccPrimeSquared;
+    double N, T, C, A, M;
+    // Make sure the longitude is between -180.00 .. 179.9
+    // (JOQ: this is broken for Long < -180, do a real normalize)
+    double LongTemp = (Long+180)-int((Long+180)/360)*360-180;
+    double LatRad = angles::from_degrees(Lat);
+    double LongRad = angles::from_degrees(LongTemp);
+    double LongOriginRad;
+    pose.pose.position.z = H;
+    // Fix Zone number with Korea
+    int zone = 52;
+    char band = 'S';
+    // +3 puts origin in middle of zone
+    LongOrigin = (zone - 1)*6 - 180 + 3;
+    LongOriginRad = angles::from_degrees(LongOrigin);
+    eccPrimeSquared = (eccSquared)/(1-eccSquared);
+    N = a/sqrt(1-eccSquared*sin(LatRad)*sin(LatRad));
+    T = tan(LatRad)*tan(LatRad);
+    C = eccPrimeSquared*cos(LatRad)*cos(LatRad);
+    A = cos(LatRad)*(LongRad-LongOriginRad);
+    M = a*((1 - eccSquared/4 - 3*eccSquared*eccSquared/64
+        - 5*eccSquared*eccSquared*eccSquared/256) * LatRad
+        - (3*eccSquared/8 + 3*eccSquared*eccSquared/32
+        + 45*eccSquared*eccSquared*eccSquared/1024)*sin(2*LatRad)
+        + (15*eccSquared*eccSquared/256
+        + 45*eccSquared*eccSquared*eccSquared/1024)*sin(4*LatRad)
+        - (35*eccSquared*eccSquared*eccSquared/3072)*sin(6*LatRad));
+    pose.pose.position.y = (double)
+    (k0*N*(A+(1-T+C)*A*A*A/6
+        + (5-18*T+T*T+72*C-58*eccPrimeSquared)*A*A*A*A*A/120)
+    + 500000.0);
+    pose.pose.position.x = (double)
+    (k0*(M+N*tan(LatRad)
+        *(A*A/2+(5-T+9*C+4*C*C)*A*A*A*A/24
+        + (61-58*T+T*T+600*C-330*eccPrimeSquared)*A*A*A*A*A*A/720)));
+    
+    double TM[4][4] = 
+    {{-0.821456, -0.593423, -0.006448, 3606301.475406},
+    {-0.596954, 0.803991, -0.096993, 2231713.639404},
+    {0.049875, 0.018177, -0.047063, -213252.081285},
+    {0.000000, 0.000000, 0.000000, 1.000000}};
+
+    double input[4] = {pose.pose.position.x, pose.pose.position.y, pose.pose.position.z, 1};
+    pose.pose.position.x = TM[0][0]*input[0] + TM[0][1]*input[1] + TM[0][2]*input[2] + TM[0][3]*input[3];
+    pose.pose.position.y = TM[1][0]*input[0] + TM[1][1]*input[1] + TM[1][2]*input[2] + TM[1][3]*input[3];
+    pose.pose.position.z = TM[2][0]*input[0] + TM[2][1]*input[1] + TM[2][2]*input[2] + TM[2][3]*input[3];    
+}
\ No newline at end of file
diff --git a/rubis_ws/src/gnss_converter/src/gnss_converter.cpp b/rubis_ws/src/gnss_converter/src/gnss_converter.cpp
new file mode 100644
index 00000000..964e49b6
--- /dev/null
+++ b/rubis_ws/src/gnss_converter/src/gnss_converter.cpp
@@ -0,0 +1,363 @@
+#include <gnss_converter/gnss_converter.h>
+#include <gnss_converter/LLH2UTM.h>
+#include <gnss_converter/quaternion_euler.h>
+
+void gps_ndt_data_cb(const inertiallabs_msgs::gps_data::ConstPtr &msg_gps, const inertiallabs_msgs::ins_data::ConstPtr &msg_ins,
+                     const geometry_msgs::PoseStamped::ConstPtr &msg_ndt_pose)
+{
+
+    geometry_msgs::PoseStamped cur_pose;
+
+    double ndt_yaw, ndt_pitch, ndt_roll;
+
+    LLH2UTM(msg_gps->LLH.x, msg_gps->LLH.y, msg_gps->LLH.z, cur_pose);
+
+    ToEulerAngles(msg_ndt_pose->pose.orientation, ndt_yaw, ndt_pitch, ndt_roll);
+
+    gps_stat tmp;
+    geometry_msgs::Vector3 vec_tmp;
+
+    tmp.header = msg_gps->header;
+
+    // gps position & orientation data
+    tmp.gps_pose = cur_pose.pose.position;
+    vec_tmp.x = ((msg_ins->YPR.x > 180) ? (msg_ins->YPR.x - 360) : (msg_ins->YPR.x)) / 180 * M_PI;
+    vec_tmp.y = ((msg_ins->YPR.y > 180) ? (msg_ins->YPR.y - 360) : (msg_ins->YPR.y)) / 180 * M_PI;
+    vec_tmp.z = ((msg_ins->YPR.z > 180) ? (msg_ins->YPR.z - 360) : (msg_ins->YPR.z)) / 180 * M_PI;
+    tmp.gps_ypr = vec_tmp;
+
+    // ndt position & orientation data
+    tmp.ndt_pose = msg_ndt_pose->pose.position;
+    vec_tmp.x = ndt_yaw;
+    vec_tmp.y = ndt_pitch;
+    vec_tmp.z = ndt_roll;
+    tmp.ndt_ypr = vec_tmp;
+
+    if (ndt_pose_x_max_ < msg_ndt_pose->pose.position.x)
+        ndt_pose_x_max_ = msg_ndt_pose->pose.position.x;
+
+    if (ndt_pose_x_min_ > msg_ndt_pose->pose.position.x)
+        ndt_pose_x_min_ = msg_ndt_pose->pose.position.x;
+
+    if (ndt_pose_y_max_ < msg_ndt_pose->pose.position.y)
+        ndt_pose_y_max_ = msg_ndt_pose->pose.position.y;
+
+    if (ndt_pose_y_min_ > msg_ndt_pose->pose.position.y)
+        ndt_pose_y_min_ = msg_ndt_pose->pose.position.y;
+
+    gps_backup_.push_back(tmp);
+}
+
+void pub_gnss_pose_cb(const inertiallabs_msgs::gps_data::ConstPtr &msg_gps, const inertiallabs_msgs::ins_data::ConstPtr &msg_ins)
+{
+    geometry_msgs::PoseStamped cur_pose;
+
+    cur_pose.header = msg_ins->header;
+    cur_pose.header.frame_id = "/map";
+
+    Matrix<double, 4, 1> gps;
+    Matrix<double, 4, 1> ndt;
+
+    /*================= position calculation =================*/
+    LLH2UTM(msg_gps->LLH.x, msg_gps->LLH.y, msg_gps->LLH.z, cur_pose);
+
+    gps(0, 0) = cur_pose.pose.position.x;
+    gps(1, 0) = cur_pose.pose.position.y;
+    gps(2, 0) = cur_pose.pose.position.z;
+    gps(3, 0) = 1.0;
+
+    ndt = pos_tf_ * gps;
+
+    cur_pose.pose.position.x = ndt(0, 0);
+    cur_pose.pose.position.y = ndt(1, 0);
+    cur_pose.pose.position.z = ndt(2, 0);
+    /*=======================================================*/
+
+    /*=============== orientation calculation ===============*/
+    gps(0, 0) = ((msg_ins->YPR.x > 180) ? (msg_ins->YPR.x - 360) : (msg_ins->YPR.x)) / 180 * M_PI;
+    gps(1, 0) = ((msg_ins->YPR.y > 180) ? (msg_ins->YPR.y - 360) : (msg_ins->YPR.y)) / 180 * M_PI;
+    gps(2, 0) = ((msg_ins->YPR.z > 180) ? (msg_ins->YPR.z - 360) : (msg_ins->YPR.z)) / 180 * M_PI;
+    gps(3, 0) = 1.0;
+
+    ndt = ori_tf_ * gps;
+
+    ToQuaternion(ndt(0, 0), ndt(1, 0), ndt(2, 0), cur_pose.pose.orientation);
+
+    gnss_pose_pub_.publish(cur_pose);
+    /*=======================================================*/
+}
+
+void scale_image(int pos, void *userdata)
+{
+    scale_factor_ = ((pos < 1) ? (1) : (pos));
+}
+
+void mouse_cb(int event, int x, int y, int flags, void *userdata)
+{
+    if (event == cv::EVENT_RBUTTONDOWN)
+    {
+        double point_x = ndt_pose_x_min_ + x / scale_factor_;
+        double point_y = ndt_pose_y_min_ + y / scale_factor_;
+        double min_dist = 9999;
+        int idx;
+
+        for (int i = 0; i < gps_backup_.size(); i++)
+        {
+            if (pow((point_x - gps_backup_[i].ndt_pose.x), 2) + pow((point_y - gps_backup_[i].ndt_pose.y), 2) < pow(min_dist, 2))
+            {
+                idx = i;
+                min_dist = pow((point_x - gps_backup_[i].ndt_pose.x), 2) + pow((point_y - gps_backup_[i].ndt_pose.y), 2);
+            }
+        }
+
+        selected_points_[points_idx_] = gps_backup_[idx];
+        std::cout << "**************** Point INFO ****************" << std::endl;
+
+        std::cout << "GPS Pose" << std::endl;
+        std::cout << "    x : " << selected_points_[points_idx_].gps_pose.x << std::endl;
+        std::cout << "    y : " << selected_points_[points_idx_].gps_pose.y << std::endl;
+        std::cout << "    z : " << selected_points_[points_idx_].gps_pose.z << std::endl;
+
+        std::cout << "GPS YPR" << std::endl;
+        std::cout << "    yaw : " << selected_points_[points_idx_].gps_ypr.x / M_PI * 180 << std::endl;
+        std::cout << "    pitch : " << selected_points_[points_idx_].gps_ypr.y / M_PI * 180 << std::endl;
+        std::cout << "    roll : " << selected_points_[points_idx_].gps_ypr.z / M_PI * 180 << std::endl;
+
+        std::cout << "NDT Pose" << std::endl;
+        std::cout << "    x : " << selected_points_[points_idx_].ndt_pose.x << std::endl;
+        std::cout << "    y : " << selected_points_[points_idx_].ndt_pose.y << std::endl;
+        std::cout << "    z : " << selected_points_[points_idx_].ndt_pose.z << std::endl;
+
+        std::cout << "NDT YPR" << std::endl;
+        std::cout << "    yaw : " << selected_points_[points_idx_].ndt_ypr.x / M_PI * 180 << std::endl;
+        std::cout << "    pitch : " << selected_points_[points_idx_].ndt_ypr.y / M_PI * 180 << std::endl;
+        std::cout << "    roll : " << selected_points_[points_idx_].ndt_ypr.z / M_PI * 180 << std::endl;
+
+        std::cout << "NDT score" << selected_points_[points_idx_].ndt_score << std::endl;
+    }
+}
+
+void points_select()
+{
+    cv::Mat orig_img = cv::Mat((ndt_pose_y_max_ - ndt_pose_y_min_ + 1), (ndt_pose_x_max_ - ndt_pose_x_min_ + 1), CV_8UC3, cv::Scalar(255, 255, 255));
+    cv::Mat display_img;
+
+    for (int i = 0; i < gps_backup_.size(); i++)
+    {
+        cv::circle(orig_img, cv::Point((gps_backup_[i].ndt_pose.x - ndt_pose_x_min_), (gps_backup_[i].ndt_pose.y - ndt_pose_y_min_)),
+                   1, cv::Scalar(255, 255, 0), 1, cv::LINE_AA);
+    }
+
+    orig_img.copyTo(display_img);
+
+    cv::namedWindow("Display Image");
+    cv::createTrackbar("Scale", "Display Image", &scale_factor_, 100, scale_image, NULL);
+
+    cv::setMouseCallback("Display Image", mouse_cb, NULL);
+
+    std::cout << "**************** How To Use ****************" << std::endl;
+    std::cout << "If you want to end, press the ESC button." << std::endl;
+    std::cout << "If you want to choose a point, press the number and click the point in the image." << std::endl;
+    std::cout << "To change the image size, use track bar to select a value and press enter." << std::endl;
+    std::cout << "********************************************" << std::endl;
+
+    int keycode;
+    while (true)
+    {
+        display_img = cv::Mat(orig_img.rows * scale_factor_, orig_img.cols * scale_factor_, CV_8UC3, cv::Scalar(255, 255, 255));
+        for (int i = 0; i < gps_backup_.size(); i++)
+        {
+            cv::circle(display_img,
+                       cv::Point(scale_factor_ * (gps_backup_[i].ndt_pose.x - ndt_pose_x_min_), scale_factor_ * (gps_backup_[i].ndt_pose.y - ndt_pose_y_min_)),
+                       1, cv::Scalar(255, 255, 0), 1, cv::LINE_AA);
+        }
+
+        cv::imshow("Display Image", display_img);
+        keycode = cv::waitKey();
+
+        if (keycode == ESC_BUTTON)
+            break;
+
+        switch (keycode)
+        {
+        case '1':
+            points_idx_ = 0;
+            std::cout << "Point Number : 1" << std::endl;
+            break;
+        case '2':
+            points_idx_ = 1;
+            std::cout << "Point Number : 2" << std::endl;
+            break;
+        case '3':
+            points_idx_ = 2;
+            std::cout << "Point Number : 3" << std::endl;
+            break;
+        case '4':
+            points_idx_ = 3;
+            std::cout << "Point Number : 4" << std::endl;
+            break;
+        case ENTER_BUTTON:
+            break;
+        default:
+            std::cout << "Unknown keyboard input" << std::endl;
+            break;
+        }
+    }
+}
+
+void calculate_tf_matrix()
+{
+    Matrix<double, 4, 4> gps_pos, ndt_pos, gps_ypr, ndt_ypr;
+
+    for (int i = 0; i < 4; i++)
+    {
+        gps_pos(0, i) = selected_points_[i].gps_pose.x;
+        gps_pos(1, i) = selected_points_[i].gps_pose.y;
+        gps_pos(2, i) = selected_points_[i].gps_pose.z;
+        gps_pos(3, i) = 1.0;
+
+        ndt_pos(0, i) = selected_points_[i].ndt_pose.x;
+        ndt_pos(1, i) = selected_points_[i].ndt_pose.y;
+        ndt_pos(2, i) = selected_points_[i].ndt_pose.z;
+        ndt_pos(3, i) = 1.0;
+
+        gps_ypr(0, i) = selected_points_[i].gps_ypr.x;
+        gps_ypr(1, i) = selected_points_[i].gps_ypr.y;
+        gps_ypr(2, i) = selected_points_[i].gps_ypr.z;
+        gps_ypr(3, i) = 1.0;
+
+        ndt_ypr(0, i) = selected_points_[i].ndt_ypr.x;
+        ndt_ypr(1, i) = selected_points_[i].ndt_ypr.y;
+        ndt_ypr(2, i) = selected_points_[i].ndt_ypr.z;
+        ndt_ypr(3, i) = 1.0;
+    }
+
+    pos_tf_ = ndt_pos * gps_pos.inverse();
+    ori_tf_ = ndt_ypr * gps_ypr.inverse();
+
+    printf("========== position tf matrix ==========\n");
+    printf("[%lf, %lf, %lf, %lf, %lf, %lf, %lf, %lf, %lf, %lf, %lf, %lf, %lf, %lf, %lf, %lf]\n", pos_tf_(0, 0), pos_tf_(0, 1), pos_tf_(0, 2), pos_tf_(0, 3), pos_tf_(1, 0), pos_tf_(1, 1), pos_tf_(1, 2), pos_tf_(1, 3), pos_tf_(2, 0), pos_tf_(2, 1), pos_tf_(2, 2), pos_tf_(2, 3), pos_tf_(3, 0), pos_tf_(3, 1), pos_tf_(3, 2), pos_tf_(3, 3));
+    printf("======== orientation tf matrix =========\n");
+    printf("[%lf, %lf, %lf, %lf, %lf, %lf, %lf, %lf, %lf, %lf, %lf, %lf, %lf, %lf, %lf, %lf]\n", ori_tf_(0, 0), ori_tf_(0, 1), ori_tf_(0, 2), ori_tf_(0, 3), ori_tf_(1, 0), ori_tf_(1, 1), ori_tf_(1, 2), ori_tf_(1, 3), ori_tf_(2, 0), ori_tf_(2, 1), ori_tf_(2, 2), ori_tf_(2, 3), ori_tf_(3, 0), ori_tf_(3, 1), ori_tf_(3, 2), ori_tf_(3, 3));
+}
+
+int main(int argc, char *argv[])
+{
+    ros::init(argc, argv, "gnss_converter");
+
+    ros::NodeHandle nh;
+
+    bool calculate_tf;
+
+    gnss_pose_pub_ = nh.advertise<geometry_msgs::PoseStamped>("/gnss_pose", 10);
+
+    message_filters::Subscriber<inertiallabs_msgs::gps_data> gps_sub(nh, "/Inertial_Labs/gps_data", 10);
+    message_filters::Subscriber<geometry_msgs::PoseStamped> ndt_pose_sub(nh, "/ndt_pose", 10);
+    message_filters::Subscriber<inertiallabs_msgs::ins_data> ins_sub(nh, "/Inertial_Labs/ins_data", 10);
+
+    Synchronizer<SyncPolicy_1> sync_1(SyncPolicy_1(100), gps_sub, ins_sub, ndt_pose_sub);
+    Synchronizer<SyncPolicy_2> sync_2(SyncPolicy_2(10), gps_sub, ins_sub);
+
+    ros::param::get("/gnss_converter/calculate_tf", calculate_tf);
+
+    if (calculate_tf)
+    {
+        sync_1.registerCallback(boost::bind(&gps_ndt_data_cb, _1, _2, _3));
+
+        pid_t pid;
+        if ((pid = fork()) < 0)
+            ROS_ERROR("Cannot create child!");
+
+        if (pid == 0)
+        {
+            std::string file_path;
+            char file_path_cstr[150];
+
+            ros::param::get("/gnss_converter/bag_file_path", file_path);
+
+            int str_len = file_path.length();
+            if (str_len >= 150)
+            {
+                ROS_ERROR("File path is too long!!");
+                exit(0);
+            }
+
+            strcpy(file_path_cstr, file_path.c_str());
+
+            const char *file = "/opt/ros/melodic/bin/rosbag";
+            char *exe_argv[] = {"/opt/ros/melodic/bin/rosbag",
+                                "play",
+                                "-r",
+                                "5",
+                                file_path_cstr,
+                                NULL};
+
+            if (execvp(file, exe_argv) < 0)
+            {
+                ROS_ERROR("Cannot load bag file!!");
+            }
+        }
+        else
+        {
+            int wstatus;
+            while (waitpid(pid, &wstatus, WNOHANG) == 0)
+            {
+                ros::spinOnce();
+            }
+            ROS_WARN("Finish loading data from rosbag file!!");
+            points_select();
+            calculate_tf_matrix();
+        }
+    }
+
+    else
+    {
+        sync_2.registerCallback(boost::bind(&pub_gnss_pose_cb, _1, _2));
+
+        vector<double> tf_tmp;
+
+        /*================= pos_tf_ matrix =================*/
+        ros::param::get("/gnss_converter/pos_tf", tf_tmp);
+        pos_tf_(0, 0) = tf_tmp[0];
+        pos_tf_(0, 1) = tf_tmp[1];
+        pos_tf_(0, 2) = tf_tmp[2];
+        pos_tf_(0, 3) = tf_tmp[3];
+        pos_tf_(1, 0) = tf_tmp[4];
+        pos_tf_(1, 1) = tf_tmp[5];
+        pos_tf_(1, 2) = tf_tmp[6];
+        pos_tf_(1, 3) = tf_tmp[7];
+        pos_tf_(2, 0) = tf_tmp[8];
+        pos_tf_(2, 1) = tf_tmp[9];
+        pos_tf_(2, 2) = tf_tmp[10];
+        pos_tf_(2, 3) = tf_tmp[11];
+        pos_tf_(3, 0) = tf_tmp[12];
+        pos_tf_(3, 1) = tf_tmp[13];
+        pos_tf_(3, 2) = tf_tmp[14];
+        pos_tf_(3, 3) = tf_tmp[15];
+        /*=================================================*/
+
+        /*================= ori_tf_ matrix =================*/
+        ros::param::get("/gnss_converter/ori_tf", tf_tmp);
+        ori_tf_(0, 0) = tf_tmp[0];
+        ori_tf_(0, 1) = tf_tmp[1];
+        ori_tf_(0, 2) = tf_tmp[2];
+        ori_tf_(0, 3) = tf_tmp[3];
+        ori_tf_(1, 0) = tf_tmp[4];
+        ori_tf_(1, 1) = tf_tmp[5];
+        ori_tf_(1, 2) = tf_tmp[6];
+        ori_tf_(1, 3) = tf_tmp[7];
+        ori_tf_(2, 0) = tf_tmp[8];
+        ori_tf_(2, 1) = tf_tmp[9];
+        ori_tf_(2, 2) = tf_tmp[10];
+        ori_tf_(2, 3) = tf_tmp[11];
+        ori_tf_(3, 0) = tf_tmp[12];
+        ori_tf_(3, 1) = tf_tmp[13];
+        ori_tf_(3, 2) = tf_tmp[14];
+        ori_tf_(3, 3) = tf_tmp[15];
+        /*================================================*/
+
+        ros::spin();
+    }
+
+    return 0;
+}
\ No newline at end of file
diff --git a/rubis_ws/src/gnss_converter/src/gnss_pose_pub.cpp b/rubis_ws/src/gnss_converter/src/gnss_pose_pub.cpp
new file mode 100644
index 00000000..ad248edd
--- /dev/null
+++ b/rubis_ws/src/gnss_converter/src/gnss_pose_pub.cpp
@@ -0,0 +1,91 @@
+#include <gnss_converter/LLH2UTM.h>
+#include <gnss_converter/quaternion_euler.h>
+
+#include <geometry_msgs/PoseStamped.h>
+#include <inertiallabs_msgs/gps_data.h>
+#include <inertiallabs_msgs/ins_data.h>
+
+#include <message_filters/subscriber.h>
+#include <message_filters/time_synchronizer.h>
+#include <message_filters/sync_policies/approximate_time.h>
+#include <message_filters/sync_policies/exact_time.h>
+
+#include <tf/tf.h>
+#include <tf/transform_broadcaster.h>
+#include <tf/transform_datatypes.h>
+#include <tf/transform_listener.h>
+
+#define M_PI 3.14159265358979323846
+
+using namespace std;
+using namespace message_filters;
+
+typedef sync_policies::ExactTime<inertiallabs_msgs::gps_data, inertiallabs_msgs::ins_data> SyncPolicy_;
+
+static ros::Publisher gnss_pose_pub_;
+static double x_offset_, y_offset_, yaw_offset_;
+static double roll_, pitch_, yaw_;
+static geometry_msgs::PoseStamped gnss_pose_;
+
+void gnss_pose_pub_cb(const inertiallabs_msgs::gps_data::ConstPtr &msg_gps, const inertiallabs_msgs::ins_data::ConstPtr &msg_ins){
+    gnss_pose_.header = msg_gps->header;
+    gnss_pose_.header.frame_id = "/map";
+
+    LLH2UTM(msg_gps->LLH.x, msg_gps->LLH.y, msg_gps->LLH.z, gnss_pose_);
+
+    gnss_pose_.pose.position.x = gnss_pose_.pose.position.x - x_offset_;
+    gnss_pose_.pose.position.y = gnss_pose_.pose.position.y - y_offset_;
+
+    roll_ = msg_ins->YPR.z;
+    pitch_ = msg_ins->YPR.y;
+    
+    yaw_ = msg_ins->YPR.x;
+    yaw_ *= -1;
+    yaw_ -= yaw_offset_;
+    if(yaw_ > 180.0) yaw_ -= 360.0;
+    if(yaw_ < -180.0) yaw_ += 360.0;
+
+    roll_ = roll_ * M_PI/180.0;
+    pitch_ = pitch_ * M_PI/180.0;
+    yaw_ = yaw_ * M_PI/180.0;
+}
+
+int main(int argc, char *argv[]){
+    ros::init(argc, argv, "gnss_pose_pub");
+
+    ros::NodeHandle nh;
+
+    nh.param("/gnss_pose_pub/x_offset", x_offset_, 0.0);
+    nh.param("/gnss_pose_pub/y_offset", y_offset_, 0.0);
+    nh.param("/ins_twist_generator/yaw_offset", yaw_offset_, 0.0);
+
+    gnss_pose_pub_ = nh.advertise<geometry_msgs::PoseStamped>("/ndt_pose", 2);
+
+    message_filters::Subscriber<inertiallabs_msgs::gps_data> gps_sub(nh, "/Inertial_Labs/gps_data", 2);
+    message_filters::Subscriber<inertiallabs_msgs::ins_data> ins_sub(nh, "/Inertial_Labs/ins_data", 2);
+    
+    Synchronizer<SyncPolicy_> sync(SyncPolicy_(2), gps_sub, ins_sub);
+
+    sync.registerCallback(boost::bind(&gnss_pose_pub_cb, _1, _2));
+
+    tf::TransformBroadcaster br;
+    ros::Rate r(10);
+    while(nh.ok()){
+        ros::spinOnce();
+
+        ToQuaternion(yaw_, pitch_, roll_, gnss_pose_.pose.orientation);
+
+        tf::Quaternion q;
+        q.setRPY(roll_, pitch_, yaw_);
+
+        tf::StampedTransform transform;
+        transform.setOrigin(tf::Vector3(gnss_pose_.pose.position.x, gnss_pose_.pose.position.y, 0.0));
+        transform.setRotation(q);
+        br.sendTransform(tf::StampedTransform(transform, ros::Time::now(), "/map", "/base_link"));
+
+        gnss_pose_pub_.publish(gnss_pose_); 
+
+
+        r.sleep();
+    }
+}
\ No newline at end of file
diff --git a/rubis_ws/src/gnss_converter/src/quaternion_euler.cpp b/rubis_ws/src/gnss_converter/src/quaternion_euler.cpp
new file mode 100644
index 00000000..158c979b
--- /dev/null
+++ b/rubis_ws/src/gnss_converter/src/quaternion_euler.cpp
@@ -0,0 +1,32 @@
+#include <gnss_converter/quaternion_euler.h>
+
+void ToEulerAngles(geometry_msgs::Quaternion q, double &yaw, double &pitch, double &roll){
+    double sinr_cosp = 2 * (q.w * q.x + q.y * q.z);
+    double cosr_cosp = 1 - 2 * (q.x * q.x + q.y * q.y);
+    roll = std::atan2(sinr_cosp, cosr_cosp);
+
+    double sinp = 2 * (q.w * q.y - q.z * q.x);
+    if (std::abs(sinp) >= 1)
+        pitch = std::copysign(M_PI / 2, sinp); // use 90 degrees if out of range
+    else
+        pitch = std::asin(sinp);
+
+    double siny_cosp = 2 * (q.w * q.z + q.x * q.y);
+    double cosy_cosp = 1 - 2 * (q.y * q.y + q.z * q.z);
+    yaw = std::atan2(siny_cosp, cosy_cosp);
+}
+
+void ToQuaternion(double yaw, double pitch, double roll, geometry_msgs::Quaternion &q)
+{
+    double cy = cos(yaw * 0.5);
+    double sy = sin(yaw * 0.5);
+    double cp = cos(pitch * 0.5);
+    double sp = sin(pitch * 0.5);
+    double cr = cos(roll * 0.5);
+    double sr = sin(roll * 0.5);
+
+    q.w = cr * cp * cy + sr * sp * sy;
+    q.x = sr * cp * cy - cr * sp * sy;
+    q.y = cr * sp * cy + sr * cp * sy;
+    q.z = cr * cp * sy - sr * sp * cy;
+}
\ No newline at end of file
diff --git a/rubis_ws/src/image_common/image_transport/src/republish.cpp b/rubis_ws/src/image_common/image_transport/src/republish.cpp
index 589e351a..2a8140d6 100644
--- a/rubis_ws/src/image_common/image_transport/src/republish.cpp
+++ b/rubis_ws/src/image_common/image_transport/src/republish.cpp
@@ -54,23 +54,19 @@ int main(int argc, char** argv)
 
   // scheduling
   ros::NodeHandle pnh("~");
-  int task_scheduling_flag = 0;
-  int task_profiling_flag = 0;
   std::string task_response_time_filename;
   int rate = 0;
   double task_minimum_inter_release_time = 0;
   double task_execution_time = 0;
   double task_relative_deadline = 0;
 
-  pnh.param<int>("/republish/task_scheduling_flag", task_scheduling_flag, 0);
-  pnh.param<int>("/republish/task_profiling_flag", task_profiling_flag, 0);
   pnh.param<std::string>("/republish/task_response_time_filename", task_response_time_filename, "~/Documents/profiling/response_time/republish.csv");
   pnh.param<int>("/republish/rate", rate, 10);
   pnh.param("/republish/task_minimum_inter_release_time", task_minimum_inter_release_time, (double)100000000);
   pnh.param("/republish/task_execution_time", task_execution_time, (double)100000000);
   pnh.param("/republish/task_relative_deadline", task_relative_deadline, (double)100000000);
   
-  if(task_profiling_flag) rubis::sched::init_task_profiling(task_response_time_filename);
+  rubis::init_task_profiling(task_response_time_filename);
 
   if (argc < 3) {
     // Use all available transports for output
@@ -81,34 +77,17 @@ int main(int argc, char** argv)
     PublishMemFn pub_mem_fn = &image_transport::Publisher::publish;
     sub = it.subscribe(in_topic, 1, boost::bind(pub_mem_fn, &pub, _1), ros::VoidPtr(), in_transport);
 
-    rubis::sched::task_state_ = TASK_STATE_READY;
+    ros::Rate r(rate);
+    // Executing task
+    while(ros::ok()){
+      rubis::start_task_profiling();
 
-    if(!task_scheduling_flag && !task_profiling_flag){
-      ros::spin();
-    }
-    else{
-      ros::Rate r(rate);
-      // Executing task
-      while(ros::ok()){
-        if(task_profiling_flag) rubis::sched::start_task_profiling();
-
-        if(rubis::sched::task_state_ == TASK_STATE_READY){          
-          if(task_scheduling_flag) rubis::sched::request_task_scheduling(task_minimum_inter_release_time, task_execution_time, task_relative_deadline); 
-          rubis::sched::task_state_ = TASK_STATE_RUNNING;     
-        }
+      ros::spinOnce();
+      
 
-        ros::spinOnce();
-        rubis::sched::task_state_ = TASK_STATE_DONE;
+      rubis::stop_task_profiling(0, 0);
 
-        if(task_profiling_flag) rubis::sched::stop_task_profiling(0, rubis::sched::task_state_);
-
-        if(rubis::sched::task_state_ == TASK_STATE_DONE){          
-          if(task_scheduling_flag) rubis::sched::yield_task_scheduling();
-          rubis::sched::task_state_ = TASK_STATE_READY;
-        }
-        
-        r.sleep();
-      }
+      r.sleep();
     }
   }
   else {
@@ -128,32 +107,14 @@ int main(int argc, char** argv)
     PublishMemFn pub_mem_fn = &Plugin::publish;
     sub = it.subscribe(in_topic, 1, boost::bind(pub_mem_fn, pub.get(), _1), pub, in_transport);
 
-    if(!task_scheduling_flag && !task_profiling_flag){
-      ros::spin();
-    }
-    else{      
-      ros::Rate r(rate);
-      // Executing task      
-      while(ros::ok()){
-        if(task_profiling_flag) rubis::sched::start_task_profiling();
-
-        if(rubis::sched::task_state_ == TASK_STATE_READY){          
-          if(task_scheduling_flag) rubis::sched::request_task_scheduling(task_minimum_inter_release_time, task_execution_time, task_relative_deadline); 
-          rubis::sched::task_state_ = TASK_STATE_RUNNING;     
-        }
-
-        ros::spinOnce();
-        rubis::sched::task_state_ = TASK_STATE_DONE;
-
-        if(task_profiling_flag) rubis::sched::stop_task_profiling(0, rubis::sched::task_state_);
-
-        if(rubis::sched::task_state_ == TASK_STATE_DONE){          
-          if(task_scheduling_flag) rubis::sched::yield_task_scheduling();
-          rubis::sched::task_state_ = TASK_STATE_READY;
-        }
-        
-        r.sleep();
-      }
+    ros::Rate r(rate);
+    // Executing task      
+    while(ros::ok()){
+      rubis::start_task_profiling();
+      ros::spinOnce();
+      
+      rubis::stop_task_profiling(0, 0);
+      r.sleep();
     }
   }
 
diff --git a/rubis_ws/src/inertiallabs_pkgs/inertiallabs_ins/CMakeLists.txt b/rubis_ws/src/inertiallabs_pkgs/inertiallabs_ins/CMakeLists.txt
index 66aa1a13..bf1bf2a9 100644
--- a/rubis_ws/src/inertiallabs_pkgs/inertiallabs_ins/CMakeLists.txt
+++ b/rubis_ws/src/inertiallabs_pkgs/inertiallabs_ins/CMakeLists.txt
@@ -15,7 +15,6 @@ inertiallabs_msgs
 
 include_directories(${catkin_INCLUDE_DIRS})
 
-find_package(OpenCV)
 
 set(DEPRECATION_FLAG "-Wsizeof-array-argument")
 set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11 -Wall -Wextra ${DEPRECATION_FLAG}")
@@ -26,7 +25,6 @@ catkin_package(
   DEPENDS system_lib
 )
 
-include_directories(${Opencv_INCLUDE_DIRS})
 include_directories(${system_lib_INCLUDE_DIRS})
 
 include_directories(../inertiallabs_sdk/)
diff --git a/rubis_ws/src/ros-bridge/carla_ackermann_control/config/settings.yaml b/rubis_ws/src/ros-bridge/carla_ackermann_control/config/settings.yaml
index c49e3f72..40654dad 100755
--- a/rubis_ws/src/ros-bridge/carla_ackermann_control/config/settings.yaml
+++ b/rubis_ws/src/ros-bridge/carla_ackermann_control/config/settings.yaml
@@ -15,4 +15,4 @@ carla_ackermann_control:
     # at more or less constant speed.
     # If the absolute value of the ackermann drive target acceleration exceeds this value,
     # directly the input acceleration is controlled 
-    min_accel: 1.0
+    min_accel: 0.005
diff --git a/rubis_ws/src/ros-bridge/carla_ackermann_control/config/settings.yaml.backup b/rubis_ws/src/ros-bridge/carla_ackermann_control/config/settings.yaml.backup
new file mode 100755
index 00000000..c49e3f72
--- /dev/null
+++ b/rubis_ws/src/ros-bridge/carla_ackermann_control/config/settings.yaml.backup
@@ -0,0 +1,18 @@
+carla_ackermann_control:
+  ros__parameters:
+    # override the default values of the pid speed controller
+    # (only relevant for ackermann control mode) 
+    speed_Kp: 0.05  # min: 0, max: 1.
+    speed_Ki: 0.00  # min: 0, max: 1.
+    speed_Kd: 0.50  # min: 0, max: 10. 
+    # override the default values of the pid acceleration controller
+    # (only relevant for ackermann control mode)
+    accel_Kp: 0.05  # min: 0, max: 10.
+    accel_Ki: 0.00  # min: 0, max: 10.
+    accel_Kd: 0.05  # min: 0, max: 10.
+    # set the minimum acceleration in (m/s^2)
+    # This border value is used to enable the speed controller which is used to control driving 
+    # at more or less constant speed.
+    # If the absolute value of the ackermann drive target acceleration exceeds this value,
+    # directly the input acceleration is controlled 
+    min_accel: 1.0
diff --git a/rubis_ws/src/ros-bridge/carla_ackermann_control/src/carla_ackermann_control/carla_ackermann_control_node.py b/rubis_ws/src/ros-bridge/carla_ackermann_control/src/carla_ackermann_control/carla_ackermann_control_node.py
index 944f70fd..c8d29c00 100755
--- a/rubis_ws/src/ros-bridge/carla_ackermann_control/src/carla_ackermann_control/carla_ackermann_control_node.py
+++ b/rubis_ws/src/ros-bridge/carla_ackermann_control/src/carla_ackermann_control/carla_ackermann_control_node.py
@@ -442,6 +442,7 @@ class CarlaAckermannControl(CompatibleNode):
         else:
             if self.info.status.speed_control_activation_count > 0:
                 self.info.status.speed_control_activation_count -= 1
+        
         # set the auto_mode of the controller accordingly
         self.speed_controller.auto_mode = self.info.status.speed_control_activation_count >= 5
 
diff --git a/rubis_ws/src/ros-bridge/carla_spawn_objects/config/objects.json b/rubis_ws/src/ros-bridge/carla_spawn_objects/config/objects.json
index 9aef8118..d31f2c9f 100755
--- a/rubis_ws/src/ros-bridge/carla_spawn_objects/config/objects.json
+++ b/rubis_ws/src/ros-bridge/carla_spawn_objects/config/objects.json
@@ -55,13 +55,14 @@
                     "type": "sensor.lidar.ray_cast",
                     "id": "lidar",
                     "spawn_point": {"x": 0.0, "y": 0.0, "z": 2.4, "roll": 0.0, "pitch": 0.0, "yaw": 0.0},
-                    "range": 50,
-                    "channels": 32,
+                    "range": 100,
+                    "channels": 16,
                     "points_per_second": 320000,
                     "upper_fov": 2.0,
                     "lower_fov": -26.8,
                     "rotation_frequency": 20,
-                    "noise_stddev": 0.0
+                    "noise_stddev": 0.0,
+                    "sensor_tick": 0.1
                 },
                 {
                     "type": "sensor.other.gnss",
diff --git a/rubis_ws/src/rubis_autorunner/CMakeLists.txt b/rubis_ws/src/rubis_autorunner/CMakeLists.txt
index 4932f0b1..be91e751 100644
--- a/rubis_ws/src/rubis_autorunner/CMakeLists.txt
+++ b/rubis_ws/src/rubis_autorunner/CMakeLists.txt
@@ -48,6 +48,18 @@ add_executable(minicar_lane_keeping
   src/minicar_lane_keeping/minicar_lane_keeping.cpp
 )
   
+add_executable(carla_lkas_autorunner
+  include/carla_autorunner/carla_autorunner.h
+  src/carla_autorunner/carla_lkas_autorunner_node.cpp
+  src/carla_autorunner/carla_lkas_autorunner.cpp
+)
+
+add_executable(carla_full_autorunner
+  include/carla_autorunner/carla_autorunner.h
+  src/carla_autorunner/carla_full_autorunner_node.cpp
+  src/carla_autorunner/carla_full_autorunner.cpp
+)
+
 add_executable(cubetown_lkas_autorunner
   include/cubetown_autorunner/cubetown_autorunner.h
   src/cubetown_autorunner/cubetown_lkas_autorunner_node.cpp
@@ -102,6 +114,19 @@ target_link_libraries(cubetown_full_autorunner
   ros_autorunner_lib
 )
 
+add_dependencies(carla_lkas_autorunner ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})
+target_link_libraries(carla_lkas_autorunner
+  ${catkin_LIBRARIES}
+  ros_autorunner_lib
+)
+
+add_dependencies(carla_full_autorunner ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})
+target_link_libraries(carla_full_autorunner
+  ${catkin_LIBRARIES}
+  ros_autorunner_lib
+)
+
+
 add_dependencies(tutorial_autorunner ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})
 target_link_libraries(tutorial_autorunner
   ${catkin_LIBRARIES}
diff --git a/rubis_ws/src/rubis_autorunner/cfg/carla_autorunner/carla_autorunner_params.yaml b/rubis_ws/src/rubis_autorunner/cfg/carla_autorunner/carla_autorunner_params.yaml
new file mode 100644
index 00000000..feb87474
--- /dev/null
+++ b/rubis_ws/src/rubis_autorunner/cfg/carla_autorunner/carla_autorunner_params.yaml
@@ -0,0 +1,183 @@
+# Unit of rate: hz
+# Unit of scheduling params: ns
+
+# 1s  : 1_000_000_000
+# 1ms : 1_000_000
+# 1us : 1_000
+# 1ns : 1
+
+#rate = hz
+# other time unut = ns
+
+# Lane Keeping
+lidar_republisher:
+  rate: 10
+  task_scheduling_configs:
+    policy: "NONE"
+    priority: 99
+    exec_time: 1_000_000
+    deadline: 2_000_000
+    period: 2_000_000
+  task_response_time_filename: "~/Documents/profiling/response_time/lidar_republisher.csv"  
+
+voxel_grid_filter:
+  rate: 10
+  task_scheduling_configs:
+    policy: "NONE"
+    priority: 99
+    exec_time: 0 # ns
+    deadline: 0 # ns
+    period: 0 # ns
+  task_response_time_filename: "~/Documents/profiling/response_time/voxel_grid_filter.csv"  
+
+ndt_matching:
+  rate: 10
+  task_scheduling_configs:
+    policy: "NONE"
+    priority: 20
+    exec_time: 0 # ns
+    deadline: 0 # ns
+    period: 0 # ns
+  task_response_time_filename: "~/Documents/profiling/response_time/ndt_matching.csv"
+  
+  use_kalman_filter: False
+  tf_x: 1.0510799 
+  tf_y: 0
+  tf_z: 1.96
+  tf_roll: 0
+  tf_pitch: 0
+  tf_yaw: 0
+  localizer: "velodyne"
+
+pure_pursuit:
+  rate: 30 #30
+  task_scheduling_configs:
+    policy: "NONE"
+    priority: 20
+    exec_time: 0 # ns
+    deadline: 0 # ns
+    period: 0 # ns  
+  task_response_time_filename: "~/Documents/profiling/response_time/pure_pursuit.csv"  
+
+  dynamic_params_flag: False
+  dynamic_params_path: "~/autoware.ai/autoware_files/lgsvl_file/parameter/lgsvl_pure_pursuit.yaml"
+
+twist_filter:
+  rate: 10
+  task_scheduling_configs:
+    policy: "NONE"
+    priority: 20
+    exec_time: 0 # ns
+    deadline: 0 # ns
+    period: 0 # ns
+  task_response_time_filename: "~/Documents/profiling/response_time/twist_filter.csv"
+
+# Detection
+ray_ground_filter_center:
+  rate: 10 
+  task_scheduling_configs:
+    policy: "NONE"
+    priority: 20
+    exec_time: 0 # ns
+    deadline: 0 # ns
+    period: 0 # ns
+  task_response_time_filename: "~/Documents/profiling/response_time/ray_ground_filter.csv"
+
+lidar_euclidean_cluster_detect:
+  rate: 10
+  task_scheduling_configs:
+    policy: "NONE"
+    priority: 20
+    exec_time: 0 # ns
+    deadline: 0 # ns
+    period: 0 # ns
+  task_response_time_filename: "~/Documents/profiling/response_time/lidar_euclidean_cluster_detect.csv"
+
+  network_definition_file: "~/autoware.ai/autoware_files/vision/yolov3-320.cfg"
+  pretrained_model_file: "~/autoware.ai/autoware_files/vision/yolov3-320.weights"
+
+# Planning
+op_global_planner:
+  rate: 25 #25
+  task_scheduling_configs:
+    policy: "NONE"
+    priority: 20
+    exec_time: 0 # ns
+    deadline: 0 # ns
+    period: 0 # ns
+  task_response_time_filename: "~/Documents/profiling/response_time/op_global_planner.csv"
+
+  multilap_flag: 1
+
+op_common_params:
+  rollOutDensity: 4
+  rollOutsNumber: 2
+  maxVelocity: 10.0
+  maxAcceleration: 10.0
+  maxDeceleration: -10.0
+
+op_trajectory_generator:
+  rate: 100 #100
+  task_scheduling_configs:
+    policy: "NONE"
+    priority: 20
+    exec_time: 0 # ns
+    deadline: 0 # ns
+    period: 0 # ns
+  task_response_time_filename: "~/Documents/profiling/response_time/op_trajectory_generator.csv"
+
+op_trajectory_evaluator:
+  rate: 100 #100
+  task_scheduling_configs:
+    policy: "NONE"
+    priority: 20
+    exec_time: 0 # ns
+    deadline: 0 # ns
+    period: 0 # ns
+  task_response_time_filename: "~/Documents/profiling/response_time/op_trajectory_evaluator.csv"
+
+  weightPriority: 1
+  weightTransition: 0.5
+  weightLong: 1
+  weightLat: 1
+  ImageWidth: 1920
+  ImageHeight: 1080
+  SprintDecisionTime: 9999999.0
+
+op_behavior_selector:
+  rate: 100 #100
+  task_scheduling_configs:
+    policy: "NONE"
+    priority: 20
+    exec_time: 0 # ns
+    deadline: 0 # ns
+    period: 0 # ns
+  task_response_time_filename: "~/Documents/profiling/response_time/op_behavior_selector.csv"
+
+  distanceToPedestrianThreshold: 15.0
+  sprintSpeed: 10.0
+  obstacleWaitingTimeinIntersection: 2.0
+  turnThreshold: 30.0
+
+op_motion_predictor:
+  rate: 25 #25
+  task_scheduling_configs:
+    policy: "NONE"
+    priority: 20
+    exec_time: 0 # ns
+    deadline: 0 # ns
+    period: 0 # ns  
+  task_response_time_filename: "~/Documents/profiling/response_time/op_motion_predictor.csv"
+
+# Independent
+twist_gate:
+  rate: 10
+  task_scheduling_configs:
+    policy: "NONE"
+    priority: 20
+    exec_time: 0 # ns
+    deadline: 0 # ns
+    period: 0 # ns
+  task_response_time_filename: "~/Documents/profiling/response_time/twist_gate.csv"
+
+  zero_flag: 0 ## Publish target velocity as 0
\ No newline at end of file
diff --git a/rubis_ws/src/rubis_autorunner/cfg/carla_autorunner/carla_full_autorunner.yaml b/rubis_ws/src/rubis_autorunner/cfg/carla_autorunner/carla_full_autorunner.yaml
new file mode 100644
index 00000000..83c242dd
--- /dev/null
+++ b/rubis_ws/src/rubis_autorunner/cfg/carla_autorunner/carla_full_autorunner.yaml
@@ -0,0 +1,14 @@
+total_step_num: 5
+terminate_script_path: "~/rubis_ws/src/rubis_autorunner/scripts/carla_autorunner/terminate_desktop.sh"
+# step_# : 
+#     [0] pacakge name
+#     [1] target name( node name or launch script name )
+#     [2] state that create constraint topic or not ( "true" or "false" )
+#     [3] state that check constraint topic or not ( "true" or "false" )
+#     [4] target type( RUN or LAUNCH )
+
+step_1: ["rubis_autorunner", "_carla_autorunner_1_sensing.launch", "true", "false", "LAUNCH"]
+step_2: ["rubis_autorunner", "_carla_autorunner_2_localization.launch", "true", "true", "LAUNCH"]
+step_3: ["rubis_autorunner", "_carla_autorunner_3_detection.launch", "true", "true", "LAUNCH"]
+step_4: ["rubis_autorunner", "_carla_autorunner_4_planning.launch", "true", "true", "LAUNCH"]
+step_5: ["rubis_autorunner", "_carla_autorunner_5_control.launch", "false", "true", "LAUNCH"]
diff --git a/rubis_ws/src/rubis_autorunner/cfg/carla_autorunner/carla_lkas_autorunner.yaml b/rubis_ws/src/rubis_autorunner/cfg/carla_autorunner/carla_lkas_autorunner.yaml
new file mode 100644
index 00000000..6fed9fc7
--- /dev/null
+++ b/rubis_ws/src/rubis_autorunner/cfg/carla_autorunner/carla_lkas_autorunner.yaml
@@ -0,0 +1,13 @@
+total_step_num: 4
+terminate_script_path: "~/rubis_ws/src/rubis_autorunner/scripts/carla_autorunner/terminate_desktop.sh"
+# step_# : 
+#     [0] pacakge name
+#     [1] target name( node name or launch script name )
+#     [2] state that create constraint topic or not ( "true" or "false" )
+#     [3] state that check constraint topic or not ( "true" or "false" )
+#     [4] target type( RUN or LAUNCH )
+
+step_1: ["rubis_autorunner", "_carla_autorunner_1_sensing.launch", "true", "false", "LAUNCH"]
+step_2: ["rubis_autorunner", "_carla_autorunner_2_localization.launch", "true", "true", "LAUNCH"]
+step_3: ["rubis_autorunner", "_carla_autorunner_4_planning.launch", "true", "true", "LAUNCH"]
+step_4: ["rubis_autorunner", "_carla_autorunner_5_control.launch", "false", "true", "LAUNCH"]
diff --git a/rubis_ws/src/rubis_autorunner/cfg/carla/lane_info.yaml b/rubis_ws/src/rubis_autorunner/cfg/carla_autorunner/lane_info.yaml
similarity index 100%
rename from rubis_ws/src/rubis_autorunner/cfg/carla/lane_info.yaml
rename to rubis_ws/src/rubis_autorunner/cfg/carla_autorunner/lane_info.yaml
diff --git a/rubis_ws/src/rubis_autorunner/cfg/carla/params.yaml b/rubis_ws/src/rubis_autorunner/cfg/carla_autorunner/params.yaml
similarity index 80%
rename from rubis_ws/src/rubis_autorunner/cfg/carla/params.yaml
rename to rubis_ws/src/rubis_autorunner/cfg/carla_autorunner/params.yaml
index 1680abe6..a7f3c4f3 100644
--- a/rubis_ws/src/rubis_autorunner/cfg/carla/params.yaml
+++ b/rubis_ws/src/rubis_autorunner/cfg/carla_autorunner/params.yaml
@@ -12,7 +12,7 @@
 # Sensing
 ray_ground_filter:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/ray_ground_filter.csv"
   rate: 10 
   task_minimum_inter_release_time: 100000000
@@ -22,7 +22,7 @@ ray_ground_filter:
 # Localization
 voxel_grid_filter:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/voxel_grid_filter.csv"
   rate: 10 
   task_minimum_inter_release_time: 100000000
@@ -33,17 +33,12 @@ ndt_matching:
   localizer: "velodyne"
 
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/ndt_matching.csv"
   rate: 100
   task_minimum_inter_release_time: 100000000
   task_execution_time: 70000000
   task_relative_deadline: 100000000
-  gpu_scheduling_flag: 0
-  gpu_profiling_flag: 0
-  gpu_execution_time_filename: "~/Documents/gpu_profiling/test_ndt_matching_execution_time.csv"
-  gpu_response_time_filename: "~/Documents/gpu_profiling/test_ndt_matching_response_time.csv"
-  gpu_deadline_filename: "~/Documents/gpu_deadline/ndt_matching_gpu_deadline.csv"
 
 logger_brake_dist:
   rate: 10
@@ -55,37 +50,27 @@ calibration_publisher:
 
 lidar_euclidean_cluster_detect:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/lidar_euclidean_cluster_detect.csv"
   rate: 10
   task_minimum_inter_release_time: 100000000
   task_execution_time: 100000000
   task_relative_deadline: 100000000
-  gpu_scheduling_flag: 0
-  gpu_profiling_flag: 0
-  gpu_execution_time_filename: "~/Documents/gpu_profiling/test_clustering_execution_time.csv"
-  gpu_response_time_filename: "~/Documents/gpu_profiling/test_clustering_response_time.csv"
-  gpu_deadline_filename: "~/Documents/gpu_deadline/clustring_gpu_deadline.csv"
 
 vision_darknet_detect:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/vision_darknet_detect.csv"
   rate: 100
   task_minimum_inter_release_time: 100000000
   task_execution_time: 100000000
   task_relative_deadline: 100000000
-  gpu_scheduling_flag: 0
-  gpu_profiling_flag: 0
-  gpu_execution_time_filename: "~/Documents/gpu_profiling/test_yolo_execution_time.csv"
-  gpu_response_time_filename: "~/Documents/gpu_profiling/test_yolo_response_time.csv"
-  gpu_deadline_filename: "~/Documents/gpu_deadline/yolo_gpu_deadline.csv"
   network_definition_file: "~/autoware.ai/autoware_files/vision/yolov3-320.cfg"
   pretrained_model_file: "~/autoware.ai/autoware_files/vision/yolov3.weights"
 
 imm_ukf_pda_track:
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/imm_ukf_pda_track.csv"
   rate: 10 
   task_minimum_inter_release_time: 100000000
@@ -94,7 +79,7 @@ imm_ukf_pda_track:
 
 range_vision_fusion:
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/range_vision_fusion.csv"
   rate: 10 
   task_minimum_inter_release_time: 100000000
@@ -104,7 +89,7 @@ range_vision_fusion:
 # Planning
 op_global_planner:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_global_planner.csv"
   rate: 25 #25
   task_minimum_inter_release_time: 100000000
@@ -122,7 +107,7 @@ op_common_params:
 
 op_trajectory_generator:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_trajectory_generator.csv"
   rate: 100 #100
   task_minimum_inter_release_time: 10000000
@@ -131,7 +116,7 @@ op_trajectory_generator:
 
 op_trajectory_evaluator:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_trajectory_evaluator.csv"
   rate: 100 #100
   task_minimum_inter_release_time: 100000000
@@ -154,7 +139,7 @@ op_trajectory_evaluator:
 
 op_behavior_selector:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_behavior_selector.csv"
   rate: 100 #100
   task_minimum_inter_release_time: 10000000
@@ -167,7 +152,7 @@ op_behavior_selector:
 
 op_motion_predictor:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_motion_predictor.csv"
   rate: 25 #25
   task_minimum_inter_release_time: 40000000
@@ -177,7 +162,7 @@ op_motion_predictor:
 # Control
 pure_pursuit:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/pure_pursuit.csv"
   rate: 30 #30
   task_minimum_inter_release_time: 33333333
@@ -188,7 +173,7 @@ pure_pursuit:
 
 twist_filter:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/twist_filter.csv"
   rate: 10
   task_minimum_inter_release_time: 100000000
@@ -197,7 +182,7 @@ twist_filter:
 
 twist_gate:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/twist_gate.csv"
   rate: 10
   task_minimum_inter_release_time: 100000000
diff --git a/rubis_ws/src/rubis_autorunner/cfg/cubetown_autorunner/cubetown_autorunner.yaml.backup b/rubis_ws/src/rubis_autorunner/cfg/cubetown_autorunner/cubetown_autorunner.yaml.backup
index 4e759a90..40581461 100644
--- a/rubis_ws/src/rubis_autorunner/cfg/cubetown_autorunner/cubetown_autorunner.yaml.backup
+++ b/rubis_ws/src/rubis_autorunner/cfg/cubetown_autorunner/cubetown_autorunner.yaml.backup
@@ -1,5 +1,5 @@
 total_step_num: 5
-terminate_script_path: "~/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/terminate.sh"
+terminate_script_path: "~/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/terminate_desktop.sh"
 # step_# : 
 #     [0] pacakge name
 #     [1] target name( node name or launch script name )
diff --git a/rubis_ws/src/rubis_autorunner/cfg/cubetown_autorunner/cubetown_autorunner_params.yaml b/rubis_ws/src/rubis_autorunner/cfg/cubetown_autorunner/cubetown_autorunner_params.yaml
index dacb51ae..a9545721 100644
--- a/rubis_ws/src/rubis_autorunner/cfg/cubetown_autorunner/cubetown_autorunner_params.yaml
+++ b/rubis_ws/src/rubis_autorunner/cfg/cubetown_autorunner/cubetown_autorunner_params.yaml
@@ -1,30 +1,46 @@
 # Unit of rate: hz
-# Unit of task information: nano seconds
+# Unit of scheduling params: ns
 
-# 1s  : 1000000000
-# 1ms : 1000000
-# 1us : 1000
+# 1s  : 1_000_000_000
+# 1ms : 1_000_000
+# 1us : 1_000
 # 1ns : 1
 
 #rate = hz
 # other time unut = ns
 
-# Localization
-voxel_grid_filter:
-  instance_mode: 1
+# Lane Keeping
+lidar_republisher:
+  rate: 10
+  task_scheduling_configs:
+    policy: "NONE"
+    priority: 99
+    exec_time: 1_000_000
+    deadline: 2_000_000
+    period: 2_000_000
+  task_response_time_filename: "~/Documents/profiling/response_time/lidar_republisher.csv"  
 
-  task_scheduling_flag: 0
-  task_profiling_flag: 1
-  task_response_time_filename: "~/Documents/profiling/response_time/voxel_grid_filter.csv"
+voxel_grid_filter:
   rate: 10
-  task_minimum_inter_release_time: 100_000_000
-  task_execution_time: 1_600_000
-  task_relative_deadline: 100_000_000
+  task_scheduling_configs:
+    policy: "NONE"
+    priority: 99
+    exec_time: 0 # ns
+    deadline: 0 # ns
+    period: 0 # ns
+  task_response_time_filename: "~/Documents/profiling/response_time/voxel_grid_filter.csv"  
 
 ndt_matching:
-  instance_mode: 1
-  use_kalman_filter: True
-
+  rate: 10
+  task_scheduling_configs:
+    policy: "NONE"
+    priority: 20
+    exec_time: 0 # ns
+    deadline: 0 # ns
+    period: 0 # ns
+  task_response_time_filename: "~/Documents/profiling/response_time/ndt_matching.csv"
+  
+  use_kalman_filter: False
   tf_x: 1.0510799 
   tf_y: 0
   tf_z: 1.96
@@ -33,129 +49,93 @@ ndt_matching:
   tf_yaw: 0
   localizer: "velodyne"
 
-  task_scheduling_flag: 0
-  task_profiling_flag: 1
-  task_response_time_filename: "~/Documents/profiling/response_time/ndt_matching.csv"
-  rate: 10
-  task_minimum_inter_release_time: 100_000_000
-  task_execution_time: 80_000_000
-  task_relative_deadline: 80_000_000
-  gpu_scheduling_flag: 0
-  gpu_profiling_flag: 0
-  gpu_execution_time_filename: "~/Documents/gpu_profiling/test_ndt_matching_execution_time.csv"
-  gpu_response_time_filename: "~/Documents/gpu_profiling/test_ndt_matching_response_time.csv"
-  gpu_deadline_filename: "~/Documents/gpu_deadline/ndt_matching_gpu_deadline.csv"
-
-modular_ndt_matching_CENTER:
-  instance_mode: 1
-  use_kalman_filter: True
+pure_pursuit:
+  rate: 30 #30
+  task_scheduling_configs:
+    policy: "NONE"
+    priority: 20
+    exec_time: 0 # ns
+    deadline: 0 # ns
+    period: 0 # ns  
+  task_response_time_filename: "~/Documents/profiling/response_time/pure_pursuit.csv"  
 
-  tf_x: 1.0510799 
-  tf_y: 0
-  tf_z: 1.96
-  tf_roll: 0
-  tf_pitch: 0
-  tf_yaw: 0
-  localizer: "velodyne"
+  dynamic_params_flag: False
+  dynamic_params_path: "~/autoware.ai/autoware_files/lgsvl_file/parameter/lgsvl_pure_pursuit.yaml"
 
-  task_scheduling_flag: 0
-  task_profiling_flag: 1
-  task_response_time_filename: "~/Documents/profiling/response_time/ndt_matching.csv"
+twist_filter:
   rate: 10
-  task_minimum_inter_release_time: 100_000_000
-  task_execution_time: 80_000_000
-  task_relative_deadline: 80_000_000
-  gpu_scheduling_flag: 0
-  gpu_profiling_flag: 0
-  gpu_execution_time_filename: "~/Documents/gpu_profiling/test_ndt_matching_execution_time.csv"
-  gpu_response_time_filename: "~/Documents/gpu_profiling/test_ndt_matching_response_time.csv"
-  gpu_deadline_filename: "~/Documents/gpu_deadline/ndt_matching_gpu_deadline.csv"
+  task_scheduling_configs:
+    policy: "NONE"
+    priority: 20
+    exec_time: 0 # ns
+    deadline: 0 # ns
+    period: 0 # ns
+  task_response_time_filename: "~/Documents/profiling/response_time/twist_filter.csv"
 
 # Detection
 ray_ground_filter_center:
-  task_scheduling_flag: 0
-  task_profiling_flag: 1
-  task_response_time_filename: "~/Documents/profiling/response_time/ray_ground_filter.csv"
   rate: 10 
-  task_minimum_inter_release_time: 100_000_000
-  task_execution_time: 100_000_000
-  task_relative_deadline: 100_000_000
-
+  task_scheduling_configs:
+    policy: "NONE"
+    priority: 20
+    exec_time: 0 # ns
+    deadline: 0 # ns
+    period: 0 # ns
+  task_response_time_filename: "~/Documents/profiling/response_time/ray_ground_filter.csv"
 
 lidar_euclidean_cluster_detect:
-  task_scheduling_flag: 0
-  task_profiling_flag: 1
-  task_response_time_filename: "~/Documents/profiling/response_time/lidar_euclidean_cluster_detect.csv"
   rate: 10
-  task_minimum_inter_release_time: 200_000_000
-  task_execution_time: 50_000_000
-  task_relative_deadline: 200_000_000
-  gpu_scheduling_flag: 0
-  gpu_profiling_flag: 0
-  gpu_execution_time_filename: "~/Documents/gpu_profiling/test_clustering_execution_time.csv"
-  gpu_response_time_filename: "~/Documents/gpu_profiling/test_clustering_response_time.csv"
-  gpu_deadline_filename: "~/Documents/gpu_deadline/clustering_gpu_deadline.csv"
-
-vision_darknet_detect:
-  task_scheduling_flag: 0
-  task_profiling_flag: 1
-  task_response_time_filename: "~/Documents/profiling/response_time/vision_darknet_detect.csv"
-  rate: 10
-  task_minimum_inter_release_time: 100_000_000
-  task_execution_time: 75_000_000
-  task_relative_deadline: 80_000_000
-  gpu_scheduling_flag: 0
-  gpu_profiling_flag: 0
-  gpu_execution_time_filename: "~/Documents/gpu_profiling/test_yolo_execution_time.csv"
-  gpu_response_time_filename: "~/Documents/gpu_profiling/test_yolo_response_time.csv"
-  gpu_deadline_filename: "~/Documents/gpu_deadline/yolo_gpu_deadline.csv"
+  task_scheduling_configs:
+    policy: "NONE"
+    priority: 20
+    exec_time: 0 # ns
+    deadline: 0 # ns
+    period: 0 # ns
+  task_response_time_filename: "~/Documents/profiling/response_time/lidar_euclidean_cluster_detect.csv"
+
   network_definition_file: "~/autoware.ai/autoware_files/vision/yolov3-320.cfg"
   pretrained_model_file: "~/autoware.ai/autoware_files/vision/yolov3-320.weights"
 
-imm_ukf_pda_track:
-  task_scheduling_flag: 0
-  task_profiling_flag: 1
-  task_response_time_filename: "~/Documents/profiling/response_time/imm_ukf_pda_track.csv"
-  rate: 10
-  task_minimum_inter_release_time: 200_000_000
-  task_execution_time: 100_000_000
-  task_relative_deadline: 200_000_000
-
 # Planning
 op_global_planner:
-  task_scheduling_flag: 0
-  task_profiling_flag: 1
-  task_response_time_filename: "~/Documents/profiling/response_time/op_global_planner.csv"
   rate: 25 #25
-  task_minimum_inter_release_time: 100_000_000
-  task_execution_time: 45_000_000
-  task_relative_deadline: 100_000_000
+  task_scheduling_configs:
+    policy: "NONE"
+    priority: 20
+    exec_time: 0 # ns
+    deadline: 0 # ns
+    period: 0 # ns
+  task_response_time_filename: "~/Documents/profiling/response_time/op_global_planner.csv"
+
   multilap_flag: 1
 
 op_common_params:
-  rollOutDensity: 2
-  rollOutsNumber: 4
+  rollOutDensity: 4
+  rollOutsNumber: 2
   maxVelocity: 10.0
   maxAcceleration: 10.0
   maxDeceleration: -10.0
 
 op_trajectory_generator:
-  task_scheduling_flag: 0
-  task_profiling_flag: 1
-  task_response_time_filename: "~/Documents/profiling/response_time/op_trajectory_generator.csv"
   rate: 100 #100
-  task_minimum_inter_release_time: 100_000_000
-  task_execution_time: 2_900_000
-  task_relative_deadline: 100_000_000
+  task_scheduling_configs:
+    policy: "NONE"
+    priority: 20
+    exec_time: 0 # ns
+    deadline: 0 # ns
+    period: 0 # ns
+  task_response_time_filename: "~/Documents/profiling/response_time/op_trajectory_generator.csv"
 
 op_trajectory_evaluator:
-  task_scheduling_flag: 0
-  task_profiling_flag: 1
-  task_response_time_filename: "~/Documents/profiling/response_time/op_trajectory_evaluator.csv"
   rate: 100 #100
-  task_minimum_inter_release_time: 100_000_000
-  task_execution_time: 3_600_000
-  task_relative_deadline: 100_000_000
+  task_scheduling_configs:
+    policy: "NONE"
+    priority: 20
+    exec_time: 0 # ns
+    deadline: 0 # ns
+    period: 0 # ns
+  task_response_time_filename: "~/Documents/profiling/response_time/op_trajectory_evaluator.csv"
+
   weightPriority: 1
   weightTransition: 0.5
   weightLong: 10
@@ -165,77 +145,39 @@ op_trajectory_evaluator:
   SprintDecisionTime: 9999999.0
 
 op_behavior_selector:
-  task_scheduling_flag: 0
-  task_profiling_flag: 1
-  task_response_time_filename: "~/Documents/profiling/response_time/op_behavior_selector.csv"
   rate: 100 #100
-  task_minimum_inter_release_time: 100_000_000
-  task_execution_time: 20_800_000
-  task_relative_deadline: 100_000_000
+  task_scheduling_configs:
+    policy: "NONE"
+    priority: 20
+    exec_time: 0 # ns
+    deadline: 0 # ns
+    period: 0 # ns
+  task_response_time_filename: "~/Documents/profiling/response_time/op_behavior_selector.csv"
+
   distanceToPedestrianThreshold: 15.0
   sprintSpeed: 10.0
   obstacleWaitingTimeinIntersection: 2.0
   turnThreshold: 30.0
 
 op_motion_predictor:
-  task_scheduling_flag: 0
-  task_profiling_flag: 1
-  task_response_time_filename: "~/Documents/profiling/response_time/op_motion_predictor.csv"
   rate: 25 #25
-  task_minimum_inter_release_time: 100_000_000
-  task_execution_time: 3_800_000
-  task_relative_deadline: 100_000_000
-
-# Control
-pure_pursuit:
-  instance_mode: 1
-  task_scheduling_flag: 0
-  task_profiling_flag: 1
-  task_response_time_filename: "~/Documents/profiling/response_time/pure_pursuit.csv"
-  rate: 30 #30
-  task_minimum_inter_release_time: 100_000_000
-  task_execution_time: 3_000_000
-  task_relative_deadline: 100_000_000
-  dynamic_params_flag: False
-  dynamic_params_path: "~/autoware.ai/autoware_files/lgsvl_file/parameter/lgsvl_pure_pursuit.yaml"
-
-twist_filter:
-  instance_mode: 1
-  task_scheduling_flag: 0
-  task_profiling_flag: 1
-  task_response_time_filename: "~/Documents/profiling/response_time/twist_filter.csv"
-  rate: 10
-  task_minimum_inter_release_time: 100_000_000
-  task_execution_time: 2_000_000
-  task_relative_deadline: 100_000_000
+  task_scheduling_configs:
+    policy: "NONE"
+    priority: 20
+    exec_time: 0 # ns
+    deadline: 0 # ns
+    period: 0 # ns  
+  task_response_time_filename: "~/Documents/profiling/response_time/op_motion_predictor.csv"
 
+# Independent
 twist_gate:
-  instance_mode: 1
-  task_scheduling_flag: 0
-  task_profiling_flag: 1
-  task_response_time_filename: "~/Documents/profiling/response_time/twist_gate.csv"
   rate: 10
-  task_minimum_inter_release_time: 100_000_000
-  task_execution_time: 2_000_000
-  task_relative_deadline: 100_000_000
-  zero_flag: 0 ## Publish target velocity as 0
+  task_scheduling_configs:
+    policy: "NONE"
+    priority: 20
+    exec_time: 0 # ns
+    deadline: 0 # ns
+    period: 0 # ns
+  task_response_time_filename: "~/Documents/profiling/response_time/twist_gate.csv"
 
-# Others
-lidar_republisher:
-  instance_mode: 1
-  task_scheduling_flag: 0
-  task_profiling_flag: 1
-  task_response_time_filename: "~/Documents/profiling/response_time/lidar_republisher.csv"
-  rate: 10
-  task_minimum_inter_release_time: 100_000_000
-  task_execution_time: 70_000_000
-  task_relative_deadline: 100_000_000
-
-republish:
-  task_scheduling_flag: 0
-  task_profiling_flag: 1
-  task_response_time_filename: "~/Documents/profiling/response_time/republish.csv"
-  rate: 10
-  task_minimum_inter_release_time: 100_000_000
-  task_execution_time: 35_000_000
-  task_relative_deadline: 100_000_000
\ No newline at end of file
+  zero_flag: 0 ## Publish target velocity as 0
\ No newline at end of file
diff --git a/rubis_ws/src/rubis_autorunner/cfg/cubetown_autorunner/cubetown_autorunner_params.yaml.backup b/rubis_ws/src/rubis_autorunner/cfg/cubetown_autorunner/cubetown_autorunner_params.yaml.backup
deleted file mode 100644
index f8e2f9cf..00000000
--- a/rubis_ws/src/rubis_autorunner/cfg/cubetown_autorunner/cubetown_autorunner_params.yaml.backup
+++ /dev/null
@@ -1,238 +0,0 @@
-# Unit of rate: hz
-# Unit of task information: nano seconds
-
-# 1s  : 1000000000
-# 1ms : 1000000
-# 1us : 1000
-# 1ns : 1
-
-#rate = hz
-# other time unut = ns
-
-# Localization
-voxel_grid_filter:
-  task_scheduling_flag: 1
-  task_profiling_flag: 0
-  task_response_time_filename: "~/Documents/profiling/response_time/voxel_grid_filter.csv"
-  rate: 10 
-  task_minimum_inter_release_time: 100000000
-  task_execution_time: 100000000
-  task_relative_deadline: 100000000
-
-ndt_matching:
-  tf_x: 1.0510799 
-  tf_y: 0
-  tf_z: 1.96
-  tf_roll: 0
-  tf_pitch: 0
-  tf_yaw: 0
-  localizer: "velodyne"
-
-  task_scheduling_flag: 0
-  task_profiling_flag: 0
-  task_response_time_filename: "~/Documents/profiling/response_time/ndt_matching.csv"
-  rate: 10
-  task_minimum_inter_release_time: 100000000
-  task_execution_time: 70000000
-  task_relative_deadline: 100000000
-  gpu_scheduling_flag: 0
-  gpu_profiling_flag: 0
-  gpu_execution_time_filename: "~/Documents/gpu_profiling/test_ndt_matching_execution_time.csv"
-  gpu_response_time_filename: "~/Documents/gpu_profiling/test_ndt_matching_response_time.csv"
-  gpu_deadline_filename: "~/Documents/gpu_deadline/ndt_matching_gpu_deadline.csv"
-
-# Detection
-compare_map_filter:
-  distance_threshold: 0.4
-  min_clipping_height: -1.7
-  max_clipping_height: 0.5
-
-  task_scheduling_flag: 0
-  task_profiling_flag: 0
-  task_response_time_filename: "~/Documents/profiling/response_time/compare_map_filter.csv"
-  rate: 10
-  task_minimum_inter_release_time: 100000000
-  task_execution_time: 70000000
-  task_relative_deadline: 100000000
-
-
-lidar_euclidean_cluster_detect:
-  task_scheduling_flag: 0
-  task_profiling_flag: 0
-  task_response_time_filename: "~/Documents/profiling/response_time/lidar_euclidean_cluster_detect.csv"
-  rate: 10 
-  task_minimum_inter_release_time: 100000000
-  task_execution_time: 100000000
-  task_relative_deadline: 100000000
-  gpu_scheduling_flag: 0
-  gpu_profiling_flag: 0
-  gpu_execution_time_filename: "~/Documents/gpu_profiling/test_clustering_execution_time.csv"
-  gpu_response_time_filename: "~/Documents/gpu_profiling/test_clustering_response_time.csv"
-  gpu_deadline_filename: "~/Documents/gpu_deadline/clustring_gpu_deadline.csv"
-
-vision_darknet_detect:
-  task_scheduling_flag: 0
-  task_profiling_flag: 0
-  task_response_time_filename: "~/Documents/profiling/response_time/vision_darknet_detect.csv"
-  rate: 10 
-  task_minimum_inter_release_time: 100000000
-  task_execution_time: 100000000
-  task_relative_deadline: 100000000
-  gpu_scheduling_flag: 0
-  gpu_profiling_flag: 0
-  gpu_execution_time_filename: "~/Documents/gpu_profiling/test_yolo_execution_time.csv"
-  gpu_response_time_filename: "~/Documents/gpu_profiling/test_yolo_response_time.csv"
-  gpu_deadline_filename: "~/Documents/gpu_deadline/yolo_gpu_deadline.csv"
-  network_definition_file: "~/autoware.ai/autoware_files/vision/yolov3-tiny.cfg"
-  pretrained_model_file: "~/autoware.ai/autoware_files/vision/yolov3-tiny.weights"
-
-imm_ukf_pda_track:
-  task_scheduling_flag: 0
-  task_profiling_flag: 0
-  task_response_time_filename: "~/Documents/profiling/response_time/imm_ukf_pda_track.csv"
-  rate: 10 
-  task_minimum_inter_release_time: 100000000
-  task_execution_time: 100000000
-  task_relative_deadline: 100000000
-
-range_vision_fusion:
-  task_scheduling_flag: 0
-  task_profiling_flag: 0
-  task_response_time_filename: "~/Documents/profiling/response_time/range_vision_fusion.csv"
-  rate: 10 
-  task_minimum_inter_release_time: 100000000
-  task_execution_time: 100000000
-  task_relative_deadline: 100000000
-
-# Planning
-op_global_planner:
-  task_scheduling_flag: 0
-  task_profiling_flag: 0
-  task_response_time_filename: "~/Documents/profiling/response_time/op_global_planner.csv"
-  rate: 25 #25
-  task_minimum_inter_release_time: 100000000
-  task_execution_time: 100000000
-  task_relative_deadline: 100000000
-  multilap_flag: 1
-
-op_common_params:
-  rollOutDensity: 4
-  rollOutsNumber: 0
-  maxVelocity: 10.0
-  maxAcceleration: 10.0
-  maxDeceleration: -10.0
-
-op_trajectory_generator:
-  task_scheduling_flag: 0
-  task_profiling_flag: 0
-  task_response_time_filename: "~/Documents/profiling/response_time/op_trajectory_generator.csv"
-  rate: 100 #100
-  task_minimum_inter_release_time: 10000000
-  task_execution_time: 10000000
-  task_relative_deadline: 10000000
-
-op_trajectory_evaluator:
-  task_scheduling_flag: 0
-  task_profiling_flag: 0
-  task_response_time_filename: "~/Documents/profiling/response_time/op_trajectory_evaluator.csv"
-  rate: 100 #100
-  task_minimum_inter_release_time: 100000000
-  task_execution_time: 100000000
-  task_relative_deadline: 100000000
-  weightPriority: 0
-  weightTransition: 5
-  weightLong: 4
-  weightLat: 4
-  ImageWidth: 1920
-  ImageHeight: 1080
-  SprintDecisionTime: 9999999.0
-
-op_behavior_selector:
-  task_scheduling_flag: 0
-  task_profiling_flag: 0
-  task_response_time_filename: "~/Documents/profiling/response_time/op_behavior_selector.csv"
-  rate: 100 #100
-  task_minimum_inter_release_time: 10000000
-  task_execution_time: 10000000
-  task_relative_deadline: 10000000
-  distanceToPedestrianThreshold: 15.0
-  sprintSpeed: 10.0
-  obstacleWaitingTimeinIntersection: 2.0
-  turnThreshold: 30.0
-
-op_motion_predictor:
-  task_scheduling_flag: 0
-  task_profiling_flag: 0
-  task_response_time_filename: "~/Documents/profiling/response_time/op_motion_predictor.csv"
-  rate: 25 #25
-  task_minimum_inter_release_time: 40000000
-  task_execution_time: 40000000
-  task_relative_deadline: 40000000
-
-# Control
-pure_pursuit:
-  task_scheduling_flag: 0
-  task_profiling_flag: 0
-  task_response_time_filename: "~/Documents/profiling/response_time/pure_pursuit.csv"
-  rate: 30 #30
-  task_minimum_inter_release_time: 33333333
-  task_execution_time: 33333333
-  task_relative_deadline: 33333333
-  dynamic_params_flag: False
-  dynamic_params_path: "~/autoware.ai/autoware_files/lgsvl_file/parameter/lgsvl_pure_pursuit.yaml"
-
-twist_filter:
-  task_scheduling_flag: 0
-  task_profiling_flag: 0
-  task_response_time_filename: "~/Documents/profiling/response_time/twist_filter.csv"
-  rate: 10
-  task_minimum_inter_release_time: 100000000
-  task_execution_time: 100000000
-  task_relative_deadline: 100000000
-
-twist_gate:
-  task_scheduling_flag: 0
-  task_profiling_flag: 0
-  task_response_time_filename: "~/Documents/profiling/response_time/twist_gate.csv"
-  rate: 10
-  task_minimum_inter_release_time: 100000000
-  task_execution_time: 100000000
-  task_relative_deadline: 100000000
-  zero_flag: 0 ## Publish target velocity as 0
-
-# Others
-lidar_republisher:
-  task_scheduling_flag: 0
-  task_profiling_flag: 0
-  task_response_time_filename: "~/Documents/profiling/response_time/lidar_republisher.csv"
-  rate: 10
-  task_minimum_inter_release_time: 100000000
-  task_execution_time: 100000000
-  task_relative_deadline: 100000000
-
-vel_relay:
-  task_scheduling_flag: 0
-  task_profiling_flag: 0
-  task_response_time_filename: "~/Documents/profiling/response_time/vel_relay.csv"
-  rate: 10
-  task_minimum_inter_release_time: 100000000
-  task_execution_time: 100000000
-  task_relative_deadline: 100000000
-
-vel_relay:
-  task_scheduling_flag: 0
-  task_profiling_flag: 0
-  task_response_time_filename: "~/Documents/profiling/response_time/pose_relay.csv"
-  rate: 10
-  task_minimum_inter_release_time: 100000000
-  task_execution_time: 100000000
-  task_relative_deadline: 100000000
-
-republish:
-  task_scheduling_flag: 0
-  task_profiling_flag: 1
-  task_response_time_filename: "~/Documents/profiling/response_time/republish.csv"
-  rate: 10
-  task_minimum_inter_release_time: 100000000
-  task_execution_time: 100000000
-  task_relative_deadline: 100000000
\ No newline at end of file
diff --git a/rubis_ws/src/rubis_autorunner/cfg/cubetown_autorunner/cubetown_full_autorunner.yaml b/rubis_ws/src/rubis_autorunner/cfg/cubetown_autorunner/cubetown_full_autorunner.yaml
index 4e759a90..40581461 100644
--- a/rubis_ws/src/rubis_autorunner/cfg/cubetown_autorunner/cubetown_full_autorunner.yaml
+++ b/rubis_ws/src/rubis_autorunner/cfg/cubetown_autorunner/cubetown_full_autorunner.yaml
@@ -1,5 +1,5 @@
 total_step_num: 5
-terminate_script_path: "~/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/terminate.sh"
+terminate_script_path: "~/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/terminate_desktop.sh"
 # step_# : 
 #     [0] pacakge name
 #     [1] target name( node name or launch script name )
diff --git a/rubis_ws/src/rubis_autorunner/cfg/cubetown_autorunner/cubetown_lkas_autorunner.yaml b/rubis_ws/src/rubis_autorunner/cfg/cubetown_autorunner/cubetown_lkas_autorunner.yaml
index c70a8e39..6873e2f3 100644
--- a/rubis_ws/src/rubis_autorunner/cfg/cubetown_autorunner/cubetown_lkas_autorunner.yaml
+++ b/rubis_ws/src/rubis_autorunner/cfg/cubetown_autorunner/cubetown_lkas_autorunner.yaml
@@ -1,5 +1,5 @@
 total_step_num: 4
-terminate_script_path: "~/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/terminate.sh"
+terminate_script_path: "~/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/terminate_desktop.sh"
 # step_# : 
 #     [0] pacakge name
 #     [1] target name( node name or launch script name )
diff --git a/rubis_ws/src/rubis_autorunner/cfg/desktop_lane_keeping/desktop_lane_keeping.yaml b/rubis_ws/src/rubis_autorunner/cfg/desktop_lane_keeping/desktop_lane_keeping.yaml
index 3548041c..f142af8a 100644
--- a/rubis_ws/src/rubis_autorunner/cfg/desktop_lane_keeping/desktop_lane_keeping.yaml
+++ b/rubis_ws/src/rubis_autorunner/cfg/desktop_lane_keeping/desktop_lane_keeping.yaml
@@ -1,5 +1,5 @@
 total_step_num: 4
-terminate_script_path: "~/rubis_ws/src/rubis_autorunner/scripts/desktop_lane_keeping/terminate.sh"
+terminate_script_path: "~/rubis_ws/src/rubis_autorunner/scripts/desktop_lane_keeping/terminate_desktop.sh"
 # step_# : 
 #     [0] pacakge name
 #     [1] target name( node name or launch script name )
diff --git a/rubis_ws/src/rubis_autorunner/cfg/desktop_lane_keeping/desktop_lene_keeping_params.yaml b/rubis_ws/src/rubis_autorunner/cfg/desktop_lane_keeping/desktop_lene_keeping_params.yaml
index 29cc8960..0817c790 100644
--- a/rubis_ws/src/rubis_autorunner/cfg/desktop_lane_keeping/desktop_lene_keeping_params.yaml
+++ b/rubis_ws/src/rubis_autorunner/cfg/desktop_lane_keeping/desktop_lene_keeping_params.yaml
@@ -12,7 +12,7 @@
 # Sensing
 ray_ground_filter:
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/ray_ground_filter.csv"
   rate: 10 
   task_minimum_inter_release_time: 100000000
@@ -22,7 +22,7 @@ ray_ground_filter:
 # Localization
 voxel_grid_filter:
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/voxel_grid_filter.csv"
   rate: 10 
   task_minimum_inter_release_time: 100000000
@@ -33,17 +33,12 @@ ndt_matching:
   localizer: "velodyne"
 
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/ndt_matching.csv"
   rate: 10
   task_minimum_inter_release_time: 100000000
   task_execution_time: 70000000
   task_relative_deadline: 100000000
-  gpu_scheduling_flag: 0
-  gpu_profiling_flag: 0
-  gpu_execution_time_filename: "~/Documents/gpu_profiling/test_ndt_matching_execution_time.csv"
-  gpu_response_time_filename: "~/Documents/gpu_profiling/test_ndt_matching_response_time.csv"
-  gpu_deadline_filename: "~/Documents/gpu_deadline/ndt_matching_gpu_deadline.csv"
 
 # Detection
 calibration_publisher:
@@ -51,37 +46,27 @@ calibration_publisher:
 
 lidar_euclidean_cluster_detect:
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/lidar_euclidean_cluster_detect.csv"
   rate: 10 
   task_minimum_inter_release_time: 100000000
   task_execution_time: 100000000
   task_relative_deadline: 100000000
-  gpu_scheduling_flag: 0
-  gpu_profiling_flag: 0
-  gpu_execution_time_filename: "~/Documents/gpu_profiling/test_clustering_execution_time.csv"
-  gpu_response_time_filename: "~/Documents/gpu_profiling/test_clustering_response_time.csv"
-  gpu_deadline_filename: "~/Documents/gpu_deadline/clustring_gpu_deadline.csv"
 
 vision_darknet_detect:
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/vision_darknet_detect.csv"
   rate: 10 
   task_minimum_inter_release_time: 100000000
   task_execution_time: 100000000
   task_relative_deadline: 100000000
-  gpu_scheduling_flag: 0
-  gpu_profiling_flag: 0
-  gpu_execution_time_filename: "~/Documents/gpu_profiling/test_yolo_execution_time.csv"
-  gpu_response_time_filename: "~/Documents/gpu_profiling/test_yolo_response_time.csv"
-  gpu_deadline_filename: "~/Documents/gpu_deadline/yolo_gpu_deadline.csv"
   network_definition_file: "~/autoware.ai/autoware_files/vision/yolov3-tiny.cfg"
   pretrained_model_file: "~/autoware.ai/autoware_files/vision/yolov3-tiny.weights"
 
 imm_ukf_pda_track:
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/imm_ukf_pda_track.csv"
   rate: 10 
   task_minimum_inter_release_time: 100000000
@@ -90,7 +75,7 @@ imm_ukf_pda_track:
 
 range_vision_fusion:
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/range_vision_fusion.csv"
   rate: 10 
   task_minimum_inter_release_time: 100000000
@@ -100,7 +85,7 @@ range_vision_fusion:
 # Planning
 op_global_planner:
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_global_planner.csv"
   rate: 25 #25
   task_minimum_inter_release_time: 100000000
@@ -118,7 +103,7 @@ op_common_params:
 
 op_trajectory_generator:
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_trajectory_generator.csv"
   rate: 100 #100
   task_minimum_inter_release_time: 10000000
@@ -127,7 +112,7 @@ op_trajectory_generator:
 
 op_trajectory_evaluator:
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_trajectory_evaluator.csv"
   rate: 100 #100
   task_minimum_inter_release_time: 100000000
@@ -143,7 +128,7 @@ op_trajectory_evaluator:
 
 op_behavior_selector:
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_behavior_selector.csv"
   rate: 100 #100
   task_minimum_inter_release_time: 10000000
@@ -156,7 +141,7 @@ op_behavior_selector:
 
 op_motion_predictor:
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_motion_predictor.csv"
   rate: 25 #25
   task_minimum_inter_release_time: 40000000
@@ -166,7 +151,7 @@ op_motion_predictor:
 # Control
 pure_pursuit:
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/pure_pursuit.csv"
   rate: 30 #30
   task_minimum_inter_release_time: 33333333
@@ -177,7 +162,7 @@ pure_pursuit:
 
 twist_filter:
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/twist_filter.csv"
   rate: 10
   task_minimum_inter_release_time: 100000000
@@ -186,7 +171,7 @@ twist_filter:
 
 twist_gate:
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/twist_gate.csv"
   rate: 10
   task_minimum_inter_release_time: 100000000
diff --git a/rubis_ws/src/rubis_autorunner/cfg/ionic_autorunner/ionic_autorunner_params.yaml b/rubis_ws/src/rubis_autorunner/cfg/ionic_autorunner/ionic_autorunner_params.yaml
index 446ed3b2..0eaf97db 100644
--- a/rubis_ws/src/rubis_autorunner/cfg/ionic_autorunner/ionic_autorunner_params.yaml
+++ b/rubis_ws/src/rubis_autorunner/cfg/ionic_autorunner/ionic_autorunner_params.yaml
@@ -19,7 +19,7 @@ voxel_grid_filter:
   instance_mode: 1
 
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/voxel_grid_filter.csv"
   rate: 10
   task_minimum_inter_release_time: 100_000_000
@@ -30,20 +30,14 @@ modular_ndt_matching_FR:
   instance_mode: 1
 
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/ndt_matching.csv"
   rate: 10
   task_minimum_inter_release_time: 100_000_000
   task_execution_time: 80_000_000
   task_relative_deadline: 80_000_000
-  gpu_scheduling_flag: 0
-  gpu_profiling_flag: 0
-  gpu_execution_time_filename: "~/Documents/gpu_profiling/test_ndt_matching_execution_time.csv"
-  gpu_response_time_filename: "~/Documents/gpu_profiling/test_ndt_matching_response_time.csv"
-  gpu_deadline_filename: "~/Documents/gpu_deadline/ndt_matching_gpu_deadline.csv"
 
 ndt_matching:
-  instance_mode: 1
   use_kalman_filter: False
 
   tf_x: 3.3
@@ -55,24 +49,17 @@ ndt_matching:
   localizer: "velodyne"
 
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/ndt_matching.csv"
   rate: 10
   task_minimum_inter_release_time: 100_000_000
   task_execution_time: 80_000_000
   task_relative_deadline: 80_000_000
-  gpu_scheduling_flag: 0
-  gpu_profiling_flag: 0
-  gpu_execution_time_filename: "~/Documents/gpu_profiling/test_ndt_matching_execution_time.csv"
-  gpu_response_time_filename: "~/Documents/gpu_profiling/test_ndt_matching_response_time.csv"
-  gpu_deadline_filename: "~/Documents/gpu_deadline/ndt_matching_gpu_deadline.csv"
-
-
 
 # Detection
 ray_ground_filter_center:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/ray_ground_filter.csv"
   rate: 10 
   task_minimum_inter_release_time: 100_000_000
@@ -82,37 +69,27 @@ ray_ground_filter_center:
 
 lidar_euclidean_cluster_detect:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/lidar_euclidean_cluster_detect.csv"
   rate: 10
   task_minimum_inter_release_time: 200_000_000
   task_execution_time: 50_000_000
   task_relative_deadline: 200_000_000
-  gpu_scheduling_flag: 0
-  gpu_profiling_flag: 0
-  gpu_execution_time_filename: "~/Documents/gpu_profiling/test_clustering_execution_time.csv"
-  gpu_response_time_filename: "~/Documents/gpu_profiling/test_clustering_response_time.csv"
-  gpu_deadline_filename: "~/Documents/gpu_deadline/clustering_gpu_deadline.csv"
 
 vision_darknet_detect:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/vision_darknet_detect.csv"
   rate: 10
   task_minimum_inter_release_time: 100_000_000
   task_execution_time: 75_000_000
   task_relative_deadline: 80_000_000
-  gpu_scheduling_flag: 0
-  gpu_profiling_flag: 0
-  gpu_execution_time_filename: "~/Documents/gpu_profiling/test_yolo_execution_time.csv"
-  gpu_response_time_filename: "~/Documents/gpu_profiling/test_yolo_response_time.csv"
-  gpu_deadline_filename: "~/Documents/gpu_deadline/yolo_gpu_deadline.csv"
   network_definition_file: "~/autoware.ai/autoware_files/vision/yolov3-320.cfg"
   pretrained_model_file: "~/autoware.ai/autoware_files/vision/yolov3-320.weights"
 
 imm_ukf_pda_track:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/imm_ukf_pda_track.csv"
   rate: 10
   task_minimum_inter_release_time: 200_000_000
@@ -122,7 +99,7 @@ imm_ukf_pda_track:
 # Planning
 op_global_planner:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_global_planner.csv"
   rate: 10 #25
   task_minimum_inter_release_time: 100_000_000
@@ -139,7 +116,7 @@ op_common_params:
 
 op_trajectory_generator:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_trajectory_generator.csv"
   rate: 10 #100
   task_minimum_inter_release_time: 100_000_000
@@ -148,7 +125,7 @@ op_trajectory_generator:
 
 op_trajectory_evaluator:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_trajectory_evaluator.csv"
   rate: 10 #100
   task_minimum_inter_release_time: 100_000_000
@@ -166,7 +143,7 @@ op_trajectory_evaluator:
 
 op_behavior_selector:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_behavior_selector.csv"
   rate: 10 #100
   task_minimum_inter_release_time: 100_000_000
@@ -179,7 +156,7 @@ op_behavior_selector:
 
 op_motion_predictor:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_motion_predictor.csv"
   rate: 10 #25
   task_minimum_inter_release_time: 100_000_000
@@ -188,9 +165,8 @@ op_motion_predictor:
 
 # Control
 pure_pursuit:
-  instance_mode: 1
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/pure_pursuit.csv"
   rate: 10 #30
   task_minimum_inter_release_time: 100_000_000
@@ -200,9 +176,8 @@ pure_pursuit:
   dynamic_params_path: "~/autoware.ai/autoware_files/lgsvl_file/parameter/lgsvl_pure_pursuit.yaml"
 
 twist_filter:
-  instance_mode: 1
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/twist_filter.csv"
   rate: 10
   task_minimum_inter_release_time: 100_000_000
@@ -210,9 +185,8 @@ twist_filter:
   task_relative_deadline: 100_000_000
 
 twist_gate:
-  instance_mode: 1
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/twist_gate.csv"
   rate: 10
   task_minimum_inter_release_time: 100_000_000
@@ -222,9 +196,8 @@ twist_gate:
 
 # Others
 lidar_republisher:
-  instance_mode: 1
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/lidar_republisher.csv"
   rate: 10
   task_minimum_inter_release_time: 100_000_000
@@ -233,7 +206,7 @@ lidar_republisher:
 
 vel_relay:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/vel_relay.csv"
   rate: 10
   task_minimum_inter_release_time: 100_000_000
@@ -241,9 +214,8 @@ vel_relay:
   task_relative_deadline: 100_000_000
 
 pose_relay:
-  instance_mode: 1
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/pose_relay.csv"
   rate: 10
   task_minimum_inter_release_time: 100_000_000
@@ -252,7 +224,7 @@ pose_relay:
 
 republish:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/republish.csv"
   rate: 10
   task_minimum_inter_release_time: 100_000_000
diff --git a/rubis_ws/src/rubis_autorunner/cfg/ionic_autorunner/ionic_autorunner_params_spin40.yaml b/rubis_ws/src/rubis_autorunner/cfg/ionic_autorunner/ionic_autorunner_params_spin40.yaml
index cb127f78..f979d738 100644
--- a/rubis_ws/src/rubis_autorunner/cfg/ionic_autorunner/ionic_autorunner_params_spin40.yaml
+++ b/rubis_ws/src/rubis_autorunner/cfg/ionic_autorunner/ionic_autorunner_params_spin40.yaml
@@ -18,7 +18,7 @@ voxel_grid_filter:
   instance_mode: 1
 
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/voxel_grid_filter.csv"
   rate: 40
   task_minimum_inter_release_time: 100_000_000
@@ -29,20 +29,14 @@ modular_ndt_matching_FR:
   instance_mode: 1
 
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/ndt_matching.csv"
   rate: 40
   task_minimum_inter_release_time: 100_000_000
   task_execution_time: 80_000_000
   task_relative_deadline: 80_000_000
-  gpu_scheduling_flag: 0
-  gpu_profiling_flag: 0
-  gpu_execution_time_filename: "~/Documents/gpu_profiling/test_ndt_matching_execution_time.csv"
-  gpu_response_time_filename: "~/Documents/gpu_profiling/test_ndt_matching_response_time.csv"
-  gpu_deadline_filename: "~/Documents/gpu_deadline/ndt_matching_gpu_deadline.csv"
 
 ndt_matching:
-  instance_mode: 1
   use_kalman_filter: False
 
   tf_x: 3.3
@@ -54,24 +48,17 @@ ndt_matching:
   localizer: "velodyne"
 
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/ndt_matching.csv"
   rate: 40
   task_minimum_inter_release_time: 100_000_000
   task_execution_time: 80_000_000
   task_relative_deadline: 80_000_000
-  gpu_scheduling_flag: 0
-  gpu_profiling_flag: 0
-  gpu_execution_time_filename: "~/Documents/gpu_profiling/test_ndt_matching_execution_time.csv"
-  gpu_response_time_filename: "~/Documents/gpu_profiling/test_ndt_matching_response_time.csv"
-  gpu_deadline_filename: "~/Documents/gpu_deadline/ndt_matching_gpu_deadline.csv"
-
-
 
 # Detection
 ray_ground_filter_center:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/ray_ground_filter.csv"
   rate: 40
   task_minimum_inter_release_time: 100_000_000
@@ -81,37 +68,27 @@ ray_ground_filter_center:
 
 lidar_euclidean_cluster_detect:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/lidar_euclidean_cluster_detect.csv"
   rate: 40
   task_minimum_inter_release_time: 200_000_000
   task_execution_time: 50_000_000
   task_relative_deadline: 200_000_000
-  gpu_scheduling_flag: 0
-  gpu_profiling_flag: 0
-  gpu_execution_time_filename: "~/Documents/gpu_profiling/test_clustering_execution_time.csv"
-  gpu_response_time_filename: "~/Documents/gpu_profiling/test_clustering_response_time.csv"
-  gpu_deadline_filename: "~/Documents/gpu_deadline/clustering_gpu_deadline.csv"
 
 vision_darknet_detect:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/vision_darknet_detect.csv"
   rate: 40
   task_minimum_inter_release_time: 100_000_000
   task_execution_time: 75_000_000
   task_relative_deadline: 80_000_000
-  gpu_scheduling_flag: 0
-  gpu_profiling_flag: 0
-  gpu_execution_time_filename: "~/Documents/gpu_profiling/test_yolo_execution_time.csv"
-  gpu_response_time_filename: "~/Documents/gpu_profiling/test_yolo_response_time.csv"
-  gpu_deadline_filename: "~/Documents/gpu_deadline/yolo_gpu_deadline.csv"
   network_definition_file: "~/autoware.ai/autoware_files/vision/yolov3-320.cfg"
   pretrained_model_file: "~/autoware.ai/autoware_files/vision/yolov3-320.weights"
 
 imm_ukf_pda_track:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/imm_ukf_pda_track.csv"
   rate: 40
   task_minimum_inter_release_time: 200_000_000
@@ -121,7 +98,7 @@ imm_ukf_pda_track:
 # Planning
 op_global_planner:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_global_planner.csv"
   rate: 40 #25
   task_minimum_inter_release_time: 100_000_000
@@ -138,7 +115,7 @@ op_common_params:
 
 op_trajectory_generator:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_trajectory_generator.csv"
   rate: 40 #100
   task_minimum_inter_release_time: 100_000_000
@@ -147,7 +124,7 @@ op_trajectory_generator:
 
 op_trajectory_evaluator:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_trajectory_evaluator.csv"
   rate: 40 #100
   task_minimum_inter_release_time: 100_000_000
@@ -165,7 +142,7 @@ op_trajectory_evaluator:
 
 op_behavior_selector:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_behavior_selector.csv"
   rate: 40 #100
   task_minimum_inter_release_time: 100_000_000
@@ -178,7 +155,7 @@ op_behavior_selector:
 
 op_motion_predictor:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_motion_predictor.csv"
   rate: 40 #25
   task_minimum_inter_release_time: 100_000_000
@@ -187,9 +164,8 @@ op_motion_predictor:
 
 # Control
 pure_pursuit:
-  instance_mode: 1
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/pure_pursuit.csv"
   rate: 40 #30
   task_minimum_inter_release_time: 100_000_000
@@ -199,9 +175,8 @@ pure_pursuit:
   dynamic_params_path: "~/autoware.ai/autoware_files/lgsvl_file/parameter/lgsvl_pure_pursuit.yaml"
 
 twist_filter:
-  instance_mode: 1
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/twist_filter.csv"
   rate: 40
   task_minimum_inter_release_time: 100_000_000
@@ -209,9 +184,8 @@ twist_filter:
   task_relative_deadline: 100_000_000
 
 twist_gate:
-  instance_mode: 1
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/twist_gate.csv"
   rate: 40
   task_minimum_inter_release_time: 100_000_000
@@ -221,9 +195,8 @@ twist_gate:
 
 # Others
 lidar_republisher:
-  instance_mode: 1
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/lidar_republisher.csv"
   rate: 40
   task_minimum_inter_release_time: 100_000_000
@@ -232,7 +205,7 @@ lidar_republisher:
 
 vel_relay:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/vel_relay.csv"
   rate: 40
   task_minimum_inter_release_time: 100_000_000
@@ -240,9 +213,8 @@ vel_relay:
   task_relative_deadline: 100_000_000
 
 pose_relay:
-  instance_mode: 1
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/pose_relay.csv"
   rate: 40
   task_minimum_inter_release_time: 100_000_000
@@ -251,7 +223,7 @@ pose_relay:
 
 republish:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/republish.csv"
   rate: 40
   task_minimum_inter_release_time: 100_000_000
diff --git a/rubis_ws/src/rubis_autorunner/cfg/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_autorunner.yaml b/rubis_ws/src/rubis_autorunner/cfg/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_autorunner.yaml
index 717968c5..e0e4d6ab 100644
--- a/rubis_ws/src/rubis_autorunner/cfg/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_autorunner.yaml
+++ b/rubis_ws/src/rubis_autorunner/cfg/lgsvl_triple_lidar_autorunner/lgsvl_triple_lidar_autorunner.yaml
@@ -1,5 +1,5 @@
 total_step_num: 9
-terminate_script_path: "~/rubis_ws/src/rubis_autorunner/scripts/lgsvl_triple_lidar_autorunner/terminate.sh"
+terminate_script_path: "~/rubis_ws/src/rubis_autorunner/scripts/lgsvl_triple_lidar_autorunner/terminate_desktop.sh"
 # step_# : 
 #     [0] pacakge name
 #     [1] target name( node name or launch script name )
diff --git a/rubis_ws/src/rubis_autorunner/cfg/minicar_lane_keeping/minicar_lane_keeping.yaml b/rubis_ws/src/rubis_autorunner/cfg/minicar_lane_keeping/minicar_lane_keeping.yaml
index 1f7f7e4e..b1249827 100644
--- a/rubis_ws/src/rubis_autorunner/cfg/minicar_lane_keeping/minicar_lane_keeping.yaml
+++ b/rubis_ws/src/rubis_autorunner/cfg/minicar_lane_keeping/minicar_lane_keeping.yaml
@@ -1,5 +1,5 @@
 total_step_num: 4
-terminate_script_path: "~/rubis_ws/src/rubis_autorunner/scripts/minicar_lane_keeping/terminate.sh"
+terminate_script_path: "~/rubis_ws/src/rubis_autorunner/scripts/minicar_lane_keeping/terminate_desktop.sh"
 # step_# : 
 #     [0] pacakge name
 #     [1] target name( node name or launch script name )
diff --git a/rubis_ws/src/rubis_autorunner/cfg/minicar_lane_keeping/minicar_lene_keeping_params.yaml b/rubis_ws/src/rubis_autorunner/cfg/minicar_lane_keeping/minicar_lene_keeping_params.yaml
index 17751521..b2066de6 100644
--- a/rubis_ws/src/rubis_autorunner/cfg/minicar_lane_keeping/minicar_lene_keeping_params.yaml
+++ b/rubis_ws/src/rubis_autorunner/cfg/minicar_lane_keeping/minicar_lene_keeping_params.yaml
@@ -15,7 +15,7 @@ camera_image:
   frequency: 10
   
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/ray_ground_filter.csv"
   # rate: 10 # Frequency replaces rate
   task_minimum_inter_release_time: 100000000
@@ -24,7 +24,7 @@ camera_image:
 
 ray_ground_filter:
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/ray_ground_filter.csv"
   rate: 10 
   task_minimum_inter_release_time: 100000000
@@ -34,7 +34,7 @@ ray_ground_filter:
 # Localization
 voxel_grid_filter:
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/voxel_grid_filter.csv"
   rate: 10 
   task_minimum_inter_release_time: 100000000
@@ -45,22 +45,17 @@ ndt_matching:
   localizer: "velodyne"
 
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/ndt_matching.csv"
   rate: 10
   task_minimum_inter_release_time: 100000000
   task_execution_time: 70000000
   task_relative_deadline: 100000000
-  gpu_scheduling_flag: 0
-  gpu_profiling_flag: 0
-  gpu_execution_time_filename: "~/Documents/gpu_profiling/test_ndt_matching_execution_time.csv"
-  gpu_response_time_filename: "~/Documents/gpu_profiling/test_ndt_matching_response_time.csv"
-  gpu_deadline_filename: "~/Documents/gpu_deadline/ndt_matching_gpu_deadline.csv"
 
 # Planning
 op_global_planner:
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_global_planner.csv"
   rate: 25 #25
   task_minimum_inter_release_time: 100000000
@@ -78,7 +73,7 @@ op_common_params:
 
 op_trajectory_generator:
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_trajectory_generator.csv"
   rate: 100 #100
   task_minimum_inter_release_time: 10000000
@@ -87,7 +82,7 @@ op_trajectory_generator:
 
 op_trajectory_evaluator:
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_trajectory_evaluator.csv"
   rate: 100 #100
   task_minimum_inter_release_time: 100000000
@@ -103,7 +98,7 @@ op_trajectory_evaluator:
 
 op_behavior_selector:
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_behavior_selector.csv"
   rate: 100 #100
   task_minimum_inter_release_time: 10000000
@@ -117,7 +112,7 @@ op_behavior_selector:
 # Control
 pure_pursuit:
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/pure_pursuit.csv"
   rate: 30 #30
   task_minimum_inter_release_time: 33333333
@@ -128,7 +123,7 @@ pure_pursuit:
 
 twist_filter:
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/twist_filter.csv"
   rate: 10
   task_minimum_inter_release_time: 100000000
@@ -137,7 +132,7 @@ twist_filter:
 
 twist_gate:
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/twist_gate.csv"
   rate: 10
   task_minimum_inter_release_time: 100000000
@@ -148,7 +143,7 @@ twist_gate:
 # Others
 vel_relay:
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/vel_relay.csv"
   rate: 10
   task_minimum_inter_release_time: 100000000
@@ -157,7 +152,7 @@ vel_relay:
 
 pose_relay:
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/pose_relay.csv"
   rate: 10
   task_minimum_inter_release_time: 100000000
diff --git a/rubis_ws/src/rubis_autorunner/cfg/rubis_testbed_autorunner/rubis_testbed_autorunner.yaml b/rubis_ws/src/rubis_autorunner/cfg/rubis_testbed_autorunner/rubis_testbed_autorunner.yaml
index 7c9a8b8d..b4235314 100644
--- a/rubis_ws/src/rubis_autorunner/cfg/rubis_testbed_autorunner/rubis_testbed_autorunner.yaml
+++ b/rubis_ws/src/rubis_autorunner/cfg/rubis_testbed_autorunner/rubis_testbed_autorunner.yaml
@@ -1,5 +1,5 @@
 total_step_num: 5
-terminate_script_path: "~/rubis_ws/src/rubis_autorunner/scripts/rubis_testbed_autorunner/terminate.sh"
+terminate_script_path: "~/rubis_ws/src/rubis_autorunner/scripts/rubis_testbed_autorunner/terminate_desktop.sh"
 # step_# : 
 #     [0] pacakge name
 #     [1] target name( node name or launch script name )
diff --git a/rubis_ws/src/rubis_autorunner/cfg/rubis_testbed_autorunner/rubis_testbed_autorunner_params.yaml b/rubis_ws/src/rubis_autorunner/cfg/rubis_testbed_autorunner/rubis_testbed_autorunner_params.yaml
index 59cfa745..ccd8802d 100644
--- a/rubis_ws/src/rubis_autorunner/cfg/rubis_testbed_autorunner/rubis_testbed_autorunner_params.yaml
+++ b/rubis_ws/src/rubis_autorunner/cfg/rubis_testbed_autorunner/rubis_testbed_autorunner_params.yaml
@@ -14,7 +14,7 @@ voxel_grid_filter:
   instance_mode: 0
 
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/voxel_grid_filter.csv"
   rate: 10
   task_minimum_inter_release_time: 100_000_000
@@ -33,22 +33,17 @@ ndt_matching:
   localizer: "velodyne"
 
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/ndt_matching.csv"
   rate: 10
   task_minimum_inter_release_time: 100_000_000
   task_execution_time: 80_000_000
   task_relative_deadline: 80_000_000
-  gpu_scheduling_flag: 0
-  gpu_profiling_flag: 0
-  gpu_execution_time_filename: "~/Documents/gpu_profiling/test_ndt_matching_execution_time.csv"
-  gpu_response_time_filename: "~/Documents/gpu_profiling/test_ndt_matching_response_time.csv"
-  gpu_deadline_filename: "~/Documents/gpu_deadline/ndt_matching_gpu_deadline.csv"
 
 # Detection
 ray_ground_filter_center:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/ray_ground_filter.csv"
   rate: 10 
   task_minimum_inter_release_time: 100_000_000
@@ -58,37 +53,27 @@ ray_ground_filter_center:
 
 lidar_euclidean_cluster_detect:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/lidar_euclidean_cluster_detect.csv"
   rate: 10
   task_minimum_inter_release_time: 200_000_000
   task_execution_time: 50_000_000
   task_relative_deadline: 200_000_000
-  gpu_scheduling_flag: 0
-  gpu_profiling_flag: 0
-  gpu_execution_time_filename: "~/Documents/gpu_profiling/test_clustering_execution_time.csv"
-  gpu_response_time_filename: "~/Documents/gpu_profiling/test_clustering_response_time.csv"
-  gpu_deadline_filename: "~/Documents/gpu_deadline/clustering_gpu_deadline.csv"
 
 vision_darknet_detect:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/vision_darknet_detect.csv"
   rate: 10
   task_minimum_inter_release_time: 100_000_000
   task_execution_time: 75_000_000
   task_relative_deadline: 80_000_000
-  gpu_scheduling_flag: 0
-  gpu_profiling_flag: 0
-  gpu_execution_time_filename: "~/Documents/gpu_profiling/test_yolo_execution_time.csv"
-  gpu_response_time_filename: "~/Documents/gpu_profiling/test_yolo_response_time.csv"
-  gpu_deadline_filename: "~/Documents/gpu_deadline/yolo_gpu_deadline.csv"
   network_definition_file: "~/autoware.ai/autoware_files/vision/yolov3-320.cfg"
   pretrained_model_file: "~/autoware.ai/autoware_files/vision/yolov3-320.weights"
 
 imm_ukf_pda_track:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/imm_ukf_pda_track.csv"
   rate: 10
   task_minimum_inter_release_time: 200_000_000
@@ -98,7 +83,7 @@ imm_ukf_pda_track:
 # Planning
 op_global_planner:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_global_planner.csv"
   rate: 25 #25
   task_minimum_inter_release_time: 100_000_000
@@ -115,7 +100,7 @@ op_common_params:
 
 op_trajectory_generator:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_trajectory_generator.csv"
   rate: 100 #100
   task_minimum_inter_release_time: 100_000_000
@@ -124,7 +109,7 @@ op_trajectory_generator:
 
 op_trajectory_evaluator:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_trajectory_evaluator.csv"
   rate: 100 #100
   task_minimum_inter_release_time: 100_000_000
@@ -140,7 +125,7 @@ op_trajectory_evaluator:
 
 op_behavior_selector:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_behavior_selector.csv"
   rate: 100 #100
   task_minimum_inter_release_time: 100_000_000
@@ -153,7 +138,7 @@ op_behavior_selector:
 
 op_motion_predictor:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_motion_predictor.csv"
   rate: 25 #25
   task_minimum_inter_release_time: 100_000_000
@@ -162,9 +147,8 @@ op_motion_predictor:
 
 # Control
 pure_pursuit:
-  instance_mode: 0
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/pure_pursuit.csv"
   rate: 30 #30
   task_minimum_inter_release_time: 100_000_000
@@ -174,9 +158,8 @@ pure_pursuit:
   dynamic_params_path: "~/autoware.ai/autoware_files/lgsvl_file/parameter/lgsvl_pure_pursuit.yaml"
 
 twist_filter:
-  instance_mode: 0
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/twist_filter.csv"
   rate: 10
   task_minimum_inter_release_time: 100_000_000
@@ -184,9 +167,8 @@ twist_filter:
   task_relative_deadline: 100_000_000
 
 twist_gate:
-  instance_mode: 0
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/twist_gate.csv"
   rate: 10
   task_minimum_inter_release_time: 100_000_000
@@ -196,9 +178,8 @@ twist_gate:
 
 # Others
 lidar_republisher:
-  instance_mode: 0
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/lidar_republisher.csv"
   rate: 10
   task_minimum_inter_release_time: 100_000_000
@@ -207,7 +188,7 @@ lidar_republisher:
 
 vel_relay:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/vel_relay.csv"
   rate: 10
   task_minimum_inter_release_time: 100_000_000
@@ -215,9 +196,8 @@ vel_relay:
   task_relative_deadline: 100_000_000
 
 pose_relay:
-  instance_mode: 0
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/pose_relay.csv"
   rate: 10
   task_minimum_inter_release_time: 100_000_000
@@ -226,7 +206,7 @@ pose_relay:
 
 republish:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/republish.csv"
   rate: 10
   task_minimum_inter_release_time: 100_000_000
diff --git a/rubis_ws/src/rubis_autorunner/cfg/tutorial_autorunner/tutorial_autorunner.yaml b/rubis_ws/src/rubis_autorunner/cfg/tutorial_autorunner/tutorial_autorunner.yaml
index 7bbaa3d4..89161057 100644
--- a/rubis_ws/src/rubis_autorunner/cfg/tutorial_autorunner/tutorial_autorunner.yaml
+++ b/rubis_ws/src/rubis_autorunner/cfg/tutorial_autorunner/tutorial_autorunner.yaml
@@ -1,5 +1,5 @@
 total_step_num: 5
-terminate_script_path: "~/rubis_ws/src/rubis_autorunner/scripts/tutorial/terminate.sh"
+terminate_script_path: "~/rubis_ws/src/rubis_autorunner/scripts/tutorial/terminate_desktop.sh"
 # step_# : 
 #     [0] pacakge name
 #     [1] target name( node name or launch script name )
diff --git a/rubis_ws/src/rubis_autorunner/cfg/tutorial_autorunner/tutorial_autoruuner_params.yaml b/rubis_ws/src/rubis_autorunner/cfg/tutorial_autorunner/tutorial_autoruuner_params.yaml
index 5ff124da..39f6cf02 100644
--- a/rubis_ws/src/rubis_autorunner/cfg/tutorial_autorunner/tutorial_autoruuner_params.yaml
+++ b/rubis_ws/src/rubis_autorunner/cfg/tutorial_autorunner/tutorial_autoruuner_params.yaml
@@ -12,7 +12,7 @@
 # Localization
 voxel_grid_filter:
   task_scheduling_flag: 0
-  task_profiling_flag: 0
+  
   task_response_time_filename: "~/Documents/profiling/response_time/voxel_grid_filter.csv"
   rate: 10
   task_minimum_inter_release_time: 100_000_000
@@ -29,17 +29,12 @@ ndt_matching:
   localizer: "velodyne"
 
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/ndt_matching.csv"
   rate: 10
   task_minimum_inter_release_time: 100_000_000
   task_execution_time: 80_000_000
   task_relative_deadline: 80_000_000
-  gpu_scheduling_flag: 0
-  gpu_profiling_flag: 1
-  gpu_execution_time_filename: "~/Documents/gpu_profiling/test_ndt_matching_execution_time.csv"
-  gpu_response_time_filename: "~/Documents/gpu_profiling/test_ndt_matching_response_time.csv"
-  gpu_deadline_filename: "~/Documents/gpu_deadline/ndt_matching_gpu_deadline.csv"
 
 # Detection
 compare_map_filter:
@@ -48,7 +43,7 @@ compare_map_filter:
   max_clipping_height: 0.5
 
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/compare_map_filter.csv"
   rate: 10
   task_minimum_inter_release_time: 200_000_000
@@ -58,37 +53,27 @@ compare_map_filter:
 
 lidar_euclidean_cluster_detect:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/lidar_euclidean_cluster_detect.csv"
   rate: 10
   task_minimum_inter_release_time: 200_000_000
   task_execution_time: 50_000_000
   task_relative_deadline: 200_000_000
-  gpu_scheduling_flag: 0
-  gpu_profiling_flag: 1
-  gpu_execution_time_filename: "~/Documents/gpu_profiling/test_clustering_execution_time.csv"
-  gpu_response_time_filename: "~/Documents/gpu_profiling/test_clustering_response_time.csv"
-  gpu_deadline_filename: "~/Documents/gpu_deadline/clustering_gpu_deadline.csv"
 
 vision_darknet_detect:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/vision_darknet_detect.csv"
   rate: 10
   task_minimum_inter_release_time: 100_000_000
   task_execution_time: 75_000_000
   task_relative_deadline: 80_000_000
-  gpu_scheduling_flag: 0
-  gpu_profiling_flag: 1
-  gpu_execution_time_filename: "~/Documents/gpu_profiling/test_yolo_execution_time.csv"
-  gpu_response_time_filename: "~/Documents/gpu_profiling/test_yolo_response_time.csv"
-  gpu_deadline_filename: "~/Documents/gpu_deadline/yolo_gpu_deadline.csv"
   network_definition_file: "~/autoware.ai/autoware_files/vision/yolov3-tiny.cfg"
   pretrained_model_file: "~/autoware.ai/autoware_files/vision/yolov3-tiny.weights"
 
 imm_ukf_pda_track:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/imm_ukf_pda_track.csv"
   rate: 10
   task_minimum_inter_release_time: 200_000_000
@@ -98,7 +83,7 @@ imm_ukf_pda_track:
 # Planning
 op_global_planner:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_global_planner.csv"
   rate: 25 #25
   task_minimum_inter_release_time: 100_000_000
@@ -115,7 +100,7 @@ op_common_params:
 
 op_trajectory_generator:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_trajectory_generator.csv"
   rate: 100 #100
   task_minimum_inter_release_time: 100_000_000
@@ -124,7 +109,7 @@ op_trajectory_generator:
 
 op_trajectory_evaluator:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_trajectory_evaluator.csv"
   rate: 100 #100
   task_minimum_inter_release_time: 100_000_000
@@ -140,7 +125,7 @@ op_trajectory_evaluator:
 
 op_behavior_selector:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_behavior_selector.csv"
   rate: 100 #100
   task_minimum_inter_release_time: 100_000_000
@@ -153,7 +138,7 @@ op_behavior_selector:
 
 op_motion_predictor:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/op_motion_predictor.csv"
   rate: 25 #25
   task_minimum_inter_release_time: 100_000_000
@@ -163,7 +148,7 @@ op_motion_predictor:
 # Control
 pure_pursuit:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/pure_pursuit.csv"
   rate: 30 #30
   task_minimum_inter_release_time: 100_000_000
@@ -174,7 +159,7 @@ pure_pursuit:
 
 twist_filter:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/twist_filter.csv"
   rate: 10
   task_minimum_inter_release_time: 100_000_000
@@ -183,7 +168,7 @@ twist_filter:
 
 twist_gate:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/twist_gate.csv"
   rate: 10
   task_minimum_inter_release_time: 100_000_000
@@ -194,7 +179,7 @@ twist_gate:
 # Others
 lidar_republisher:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/lidar_republisher.csv"
   rate: 10
   task_minimum_inter_release_time: 100_000_000
@@ -203,7 +188,7 @@ lidar_republisher:
 
 vel_relay:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/vel_relay.csv"
   rate: 10
   task_minimum_inter_release_time: 100_000_000
@@ -212,7 +197,7 @@ vel_relay:
 
 pose_relay:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/pose_relay.csv"
   rate: 10
   task_minimum_inter_release_time: 100_000_000
@@ -221,7 +206,7 @@ pose_relay:
 
 republish:
   task_scheduling_flag: 0
-  task_profiling_flag: 1
+  
   task_response_time_filename: "~/Documents/profiling/response_time/republish.csv"
   rate: 10
   task_minimum_inter_release_time: 100_000_000
diff --git a/rubis_ws/src/rubis_autorunner/include/carla_autorunner/carla_autorunner.h b/rubis_ws/src/rubis_autorunner/include/carla_autorunner/carla_autorunner.h
new file mode 100644
index 00000000..66bf4692
--- /dev/null
+++ b/rubis_ws/src/rubis_autorunner/include/carla_autorunner/carla_autorunner.h
@@ -0,0 +1,32 @@
+#include <ros/ros.h>
+#include <ros_autorunner_lib/ros_autorunner.h>
+
+// Include subscribe message type
+#include <sensor_msgs/PointCloud2.h>
+#include <autoware_msgs/NDTStat.h>
+#include <autoware_msgs/DetectedObjectArray.h>
+#include <visualization_msgs/MarkerArray.h>
+#include <geometry_msgs/PoseStamped.h>
+#include <geometry_msgs/PoseWithCovarianceStamped.h>
+#define SLEEP_PERIOD 1
+
+class CarlaAutorunner : public AutorunnerBase{
+private:    
+    ros::NodeHandle     nh_;
+    ROSAutorunner       ros_autorunner_;
+private:
+    virtual void register_subscribers();
+private:
+    void points_raw_cb(const sensor_msgs::PointCloud2& msg);
+    void ndt_pose_cb(const geometry_msgs::PoseStamped& msg);
+    void detection_cb(const autoware_msgs::DetectedObjectArray& msg);
+    void behavior_state_cb(const visualization_msgs::MarkerArray& msg);
+
+public:
+    Sub_v               sub_v_;
+    ros::Publisher      initial_pose_pub_;
+public:
+    CarlaAutorunner() {}
+    CarlaAutorunner(ros::NodeHandle nh) : nh_(nh){}
+    virtual void Run();
+};
diff --git a/rubis_ws/src/rubis_autorunner/include/cubetown_autorunner/cubetown_autorunner.h b/rubis_ws/src/rubis_autorunner/include/cubetown_autorunner/cubetown_autorunner.h
index a7a7086a..84f62d3a 100644
--- a/rubis_ws/src/rubis_autorunner/include/cubetown_autorunner/cubetown_autorunner.h
+++ b/rubis_ws/src/rubis_autorunner/include/cubetown_autorunner/cubetown_autorunner.h
@@ -6,6 +6,7 @@
 #include <autoware_msgs/NDTStat.h>
 #include <autoware_msgs/DetectedObjectArray.h>
 #include <visualization_msgs/MarkerArray.h>
+#include <geometry_msgs/PoseStamped.h>
 #include <geometry_msgs/PoseWithCovarianceStamped.h>
 #define SLEEP_PERIOD 1
 
@@ -17,7 +18,7 @@ private:
     virtual void register_subscribers();
 private:
     void points_raw_cb(const sensor_msgs::PointCloud2& msg);
-    void ndt_stat_cb(const autoware_msgs::NDTStat& msg);
+    void ndt_pose_cb(const geometry_msgs::PoseStamped& msg);
     void detection_cb(const autoware_msgs::DetectedObjectArray& msg);
     void behavior_state_cb(const visualization_msgs::MarkerArray& msg);
 
diff --git a/rubis_ws/src/rubis_autorunner/launch/carla_full_autorunner.launch b/rubis_ws/src/rubis_autorunner/launch/carla_full_autorunner.launch
new file mode 100644
index 00000000..a91009bc
--- /dev/null
+++ b/rubis_ws/src/rubis_autorunner/launch/carla_full_autorunner.launch
@@ -0,0 +1,4 @@
+<launch>
+    <rosparam command="load" file="$(env USER_HOME)/rubis_ws/src/rubis_autorunner/cfg/carla_autorunner/carla_full_autorunner.yaml" />
+    <node pkg="rubis_autorunner" type="carla_full_autorunner" name="carla_full_autorunner"/>
+</launch>
\ No newline at end of file
diff --git a/rubis_ws/src/rubis_autorunner/launch/carla_lkas_autorunner.launch b/rubis_ws/src/rubis_autorunner/launch/carla_lkas_autorunner.launch
new file mode 100644
index 00000000..41f53b5f
--- /dev/null
+++ b/rubis_ws/src/rubis_autorunner/launch/carla_lkas_autorunner.launch
@@ -0,0 +1,4 @@
+<launch>
+    <rosparam command="load" file="$(env USER_HOME)/rubis_ws/src/rubis_autorunner/cfg/carla_autorunner/carla_lkas_autorunner.yaml" />
+    <node pkg="rubis_autorunner" type="carla_lkas_autorunner" name="carla_lkas_autorunner" output="screen" />
+</launch>
\ No newline at end of file
diff --git a/rubis_ws/src/rubis_autorunner/scripts/carla_autorunner/_carla_autorunner_1_sensing.launch b/rubis_ws/src/rubis_autorunner/scripts/carla_autorunner/_carla_autorunner_1_sensing.launch
new file mode 100644
index 00000000..50ce0be4
--- /dev/null
+++ b/rubis_ws/src/rubis_autorunner/scripts/carla_autorunner/_carla_autorunner_1_sensing.launch
@@ -0,0 +1,46 @@
+<launch>
+  <rosparam command="load" file="$(env USER_HOME)/rubis_ws/src/rubis_autorunner/cfg/carla_autorunner/carla_autorunner_params.yaml" />
+
+  <arg name="lidar_input_topic" default="/points_raw_origin"/>
+  <arg name="lidar_output_topic" default="/points_raw"/>
+
+  <!-- Map TF Publisher -->	
+	<!-- <include file="$(env USER_HOME)/autoware.ai/autoware_files/data/tf/tf.launch" /> -->
+  
+  <!-- Vector Map Loader -->
+  <!-- Default -->
+	<!-- <node pkg="map_file" type="vector_map_loader" name="vector_map_loader" args="
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/220824_carla_town04/dtlane.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/220824_carla_town04/lane.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/220824_carla_town04/node.csv 
+	    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/220824_carla_town04/point.csv"/> -->
+
+  <!-- carla town04 straight -->
+  <!-- <node pkg="map_file" type="vector_map_loader" name="vector_map_loader" args="
+    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/230209_carla_town04_straight/dtlane.csv 
+    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/230209_carla_town04_straight/lane.csv 
+    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/230209_carla_town04_straight/node.csv 
+    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/230209_carla_town04_straight/point.csv"/> -->
+  
+  <!-- carla town04 circle(not connected) -->
+  <node pkg="map_file" type="vector_map_loader" name="vector_map_loader" args="
+    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/230209_carla_town04_circle_not_connected/dtlane.csv 
+    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/230209_carla_town04_circle_not_connected/lane.csv 
+    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/230209_carla_town04_circle_not_connected/node.csv 
+    $(env USER_HOME)/autoware.ai/autoware_files/vector_map/230209_carla_town04_circle_not_connected/point.csv"/>
+
+  <!-- Point Map Loader -->
+	<include file="$(find map_file)/launch/points_map_loader.launch">
+    <arg name="scene_num" value="noupdate" />
+    <arg name="path_pcd" value="$(env USER_HOME)/autoware.ai/autoware_files/points_map/Town04_Carla.pcd"/>
+  </include>
+
+  <!-- Re-publishing simulator/camera_node/image/compressed topic to /image_raw as expected by Autoware -->
+  <node name="republish" type="republish" pkg="image_transport" output="screen" args="compressed in:=/image_raw_origin out:=/image_raw"  />
+
+  <include file="$(find rubis_pkg)/launch/lidar_republisher_params.launch">
+    <arg name="input_topic" value="$(arg lidar_input_topic)" />
+    <arg name="output_topic" value="$(arg lidar_output_topic)" />
+  </include>
+
+</launch>
\ No newline at end of file
diff --git a/rubis_ws/src/rubis_autorunner/scripts/carla_autorunner/_carla_autorunner_2_localization.launch b/rubis_ws/src/rubis_autorunner/scripts/carla_autorunner/_carla_autorunner_2_localization.launch
new file mode 100644
index 00000000..9f6dca50
--- /dev/null
+++ b/rubis_ws/src/rubis_autorunner/scripts/carla_autorunner/_carla_autorunner_2_localization.launch
@@ -0,0 +1,54 @@
+<launch>
+  <!-- carla town04 default-->
+  <!-- <arg name="init_x" value="258.4" />
+  <arg name="init_y" value="206.5" />
+  <arg name="init_z" value="0.0" />
+  <arg name="init_roll" value="0.0" />
+  <arg name="init_pitch" value="0.0" />
+  <arg name="init_yaw" value="1.54" /> -->
+
+  <!-- carla town04 circle-->
+  <arg name="init_x" value="314.065" />
+  <arg name="init_y" value="129.676" />
+  <arg name="init_z" value="0.0" />
+  <arg name="init_roll" value="0.0" />
+  <arg name="init_pitch" value="0.0" />
+  <arg name="init_yaw" value="1.54" />
+
+  <!-- vel/pose connect -->
+  <arg name="topic_pose_stamped" default="/ndt_pose" />
+  <arg name="topic_twist_stamped" default="/estimate_twist" /> 
+  <!-- <arg name="topic_twist_stamped" default="/odom_twist" /> -->
+
+  <!-- points downsampler -->
+  <include file="$(find points_downsampler)/launch/voxel_grid_filter_params.launch" />
+
+  <!-- ndt matching kalman filter parameters -->
+  <rosparam command="load" file="$(env USER_HOME)/rubis_ws/src/rubis_autorunner/cfg/cubetown_autorunner/kalman_filter.yaml" />
+
+  <!-- ndt_matching --><!-- pcl_generic=0, pcl_anh=1, pcl_anh_gpu=2, pcl_openmp=3 -->
+  <include file="$(find lidar_localizer)/launch/ndt_matching_params.launch">
+    <arg name="method_type" value="0" /> 
+    <arg name="get_height" value="true" /> 
+  </include>
+
+  <!-- ndt config -->
+  <node pkg="rostopic" type="rostopic" name="config_ndt"
+  args="pub /config/ndt autoware_config_msgs/ConfigNDT
+  '{header: {seq: 8, stamp: {secs: 0, nsecs: 0}, frame_id: ''},
+    init_pos_gnss: 0,
+    x: $(arg init_x),
+    y: $(arg init_y),
+    z: $(arg init_z),
+    roll: $(arg init_roll), 
+    pitch: $(arg init_pitch),
+    yaw: $(arg init_yaw),
+    use_predict_pose: 1,
+    error_threshold: 0.05,
+    resolution: 1.0,
+    step_size: 0.5,
+    trans_epsilon: 0.01,
+    max_iterations: 2}
+  '"/>
+
+</launch>
diff --git a/rubis_ws/src/rubis_autorunner/scripts/carla_autorunner/_carla_autorunner_2_localization_gicp.launch b/rubis_ws/src/rubis_autorunner/scripts/carla_autorunner/_carla_autorunner_2_localization_gicp.launch
new file mode 100644
index 00000000..df533eb6
--- /dev/null
+++ b/rubis_ws/src/rubis_autorunner/scripts/carla_autorunner/_carla_autorunner_2_localization_gicp.launch
@@ -0,0 +1,42 @@
+<launch>
+  <!-- Town04 -->
+  <arg name="init_x" value="258.4" />
+  <arg name="init_y" value="206.5" />
+  <arg name="init_z" value="0.0" />
+  <arg name="init_roll" value="0.0" />
+  <arg name="init_pitch" value="0.0" />
+  <arg name="init_yaw" value="1.54" />
+
+  <!-- points downsampler -->
+  <include file="$(find points_downsampler)/launch/points_downsample.launch" />
+
+  <!-- gicp_localizer -->
+  <arg name="enable_gnss_backup" default="false" /> 
+  <arg name="base_frame" default="base_link" doc="Vehicle reference frame" />
+  <!-- <arg name="sensor_frame" default="velodyne" doc="Vehicle reference frame" /> -->
+  <arg name="sensor_frame" default="ego_vehicle/lidar" doc="Vehicle reference frame" />
+  <arg name="resolution" default="2.0" doc="The ND voxel grid resolution" />
+  <arg name="neighborSearchMethod" default="DIRECT7"/>
+
+  <arg name="numthreads" default="4" doc="vgicp threads num" />
+  <arg name="leafsize" default="0.01" doc="point map downsample leafsize" />
+
+  <node pkg="gicp_localizer" type="gicp_localizer_node" name="gicp_localizer_node">
+    <param name="init_x" value="$(arg init_x)" />
+    <param name="init_y" value="$(arg init_y)" />
+    <param name="init_z" value="$(arg init_z)" />
+    <param name="init_roll" value="$(arg init_roll)" />
+    <param name="init_pitch" value="$(arg init_pitch)" />
+    <param name="init_yaw" value="$(arg init_yaw)" />
+
+    <param name="enable_gnss_backup" value="$(arg enable_gnss_backup)" />
+    <param name="gnss_backup_threshold" value="7.0" />
+
+    <param name="base_frame" value="$(arg base_frame)" />
+    <param name="resolution" value="$(arg resolution)" />
+    <param name="neighborSearchMethod" value="$(arg neighborSearchMethod)" />
+    <param name="numthreads" value="$(arg numthreads)" />
+    <param name="leafsize" value="$(arg leafsize)" />
+  </node>
+
+</launch>
diff --git a/rubis_ws/src/rubis_autorunner/scripts/carla_autorunner/_carla_autorunner_3_detection.launch b/rubis_ws/src/rubis_autorunner/scripts/carla_autorunner/_carla_autorunner_3_detection.launch
new file mode 100644
index 00000000..8bb60870
--- /dev/null
+++ b/rubis_ws/src/rubis_autorunner/scripts/carla_autorunner/_carla_autorunner_3_detection.launch
@@ -0,0 +1,64 @@
+<launch>
+  <!-- Ground Filter -->
+  <!-- <include file="$(find points_preprocessor)/launch/compare_map_filter_params.launch">
+     <arg name="input_point_topic" value="/points_raw" />
+    <arg name="input_map_topic" value="/points_map" />
+    <arg name="output_match_topic" value="/points_ground_center" />
+    <arg name="output_unmatch_topic" value="/points_no_ground_center" />
+  </include> -->
+
+  <include file="$(find points_preprocessor)/launch/ray_ground_filter_params.launch">
+    <arg name="input_point_topic" value="/points_raw" />  <!-- input_point_topic, ground filtering will be performed over the pointcloud in this topic. -->
+    <arg name="base_frame" value="base_link" />  <!-- Coordinate system to perform transform (default base_link) -->
+    <arg name="max_clipping_height" value="5" />  <!-- Remove Points above this height value (default 2.0 meters) -->
+    <arg name="min_clipping_height" value="-0.5" />  <!-- Remove Points below this height value (default -0.5 meters) -->
+    <arg name="min_point_distance" value="3.5" />  <!-- Removes Points closer than this distance from the sensor origin (default 1.85 meters) -->
+    <arg name="radial_divider_angle" value="0.08" />  <!-- Angle of each Radial division on the XY Plane (default 0.08 degrees)-->
+    <arg name="concentric_divider_distance" value="0.0" />  <!-- Distance of each concentric division on the XY Plane (default 0.0 meters) -->
+    <arg name="local_max_slope" value="8" />  <!-- Max Slope of the ground between Points (default 8 degrees) -->
+    <arg name="general_max_slope" value="1" />  <!-- Max Slope of the ground in the entire PointCloud, used when reclassification occurs (default 5 degrees)-->
+    <arg name="min_height_threshold" value="0.05" />  <!-- Minimum height threshold between points (default 0.05 meters)-->
+    <arg name="reclass_distance_threshold" value="0.02" />  <!-- Distance between points at which re classification will occur (default 0.2 meters)-->
+    <arg name="no_ground_point_topic" value="/points_no_ground" />
+    <arg name="ground_point_topic" value="/points_ground" />
+  </include>
+  
+  <!-- lidar_euclidean_cluster_detect-->
+  <include file="$(find lidar_euclidean_cluster_detect)/launch/lidar_euclidean_cluster_detect.launch">
+    <arg name="points_node" value="/points_no_ground_center" />
+    <arg name="remove_ground" value="true" />
+    <arg name="downsample_cloud" value="false" />
+    <arg name="leaf_size" value="0.68" />
+    <arg name="cluster_size_min" value="1" />
+    <arg name="cluster_size_max" value="100000" />
+    <arg name="sync" value="false" />
+    <arg name="use_diffnormals" value="false" />
+    <arg name="pose_estimation" value="false" />
+    <arg name="clip_min_height" value="-10.0" />
+    <arg name="clip_max_height" value="10" />
+    <arg name="keep_lanes" value="false" />
+    <arg name="keep_lane_left_distance" value="5" />
+    <arg name="keep_lane_right_distance" value="5" />
+    <arg name="cluster_merge_threshold" value="1.5" />
+    <arg name="clustering_distance" value="0.75" />
+    <arg name="use_vector_map" value="false" />
+    <arg name="wayarea_gridmap_layer" value="wayarea" />
+    <arg name="output_frame" value="ego_vehicle/lidar" />
+    <arg name="remove_points_upto" value="0.0" />
+    <arg name="use_gpu" value="true" />    
+    <arg name="use_multiple_thres" value="false"/>
+    <arg name="clustering_ranges" value="[15,30,45,60]"/>
+    <arg name="clustering_distances"
+         value="[0.5,1.1,1.6,2.1,2.6]"/>    
+  </include>
+  
+  <!-- vision_darknet_detect -->
+  <!-- <include file="$(find vision_darknet_detect)/launch/vision_darknet_detect_parameter.launch">
+    <arg name="gpu_device_id" value="0"/>
+    <arg name="score_threshold" value="0.5"/>
+    <arg name="nms_threshold" value="0.45"/>
+    <arg name="names_file" value="$(find vision_darknet_detect)/darknet/cfg/coco.names"/>
+    <arg name="camera_id" value="/"/>
+    <arg name="image_src" value="/image_raw"/>    
+  </include> -->
+</launch>
\ No newline at end of file
diff --git a/rubis_ws/src/rubis_autorunner/scripts/carla_autorunner/_carla_autorunner_4_planning.launch b/rubis_ws/src/rubis_autorunner/scripts/carla_autorunner/_carla_autorunner_4_planning.launch
new file mode 100644
index 00000000..4f5d25e6
--- /dev/null
+++ b/rubis_ws/src/rubis_autorunner/scripts/carla_autorunner/_carla_autorunner_4_planning.launch
@@ -0,0 +1,118 @@
+<launch>
+  <!-- op_global_planning -->
+  <include file="$(find op_global_planner)/launch/op_global_planner.launch">
+    <arg name="pathDensity"           value="1" /> <!-- distance between each two waypoints-->
+    <arg name="enableSmoothing"       value="false" /> <!-- 1 or 0 -->
+    <arg name="enableLaneChange"      value="false" /> <!-- 1 or 0 -->
+    <arg name="enableRvizInput"       value="true" /> <!-- 1 or 0 -->
+    <arg name="enableReplan"          value="false" /> <!-- 1 or 0 -->  
+    <arg name="velocitySource"        value="1" /> <!-- read velocities from (0- Odometry, 1- autoware current_velocities, 2- car_info) "" -->
+    <arg name="mapSource"             value="0" /> <!-- Autoware=0, Vector Map Folder=1, kml file=2 -->
+    <arg name="mapFileName"           value="" /> <!-- incase of kml map source -->
+    <!-- Town04 -->
+    <!-- <arg name="use_static_goal"       value="true" />
+    <arg name="goal_pose_x"           value="284.118" />
+    <arg name="goal_pose_y"           value="172.178" />
+    <arg name="goal_pose_z"           value="0.0" />
+    <arg name="goal_ori_x"            value="0.0" />
+    <arg name="goal_ori_y"            value="0.0" />
+    <arg name="goal_ori_z"            value="0.99" />
+    <arg name="goal_ori_w"            value="0.02" /> -->
+
+    <!-- Town04 circle -->
+    <arg name="use_static_goal"       value="true" />
+    <arg name="goal_pose_x"           value="302.250" />
+    <arg name="goal_pose_y"           value="118.089" />
+    <arg name="goal_pose_z"           value="0.0" />
+    <arg name="goal_ori_x"            value="0.0" />
+    <arg name="goal_ori_y"            value="0.0" />
+    <arg name="goal_ori_z"            value="-0.015" />
+    <arg name="goal_ori_w"            value="1.000" />
+  </include>
+
+  <!-- op_common_params  -->
+  <include file="$(find op_local_planner)/launch/op_common_params_parameter.launch">
+    <!-- Included in app window -->
+    <arg name="horizonDistance"                 default="120"  />     <!-- Horizon -->
+    <arg name="maxLocalPlanDistance"            default="80" />       <!-- Plan Distance-->
+    <arg name="pathDensity"                     default="0.5" />      <!-- Path Density-->
+    <arg name="enableFollowing"                 default="true" />     <!-- Enable Following -->
+    <arg name="enableSwerving"                  default="true"  />    <!-- Enable Avoidance -->
+    <arg name="minFollowingDistance"            default="30.0"  />    <!-- Follow Distance --> <!-- should be bigger than Distance to follow -->  
+    <arg name="minDistanceToAvoid"              default="20.0" />     <!-- Avoiding Distance --> <!-- should be smaller than minFollowingDistance and larger than maxDistanceToAvoid -->
+    <arg name="maxDistanceToAvoid"              default="0.1"  />     <!-- Avoidnace Limit--> <!-- should be smaller than minDistanceToAvoid -->
+    <arg name="enableStopSignBehavior"          default="false" />    <!-- Enable Stop Sign Stop-->
+    <arg name="enableTrafficLightBehavior"      default="true" />     <!-- Enable Traffic Light -->
+    <arg name="enableLaneChange"                default="false" />    <!-- Enable Lane Change -->
+    <arg name="horizontalSafetyDistance"        default="1"  />       <!-- Lateral Safety --> 
+    <arg name="verticalSafetyDistance"          default="2"  />       <!-- Longitudinal Safet y-->
+    <arg name="velocitySource"                  default="1" />        <!-- read velocities from (0- Odometry, 1- autoware current_velocities, 2- car_info) "" -->   
+    <!-- Vehicle Specification -->
+    <arg name="width"                           default="1.85"  />
+    <arg name="length"                          default="4.2"  />
+    <arg name="wheelBaseLength"                 default="2.7"  />
+    <arg name="turningRadius"                   default="5.2"  />
+    <arg name="maxSteerAngle"                   default="0.45" />
+    <arg name="steeringDelay"                   default="1.2" />
+    <!-- Not included in app window -->
+    <arg name="minPursuiteDistance"             default="3.0"  />
+    <arg name="additionalBrakingDistance"       default="5.0"  />
+    <arg name="giveUpDistance"                  default="-4.0"  />
+    <arg name="mapSource"                       default="0" />        <!-- Autoware=0, Vector Map Folder=1, kml=2 -->
+    <arg name="mapFileName"                     default="" />
+    <arg name="minVelocity"                     default="0.1" />  
+    <arg name="speedProfileFactor"              default="1.2"  />
+    <arg name="smoothingDataWeight"             default="0.45"  />
+    <arg name="smoothingSmoothWeight"           default="0.4"  />
+    <arg name="enableSlowDownOnCurve"           default="true" />
+    <arg name="curveVelocityRatio"           default="0.4" />
+  </include>
+
+  <!-- op_trajectory_generator -->
+  <include file="$(find op_local_planner)/launch/op_trajectory_generator.launch">
+    <arg name="samplingTipMargin"               default="4"  />       <!-- Tip Margin -->
+    <arg name="samplingOutMargin"               default="8" />        <!-- Roll In Margin -->
+    <arg name="samplingSpeedFactor"             default="0.25" />    
+    <arg name="enableHeadingSmoothing"          default="false" />
+  </include>
+
+  <!-- op_motion_predictor -->
+  <include file="$(find op_local_planner)/launch/op_motion_predictor.launch">
+    <!-- <arg name="input_object_list"               default="[/detection/fusion_tools/objects_center]" /> -->
+    <arg name="input_object_list"               default="[/detection/lidar_detector/rubis_objects_center]" />
+    <arg name="object_tf_list"                  default="[ego_vehicle/lidar]" />
+    <arg name="enableCurbObstacles"             default="false" />    <!-- Detect curbs from map-->
+    <arg name="enableGenrateBranches"           default="false"/>     <!-- Enable Branching -->
+    <arg name="max_distance_to_lane"            default="2.0"/>       <!-- Distance to closest lane-->
+    <arg name="prediction_distance"             default="25.0"/>      <!-- Prediction distance-->
+    <arg name="enableStepByStepSignal"          default="false" />    <!-- Enable Step by Step Test-->
+    <arg name="enableParticleFilterPrediction"  default="false" />    <!-- Enable Particle Filter prediction -->
+    <!-- Not included in app window -->   
+    <arg name="distanceBetweenCurbs"            default="1.5" />
+    <arg name="visualizationTime"               default="0.25" />
+  </include>
+
+  <!-- op_trajectory_evaluator -->
+  <include file="$(find op_local_planner)/launch/op_trajectory_evaluator_parameter.launch">
+    <arg name="enableDebug"      default="0" />
+
+    <arg name="enablePrediction"                default="false" />                
+    <arg name="horizontalSafetyDistance"        default="1.2" />
+    <arg name="verticalSafetyDistance"          default="0.8" />
+    <arg name="LateralSkipDistance"             default="5.0" />  
+
+    <!-- Trajectory blocking threshold  -->
+    <arg name="lateralBlockingThreshold"           default="0.0" />
+    <arg name="frontLongitudinalBlockingThreshold"      default="30" />
+    <arg name="rearLongitudinalBlockingThreshold"      default="-5" />
+
+    <arg name="intersectionFile"                default="crossing_test/crossing_intersection.yaml" />
+  </include>
+
+  <!-- op_behavior_selector -->
+  <include file="$(find op_local_planner)/launch/op_behavior_selector_parameter.launch">
+    <arg name="evidence_tust_number"            default="25"/>
+    <arg name="trafficLightFile"                default="crossing_test/crossing_traffic_light.yaml" />
+    <arg name="stopLineFile"                    default="crossing_test/crossing_stop_line.yaml" />
+  </include>
+</launch>
\ No newline at end of file
diff --git a/rubis_ws/src/rubis_autorunner/scripts/carla_autorunner/_carla_autorunner_5_control.launch b/rubis_ws/src/rubis_autorunner/scripts/carla_autorunner/_carla_autorunner_5_control.launch
new file mode 100644
index 00000000..59144340
--- /dev/null
+++ b/rubis_ws/src/rubis_autorunner/scripts/carla_autorunner/_carla_autorunner_5_control.launch
@@ -0,0 +1,32 @@
+<launch>
+  <!--  Dynamic Pure Pursuit Param -->
+  <rosparam command="load" file="$(env USER_HOME)/autoware.ai/autoware_files/lgsvl_file/parameter/lgsvl_pure_pursuit.yaml" />
+  
+  <!-- pure_pursuit  -->
+  <include file="$(find pure_pursuit)/launch/pure_pursuit_params.launch">   
+    <!-- Core Parameter -->
+    <arg name="lookahead_ratio"               value="1.5"/>
+    <arg name="minimum_lookahead_distance"    value="10.0"/> 
+    
+    <arg name="const_velocity"                value="5.0"/>     
+    <arg name="const_lookahead_distance"      value="4.0"/>
+    <arg name="is_linear_interpolation"       value="True"/>
+    <arg name="publishes_for_steering_robot"  value="True"/>
+    <arg name="add_virtual_end_waypoints"     value="False"/>
+  </include>
+
+  <!-- twist_filter -->
+  <include file="$(find twist_filter)/launch/twist_filter_params.launch">    
+    <!-- For twist_filter -->
+    <arg name="wheel_base" default="2.7" />
+    <arg name="lateral_accel_limit" default="5.0" />
+    <arg name="lateral_jerk_limit" default="5.0" />
+    <arg name="lowpass_gain_linear_x" default="0.0" />
+    <arg name="lowpass_gain_angular_z" default="0.0" />
+    <arg name="lowpass_gain_steering_angle" default="0.0" />
+    <arg name="max_stop_count" default="40" /> <!-- 10 = 1 second -->  
+    <!-- For twist_gate -->
+    <arg name="loop_rate" default="30.0" />
+    <arg name="use_decision_maker" default="false" />
+  </include>
+</launch>
\ No newline at end of file
diff --git a/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/_cubetown_autorunner_1_sensing.launch b/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/_cubetown_autorunner_1_sensing.launch
index 072b973a..fdf35425 100644
--- a/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/_cubetown_autorunner_1_sensing.launch
+++ b/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/_cubetown_autorunner_1_sensing.launch
@@ -22,17 +22,21 @@
   </include>
 
   <!-- Re-publishing simulator/camera_node/image/compressed topic to /image_raw as expected by Autoware -->
-  <!-- <node name="republish" type="republish" pkg="image_transport" args="compressed in:=/simulator/camera_node/image raw out:=/image_raw"  /> -->
+  <node name="republish" type="republish" pkg="image_transport" output="screen" args="compressed in:=/simulator/camera_node/image raw out:=/image_raw"  />
 
   <include file="$(find rubis_pkg)/launch/lidar_republisher_params.launch">
     <arg name="input_topic" value="$(arg lidar_input_topic)" />
     <arg name="output_topic" value="$(arg lidar_output_topic)" />
   </include>
 
-  <!-- Normal LiDAR -->
   <node pkg="tf" type="static_transform_publisher" name="base_link_to_velodyne" args="1.2 0 2.0 0 0 0 base_link velodyne 10"/>
-
+  <!-- <node pkg="tf" type="static_transform_publisher" name="gps_to_base_link" args="0 0 0 0 0 0 gps base_link 10"/> -->
   <node pkg="tf" type="static_transform_publisher" name="lidar_to_camera" args="0.029 -0.574 -1.820 4.712 0.009 -1.883 velodyne camera 10" />
 
-</launch>
+  <!-- gnss localizer -->
+  <arg name="plane" default="0"/>
+  <node pkg="rubis_pkg" type="gnss_localizer" name="gnss_localizer" output="screen">
+    <param name="plane" value="$(arg plane)"/>
+  </node>
 
+</launch>
\ No newline at end of file
diff --git a/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/_cubetown_autorunner_2_localization.launch b/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/_cubetown_autorunner_2_localization.launch
index cf62f8fb..8afcb8a1 100644
--- a/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/_cubetown_autorunner_2_localization.launch
+++ b/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/_cubetown_autorunner_2_localization.launch
@@ -36,11 +36,11 @@
     pitch: $(arg init_pitch),
     yaw: $(arg init_yaw),
     use_predict_pose: 1,
-    error_threshold: 0.01,
-    resolution: 3.0,
-    step_size: 0.3,
+    error_threshold: 0.05,
+    resolution: 1.0,
+    step_size: 0.5,
     trans_epsilon: 0.01,
-    max_iterations: 10}
+    max_iterations: 2}
   '"/>
 
 </launch>
diff --git a/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/_cubetown_autorunner_4_planning.launch b/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/_cubetown_autorunner_4_planning.launch
index a49a410e..819a2793 100644
--- a/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/_cubetown_autorunner_4_planning.launch
+++ b/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/_cubetown_autorunner_4_planning.launch
@@ -82,11 +82,18 @@
 
   <!-- op_trajectory_evaluator -->
   <include file="$(find op_local_planner)/launch/op_trajectory_evaluator_parameter.launch">
+    <arg name="enableDebug"      default="1" />
+
     <arg name="enablePrediction"                default="false" />                
     <arg name="horizontalSafetyDistance"        default="1.2" />
     <arg name="verticalSafetyDistance"          default="0.8" />
     <arg name="LateralSkipDistance"             default="5.0" />  
 
+    <!-- Trajectory blocking threshold  -->
+    <arg name="lateralBlockingThreshold"           default="1.5" />
+    <arg name="frontLongitudinalBlockingThreshold"      default="30" />
+    <arg name="rearLongitudinalBlockingThreshold"      default="-5" />
+
     <arg name="intersectionFile"                default="crossing_test/crossing_intersection.yaml" />
   </include>
 
diff --git a/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/_modular_single_lidar_2_localization.launch b/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/_modular_single_lidar_2_localization.launch
index 68b2046e..6fbbc3a2 100644
--- a/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/_modular_single_lidar_2_localization.launch
+++ b/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/_modular_single_lidar_2_localization.launch
@@ -15,7 +15,6 @@
   <arg name="output_log" default="false" />
   <arg name="leaf_size" default="1.0" />
   <arg name="measurement_range" default="200" />
-  <arg name="instance_mode" default="0"/>
 
   <arg name="method_type" default="0"/>
   <arg name="max_iter" default="10"/>
diff --git a/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/_multi_lidar_1_sensing.launch b/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/_multi_lidar_1_sensing.launch
index a8f5c037..b399ee97 100644
--- a/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/_multi_lidar_1_sensing.launch
+++ b/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/_multi_lidar_1_sensing.launch
@@ -21,24 +21,19 @@
   <!-- Re-publishing simulator/camera_node/image/compressed topic to /image_raw as expected by Autoware -->
   <node name="republish" type="republish" pkg="image_transport" args="compressed in:=/simulator/camera_node/image raw out:=/image_raw"  />
 
-  <arg name="instance_mode" default="0"/>
-
   <node pkg="rubis_pkg" type="lidar_republisher" name="lidar_republisher_FL">
     <param name="/input_topic" value="points_raw_FL" />
     <param name="/output_topic" value="points_raw_FL_repub" />
-    <param name="/instance_mode" value="$(arg instance_mode)" />
   </node>
 
   <node pkg="rubis_pkg" type="lidar_republisher" name="lidar_republisher_FR">
     <param name="/input_topic" value="points_raw_FR" />
     <param name="/output_topic" value="points_raw_FR_repub" />
-    <param name="/instance_mode" value="$(arg instance_mode)" />
   </node>
 
   <node pkg="rubis_pkg" type="lidar_republisher" name="lidar_republisher_B">
     <param name="/input_topic" value="points_raw_B" />
     <param name="/output_topic" value="points_raw_B_repub" />
-    <param name="/instance_mode" value="$(arg instance_mode)" />
   </node>
 
   <node pkg="tf" type="static_transform_publisher" name="vel_to_velodyne_FR" args="0 0 0 0 0 0 velodyne_FR velodyne 10"/>
diff --git a/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/_multi_lidar_2_localizer.launch b/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/_multi_lidar_2_localizer.launch
index fd7ce414..05ed4386 100644
--- a/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/_multi_lidar_2_localizer.launch
+++ b/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/_multi_lidar_2_localizer.launch
@@ -15,7 +15,6 @@
   <arg name="output_log" default="false" />
   <arg name="leaf_size" default="0.1" />
   <arg name="measurement_range" default="200" />
-  <arg name="instance_mode" default="0"/>
 
   <arg name="method_type" default="0"/>
   <arg name="max_iter" default="10"/>
@@ -33,7 +32,6 @@
     <param name="leaf_size" value="$(arg leaf_size)" />
     <param name="measurement_range" value="$(arg measurement_range)" />
     <param name="output_log" value="$(arg output_log)" />
-    <param name="instance_mode" value="$(arg instance_mode)" />
   </node>
 
   <node pkg="lidar_localizer" type="modular_ndt_matching" name="modular_ndt_matching_FL">
@@ -78,7 +76,6 @@
     <param name="leaf_size" value="$(arg leaf_size)" />
     <param name="measurement_range" value="$(arg measurement_range)" />
     <param name="output_log" value="$(arg output_log)" />
-    <param name="instance_mode" value="$(arg instance_mode)" />
   </node>
 
   <node pkg="lidar_localizer" type="modular_ndt_matching" name="modular_ndt_matching_FR">
@@ -123,7 +120,6 @@
     <param name="leaf_size" value="$(arg leaf_size)" />
     <param name="measurement_range" value="$(arg measurement_range)" />
     <param name="output_log" value="$(arg output_log)" />
-    <param name="instance_mode" value="$(arg instance_mode)" />
   </node>
 
   <node pkg="lidar_localizer" type="modular_ndt_matching" name="modular_ndt_matching_B">
diff --git a/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/test.launch b/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/test.launch
index cab08d89..546fc8d7 100644
--- a/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/test.launch
+++ b/rubis_ws/src/rubis_autorunner/scripts/cubetown_autorunner/test.launch
@@ -36,22 +36,18 @@
   <node pkg="rubis_pkg" type="lidar_republisher" name="lidar_republisher">
     <param name="/input_topic" value="$(arg lidar_input_topic)" />
     <param name="/output_topic" value="$(arg lidar_output_topic)" />
-    <param name="/instance_mode" value="1" />
   </node>
 
   <node pkg="tf" type="static_transform_publisher" name="base_link_to_velodyne" args="1.2 0 2.0 0 0 0 base_link velodyne 10"/>
   <!-- <node pkg="tf" type="static_transform_publisher" name="gps_to_base_link" args="0 0 0 0 0 0 gps base_link 10"/> -->
   <node pkg="tf" type="static_transform_publisher" name="lidar_to_camera" args="0.029 -0.574 -1.820 4.712 0.009 -1.883 velodyne camera 10" />
 
-  <include file="$(find points_downsampler)/launch/voxel_grid_filter.launch">
-    <arg name="instance_mode" value="1" />
-  </include>
+  <include file="$(find points_downsampler)/launch/voxel_grid_filter.launch"/>
 
   <!-- ndt_matching --><!-- pcl_generic=0, pcl_anh=1, pcl_anh_gpu=2, pcl_openmp=3 -->
   <include file="$(find lidar_localizer)/launch/ndt_matching.launch">
     <arg name="method_type" value="0" /> 
     <arg name="get_height" value="true" /> 
-    <arg name="instance_mode" value="0" />
   </include>
 
   <!-- ndt config -->
@@ -76,7 +72,6 @@
 <include file="$(find rubis_pkg)/launch/vel_pose_connect.launch">
   <arg name="topic_pose_stamped" value="/ndt_pose" />
   <arg name="topic_twist_stamped" value="/estimate_twist" />
-  <arg name="instance_mode" value="1" />
 </include>
 
 </launch>
diff --git a/rubis_ws/src/rubis_autorunner/scripts/ionic_FMTC_red_course/_ionic_autorunner_2_gicp_localizer.launch b/rubis_ws/src/rubis_autorunner/scripts/ionic_FMTC_red_course/_ionic_autorunner_2_gicp_localizer.launch
index e78be3d2..44a69ccc 100644
--- a/rubis_ws/src/rubis_autorunner/scripts/ionic_FMTC_red_course/_ionic_autorunner_2_gicp_localizer.launch
+++ b/rubis_ws/src/rubis_autorunner/scripts/ionic_FMTC_red_course/_ionic_autorunner_2_gicp_localizer.launch
@@ -15,7 +15,6 @@
   <arg name="output_log" default="false" />
   <arg name="leaf_size" default="0.5" />
   <arg name="measurement_range" default="200" />
-  <arg name="instance_mode" default="0"/>
 
   <node pkg="points_downsampler" name="voxel_grid_filter" type="voxel_grid_filter">
     <param name="input_topic_name" value="points_raw" />
@@ -23,7 +22,6 @@
     <param name="leaf_size" value="$(arg leaf_size)" />
     <param name="measurement_range" value="$(arg measurement_range)" />
     <param name="output_log" value="$(arg output_log)" />
-    <param name="instance_mode" value="$(arg instance_mode)" />
   </node>
 
   <arg name="enable_gnss_backup" default="true" /> 
diff --git a/rubis_ws/src/rubis_autorunner/scripts/ionic_FMTC_red_course/_ionic_autorunner_2_modular_localizer.launch b/rubis_ws/src/rubis_autorunner/scripts/ionic_FMTC_red_course/_ionic_autorunner_2_modular_localizer.launch
index 2a317ad2..c71066ba 100644
--- a/rubis_ws/src/rubis_autorunner/scripts/ionic_FMTC_red_course/_ionic_autorunner_2_modular_localizer.launch
+++ b/rubis_ws/src/rubis_autorunner/scripts/ionic_FMTC_red_course/_ionic_autorunner_2_modular_localizer.launch
@@ -14,7 +14,6 @@
   <arg name="output_log" default="false" />
   <arg name="leaf_size" default="0.5" />
   <arg name="measurement_range" default="200" />
-  <!-- <arg name="instance_mode" default="0"/> -->
 
   <arg name="method_type" default="0"/>
   <arg name="max_iter" default="10"/>
@@ -32,7 +31,6 @@
     <param name="leaf_size" value="$(arg leaf_size)" />
     <param name="measurement_range" value="$(arg measurement_range)" />
     <param name="output_log" value="$(arg output_log)" />
-    <!-- <param name="instance_mode" value="$(arg instance_mode)" /> -->
   </node>
 
   <node pkg="lidar_localizer" type="modular_ndt_matching" name="modular_ndt_matching_FR">
diff --git a/rubis_ws/src/rubis_autorunner/src/carla_autorunner/carla_full_autorunner.cpp b/rubis_ws/src/rubis_autorunner/src/carla_autorunner/carla_full_autorunner.cpp
new file mode 100644
index 00000000..e5f44ead
--- /dev/null
+++ b/rubis_ws/src/rubis_autorunner/src/carla_autorunner/carla_full_autorunner.cpp
@@ -0,0 +1,108 @@
+#include "carla_autorunner/carla_autorunner.h"
+
+void CarlaAutorunner::Run(){
+    register_subscribers();             // Register subscribers that shoud check can go next or not
+    ros_autorunner_.init(nh_, sub_v_);   // Initialize the ROS-Autorunner
+    ros::Rate rate(1);                  // Rate can be changed
+    while(ros::ok()){               
+        if(!ros_autorunner_.Run()) break;           // Run Autorunner
+        ros::spinOnce();
+        rate.sleep();
+    }    
+}
+
+void CarlaAutorunner::register_subscribers(){
+    int total_step_num = nh_.param("/total_step_num", -1);
+    if(total_step_num < 0){
+        std::cout<<"Parameter total_step_num is invalid"<<std::endl;
+        exit(1);
+    }    
+    sub_v_.resize(total_step_num);          // Resizing the subscriber vectors. Its size must be same with number of steps
+
+    // Set the check function(subscriber)
+    sub_v_[STEP(1)] = nh_.subscribe("/points_raw", 1, &CarlaAutorunner::points_raw_cb, this);   
+    sub_v_[STEP(2)] = nh_.subscribe("/ndt_pose", 1, &CarlaAutorunner::ndt_pose_cb, this);   
+    sub_v_[STEP(3)] = nh_.subscribe("/detection/lidar_detector/objects_center", 1, &CarlaAutorunner::detection_cb, this);   
+    sub_v_[STEP(4)] = nh_.subscribe("/behavior_state", 1, &CarlaAutorunner::behavior_state_cb, this);
+
+    initial_pose_pub_ = nh_.advertise< geometry_msgs::PoseWithCovarianceStamped>("initialpose", 1);
+}
+
+ void CarlaAutorunner::points_raw_cb(const sensor_msgs::PointCloud2& msg){
+    if(!msg.fields.empty() && !ros_autorunner_.step_info_list_[STEP(2)].is_prepared){
+        ROS_WARN("[STEP 1] Map and Sensors are prepared");
+    	sleep(SLEEP_PERIOD);
+        ros_autorunner_.step_info_list_[STEP(2)].is_prepared = true;
+    }
+ }
+
+ void CarlaAutorunner::ndt_pose_cb(const geometry_msgs::PoseStamped& msg){
+    static int failure_cnt = 0, success_cnt = 0;
+    failure_cnt++;
+    
+    static const double pos_x = 314.072479248;
+    static const double pos_y = 129.654495239;
+    static const double pos_z = 0.044597864151;
+
+    static const double ori_x = 0.0;
+    static const double ori_y = 0.0;
+    static const double ori_z = 0.70715665039;
+    static const double ori_w = 0.70705690407;
+
+
+    if(failure_cnt > 10){        
+        std::cout<<"# Refresh inital pose"<<std::endl;
+        std::cout<<msg.pose.position.x - pos_x <<" "<<msg.pose.position.y - pos_y <<" "
+                 <<msg.pose.orientation.x - ori_x<<" "<<msg.pose.orientation.y - ori_y<<" "
+                 <<msg.pose.orientation.z - ori_z<<" "<<msg.pose.orientation.w - ori_w<<" "<<std::endl;
+        
+        geometry_msgs::PoseWithCovarianceStamped initial_pose_msg;
+        initial_pose_msg.header = msg.header;
+        initial_pose_msg.pose.pose.position.x = pos_x;
+        initial_pose_msg.pose.pose.position.y = pos_y;
+        initial_pose_msg.pose.pose.position.z = pos_z;
+        initial_pose_msg.pose.pose.orientation.x = ori_x;
+        initial_pose_msg.pose.pose.orientation.y = ori_y;
+        initial_pose_msg.pose.pose.orientation.z = ori_z;
+        initial_pose_msg.pose.pose.orientation.w = ori_w;
+        initial_pose_pub_.publish(initial_pose_msg);
+        failure_cnt = 0;          
+    }
+
+    if( msg.pose.position.x <= pos_x + 1.5 && msg.pose.position.x >= pos_x - 1.5 &&        
+        msg.pose.position.y <= pos_y + 1.5 && msg.pose.position.y >= pos_y - 1.5 &&
+        msg.pose.orientation.x <= ori_x + 0.01 && msg.pose.orientation.x >= ori_x - 0.01 &&
+        msg.pose.orientation.y <= ori_y + 0.01 && msg.pose.orientation.y >= ori_y - 0.01 &&
+        msg.pose.orientation.z <= ori_z + 0.01 && msg.pose.orientation.z >= ori_z - 0.01 &&
+        msg.pose.orientation.w <= ori_w + 0.01 && msg.pose.orientation.w >= ori_w - 0.01 &&
+        !ros_autorunner_.step_info_list_[STEP(3)].is_prepared){
+        success_cnt++;
+        if(success_cnt < 3) return;
+        ROS_WARN("[STEP 2] Localization is success");
+    	sleep(SLEEP_PERIOD);
+        ros_autorunner_.step_info_list_[STEP(3)].is_prepared = true;
+    }
+    else{
+        success_cnt = 0;
+    }
+ }
+
+void CarlaAutorunner::detection_cb(const autoware_msgs::DetectedObjectArray& msg){
+    if(!msg.objects.empty() && !ros_autorunner_.step_info_list_[STEP(4)].is_prepared){
+        ROS_WARN("[STEP 3] All detection modules are excuted");
+    	sleep(SLEEP_PERIOD);
+        ros_autorunner_.step_info_list_[STEP(4)].is_prepared = true;
+    }
+}
+
+
+ void CarlaAutorunner::behavior_state_cb(const visualization_msgs::MarkerArray& msg){
+    std::string state = msg.markers.front().text;    
+    if(!msg.markers.empty() && state.find(std::string("Forward"))!=std::string::npos){
+        ROS_WARN("[STEP 4] Global & local planning success");
+        ros_autorunner_.step_info_list_[STEP(5)].is_prepared = true;
+    }
+}
+
+
+
diff --git a/rubis_ws/src/rubis_autorunner/src/carla_autorunner/carla_full_autorunner_node.cpp b/rubis_ws/src/rubis_autorunner/src/carla_autorunner/carla_full_autorunner_node.cpp
new file mode 100644
index 00000000..caac332f
--- /dev/null
+++ b/rubis_ws/src/rubis_autorunner/src/carla_autorunner/carla_full_autorunner_node.cpp
@@ -0,0 +1,11 @@
+#include <carla_autorunner/carla_autorunner.h>
+
+int main(int argc, char* argv[]){
+    ros::init(argc, argv, "carla_autorunner");
+    ros::NodeHandle nh;
+
+    CarlaAutorunner carla_autorunner(nh);
+    carla_autorunner.Run();
+
+    return 0;
+}
\ No newline at end of file
diff --git a/rubis_ws/src/rubis_autorunner/src/carla_autorunner/carla_lkas_autorunner.cpp b/rubis_ws/src/rubis_autorunner/src/carla_autorunner/carla_lkas_autorunner.cpp
new file mode 100644
index 00000000..df8f65dd
--- /dev/null
+++ b/rubis_ws/src/rubis_autorunner/src/carla_autorunner/carla_lkas_autorunner.cpp
@@ -0,0 +1,99 @@
+#include "carla_autorunner/carla_autorunner.h"
+
+void CarlaAutorunner::Run(){
+    register_subscribers();             // Register subscribers that shoud check can go next or not
+    ros_autorunner_.init(nh_, sub_v_);   // Initialize the ROS-Autorunner
+    ros::Rate rate(1);                  // Rate can be changed
+    while(ros::ok()){               
+        if(!ros_autorunner_.Run()) break;           // Run Autorunner
+        ros::spinOnce();
+        rate.sleep();
+    }    
+}
+
+void CarlaAutorunner::register_subscribers(){
+    int total_step_num = nh_.param("/total_step_num", -1);
+    if(total_step_num < 0){
+        std::cout<<"Parameter total_step_num is invalid"<<std::endl;
+        exit(1);
+    }    
+    sub_v_.resize(total_step_num);          // Resizing the subscriber vectors. Its size must be same with number of steps
+
+    // Set the check function(subscriber)
+    sub_v_[STEP(1)] = nh_.subscribe("/points_raw", 1, &CarlaAutorunner::points_raw_cb, this);   
+    sub_v_[STEP(2)] = nh_.subscribe("/ndt_pose", 1, &CarlaAutorunner::ndt_pose_cb, this);   
+    sub_v_[STEP(3)] = nh_.subscribe("/behavior_state", 1, &CarlaAutorunner::behavior_state_cb, this); 
+
+    initial_pose_pub_ = nh_.advertise< geometry_msgs::PoseWithCovarianceStamped>("initialpose", 1);
+}
+
+ void CarlaAutorunner::points_raw_cb(const sensor_msgs::PointCloud2& msg){
+    if(!msg.fields.empty() && !ros_autorunner_.step_info_list_[STEP(2)].is_prepared){
+        ROS_WARN("[STEP 1] Map and Sensors are prepared");
+    	sleep(SLEEP_PERIOD);
+        ros_autorunner_.step_info_list_[STEP(2)].is_prepared = true;
+    }
+ }
+
+ void CarlaAutorunner::ndt_pose_cb(const geometry_msgs::PoseStamped& msg){
+    static int failure_cnt = 0, success_cnt = 0;
+    failure_cnt++;
+    
+    static const double pos_x = 314.072479248;
+    static const double pos_y = 129.654495239;
+    static const double pos_z = 0.044597864151;
+
+    static const double ori_x = 0.0;
+    static const double ori_y = 0.0;
+    static const double ori_z = 0.70715665039;
+    static const double ori_w = 0.70705690407;
+
+
+    if(failure_cnt > 10){        
+        std::cout<<"# Refresh inital pose"<<std::endl;
+        std::cout<<msg.pose.position.x - pos_x <<" "<<msg.pose.position.y - pos_y <<" "
+                 <<msg.pose.orientation.x - ori_x<<" "<<msg.pose.orientation.y - ori_y<<" "
+                 <<msg.pose.orientation.z - ori_z<<" "<<msg.pose.orientation.w - ori_w<<" "<<std::endl;
+        
+        geometry_msgs::PoseWithCovarianceStamped initial_pose_msg;
+        initial_pose_msg.header = msg.header;
+        initial_pose_msg.pose.pose.position.x = pos_x;
+        initial_pose_msg.pose.pose.position.y = pos_y;
+        initial_pose_msg.pose.pose.position.z = pos_z;
+        initial_pose_msg.pose.pose.orientation.x = ori_x;
+        initial_pose_msg.pose.pose.orientation.y = ori_y;
+        initial_pose_msg.pose.pose.orientation.z = ori_z;
+        initial_pose_msg.pose.pose.orientation.w = ori_w;
+        initial_pose_pub_.publish(initial_pose_msg);
+        failure_cnt = 0;          
+    }
+
+    if( msg.pose.position.x <= pos_x + 1.5 && msg.pose.position.x >= pos_x - 1.5 &&        
+        msg.pose.position.y <= pos_y + 1.5 && msg.pose.position.y >= pos_y - 1.5 &&
+        msg.pose.orientation.x <= ori_x + 0.01 && msg.pose.orientation.x >= ori_x - 0.01 &&
+        msg.pose.orientation.y <= ori_y + 0.01 && msg.pose.orientation.y >= ori_y - 0.01 &&
+        msg.pose.orientation.z <= ori_z + 0.01 && msg.pose.orientation.z >= ori_z - 0.01 &&
+        msg.pose.orientation.w <= ori_w + 0.01 && msg.pose.orientation.w >= ori_w - 0.01 &&
+        !ros_autorunner_.step_info_list_[STEP(3)].is_prepared){
+        success_cnt++;
+        if(success_cnt < 3) return;
+        ROS_WARN("[STEP 2] Localization is success");
+    	sleep(SLEEP_PERIOD);
+        ros_autorunner_.step_info_list_[STEP(3)].is_prepared = true;
+    }
+    else{
+        success_cnt = 0;
+    }
+ }
+
+
+ void CarlaAutorunner::behavior_state_cb(const visualization_msgs::MarkerArray& msg){
+    std::string state = msg.markers.front().text;    
+    if(!msg.markers.empty() && state.find(std::string("Forward"))!=std::string::npos){
+        ROS_WARN("[STEP 3] Global & local planning success");
+        ros_autorunner_.step_info_list_[STEP(4)].is_prepared = true;
+    }
+}
+
+
+
diff --git a/rubis_ws/src/rubis_autorunner/src/carla_autorunner/carla_lkas_autorunner_node.cpp b/rubis_ws/src/rubis_autorunner/src/carla_autorunner/carla_lkas_autorunner_node.cpp
new file mode 100644
index 00000000..caac332f
--- /dev/null
+++ b/rubis_ws/src/rubis_autorunner/src/carla_autorunner/carla_lkas_autorunner_node.cpp
@@ -0,0 +1,11 @@
+#include <carla_autorunner/carla_autorunner.h>
+
+int main(int argc, char* argv[]){
+    ros::init(argc, argv, "carla_autorunner");
+    ros::NodeHandle nh;
+
+    CarlaAutorunner carla_autorunner(nh);
+    carla_autorunner.Run();
+
+    return 0;
+}
\ No newline at end of file
diff --git a/rubis_ws/src/rubis_autorunner/src/cubetown_autorunner/cubetown_full_autorunner.cpp b/rubis_ws/src/rubis_autorunner/src/cubetown_autorunner/cubetown_full_autorunner.cpp
index 62a816ed..2dc84b89 100644
--- a/rubis_ws/src/rubis_autorunner/src/cubetown_autorunner/cubetown_full_autorunner.cpp
+++ b/rubis_ws/src/rubis_autorunner/src/cubetown_autorunner/cubetown_full_autorunner.cpp
@@ -21,7 +21,7 @@ void CubetownAutorunner::register_subscribers(){
 
     // Set the check function(subscriber)
     sub_v_[STEP(1)] = nh_.subscribe("/points_raw", 1, &CubetownAutorunner::points_raw_cb, this);   
-    sub_v_[STEP(2)] = nh_.subscribe("/ndt_stat", 1, &CubetownAutorunner::ndt_stat_cb, this);   
+    sub_v_[STEP(2)] = nh_.subscribe("/ndt_pose", 1, &CubetownAutorunner::ndt_pose_cb, this);   
     sub_v_[STEP(3)] = nh_.subscribe("/detection/lidar_detector/objects_center", 1, &CubetownAutorunner::detection_cb, this);   
     sub_v_[STEP(4)] = nh_.subscribe("/behavior_state", 1, &CubetownAutorunner::behavior_state_cb, this);
 
@@ -36,27 +36,37 @@ void CubetownAutorunner::register_subscribers(){
     }
  }
 
- void CubetownAutorunner::ndt_stat_cb(const autoware_msgs::NDTStat& msg){
-    static int cnt = 0;
-    cnt++;
-    if(cnt > 200){        
-        geometry_msgs::PoseWithCovariance msg;
-        msg.pose.position.x = 56.3796081543;
-        msg.pose.position.y = -0.0106279850006;
-        msg.pose.position.z = 0.465716004372;
-        msg.pose.orientation.x = -0.00171861096474;
-        msg.pose.orientation.y = -0.00120572400155;
-        msg.pose.orientation.z = 0.707457658123;
-        msg.pose.orientation.w = 0.706752612;
-        initial_pose_pub_.publish(msg);
-        cnt = 0;
+ void CubetownAutorunner::ndt_pose_cb(const geometry_msgs::PoseStamped& msg){
+    static int failure_cnt = 0, success_cnt = 0;
+    failure_cnt++;    
+
+    if(failure_cnt > 10){        
+        std::cout<<"# Refresh inital pose"<<std::endl;
+        geometry_msgs::PoseWithCovarianceStamped initial_pose_msg;
+        initial_pose_msg.header = msg.header;
+        initial_pose_msg.pose.pose.position.x = 56.3796081543;
+        initial_pose_msg.pose.pose.position.y = -0.0106279850006;
+        initial_pose_msg.pose.pose.position.z = 0.465716004372;
+        initial_pose_msg.pose.pose.orientation.x = -0.00171861096474;
+        initial_pose_msg.pose.pose.orientation.y = -0.00120572400155;
+        initial_pose_msg.pose.pose.orientation.z = 0.707457658123;
+        initial_pose_msg.pose.pose.orientation.w = 0.706752612;
+        initial_pose_pub_.publish(initial_pose_msg);
+        failure_cnt = 0;
     }
 
-    if(msg.score < 0.7 && !ros_autorunner_.step_info_list_[STEP(3)].is_prepared){
+    if(msg.pose.position.x <= 57.0 && msg.pose.position.x >= 55.0 &&        
+        msg.pose.position.y >= -0.20 && msg.pose.position.y <= 0.00 &&
+        !ros_autorunner_.step_info_list_[STEP(3)].is_prepared){
+        success_cnt++;
+        if(success_cnt < 3) return;
         ROS_WARN("[STEP 2] Localization is success");
     	sleep(SLEEP_PERIOD);
         ros_autorunner_.step_info_list_[STEP(3)].is_prepared = true;
     }
+    else{
+        success_cnt = 0;
+    }
     
  }
 
diff --git a/rubis_ws/src/rubis_autorunner/src/cubetown_autorunner/cubetown_lkas_autorunner.cpp b/rubis_ws/src/rubis_autorunner/src/cubetown_autorunner/cubetown_lkas_autorunner.cpp
index fecbc2c3..422d1062 100644
--- a/rubis_ws/src/rubis_autorunner/src/cubetown_autorunner/cubetown_lkas_autorunner.cpp
+++ b/rubis_ws/src/rubis_autorunner/src/cubetown_autorunner/cubetown_lkas_autorunner.cpp
@@ -21,7 +21,7 @@ void CubetownAutorunner::register_subscribers(){
 
     // Set the check function(subscriber)
     sub_v_[STEP(1)] = nh_.subscribe("/points_raw", 1, &CubetownAutorunner::points_raw_cb, this);   
-    sub_v_[STEP(2)] = nh_.subscribe("/ndt_stat", 1, &CubetownAutorunner::ndt_stat_cb, this); 
+    sub_v_[STEP(2)] = nh_.subscribe("/ndt_pose", 1, &CubetownAutorunner::ndt_pose_cb, this);   
     sub_v_[STEP(3)] = nh_.subscribe("/behavior_state", 1, &CubetownAutorunner::behavior_state_cb, this); 
 
     initial_pose_pub_ = nh_.advertise< geometry_msgs::PoseWithCovarianceStamped>("initialpose", 1);
@@ -35,29 +35,41 @@ void CubetownAutorunner::register_subscribers(){
     }
  }
 
- void CubetownAutorunner::ndt_stat_cb(const autoware_msgs::NDTStat& msg){
-    static int cnt = 0;
-    cnt++;
-    if(cnt > 200){        
-        geometry_msgs::PoseWithCovariance msg;
-        msg.pose.position.x = 56.3796081543;
-        msg.pose.position.y = -0.0106279850006;
-        msg.pose.position.z = 0.465716004372;
-        msg.pose.orientation.x = -0.00171861096474;
-        msg.pose.orientation.y = -0.00120572400155;
-        msg.pose.orientation.z = 0.707457658123;
-        msg.pose.orientation.w = 0.706752612;
-        initial_pose_pub_.publish(msg);
-        cnt = 0;
+ void CubetownAutorunner::ndt_pose_cb(const geometry_msgs::PoseStamped& msg){
+    static int failure_cnt = 0, success_cnt = 0;
+    failure_cnt++;    
+
+    if(failure_cnt > 10){        
+        std::cout<<"# Refresh inital pose"<<std::endl;
+        geometry_msgs::PoseWithCovarianceStamped initial_pose_msg;
+        initial_pose_msg.header = msg.header;
+        initial_pose_msg.pose.pose.position.x = 56.3796081543;
+        initial_pose_msg.pose.pose.position.y = -0.0106279850006;
+        initial_pose_msg.pose.pose.position.z = 0.465716004372;
+        initial_pose_msg.pose.pose.orientation.x = -0.00171861096474;
+        initial_pose_msg.pose.pose.orientation.y = -0.00120572400155;
+        initial_pose_msg.pose.pose.orientation.z = 0.707457658123;
+        initial_pose_msg.pose.pose.orientation.w = 0.706752612;
+        initial_pose_pub_.publish(initial_pose_msg);
+        failure_cnt = 0;
     }
-    
-    if(msg.score < 0.7 && !ros_autorunner_.step_info_list_[STEP(3)].is_prepared){
+
+    if(msg.pose.position.x <= 57.0 && msg.pose.position.x >= 55.0 &&        
+        msg.pose.position.y >= -0.20 && msg.pose.position.y <= 0.00 &&
+        !ros_autorunner_.step_info_list_[STEP(3)].is_prepared){
+        success_cnt++;
+        if(success_cnt < 3) return;
         ROS_WARN("[STEP 2] Localization is success");
     	sleep(SLEEP_PERIOD);
         ros_autorunner_.step_info_list_[STEP(3)].is_prepared = true;
     }
+    else{
+        success_cnt = 0;
+    }
+    
  }
 
+
  void CubetownAutorunner::behavior_state_cb(const visualization_msgs::MarkerArray& msg){
     std::string state = msg.markers.front().text;    
     if(!msg.markers.empty() && state.find(std::string("Forward"))!=std::string::npos){
diff --git a/rubis_ws/src/rubis_pkg/include/gnss_localizer.h b/rubis_ws/src/rubis_pkg/include/gnss_localizer.h
index 317a5987..1edf9048 100644
--- a/rubis_ws/src/rubis_pkg/include/gnss_localizer.h
+++ b/rubis_ws/src/rubis_pkg/include/gnss_localizer.h
@@ -19,6 +19,7 @@
 #include <tf/tf.h>
 #include <tf/transform_listener.h>
 #include <eigen3/Eigen/Eigen>
+#include <rubis_lib/sched.hpp>
 
 namespace gnss_localizer
 {
diff --git a/rubis_ws/src/rubis_pkg/launch/lidar_republisher.launch b/rubis_ws/src/rubis_pkg/launch/lidar_republisher.launch
index 488d479d..3f5a0762 100644
--- a/rubis_ws/src/rubis_pkg/launch/lidar_republisher.launch
+++ b/rubis_ws/src/rubis_pkg/launch/lidar_republisher.launch
@@ -2,11 +2,8 @@
     <arg name="input_topic" default="/points_raw_origin"/>
     <arg name="output_topic" default="/points_raw"/>
     <arg name="node_name" default="lidar_republisher"/>
-    <arg name="instance_mode" default="0" />
-    <node pkg="rubis_pkg" type="lidar_republisher" name="$(arg node_name)">
+    <node pkg="rubis_pkg" type="lidar_republisher" name="$(arg node_name)" output="screen">
         <param name="/input_topic" value="$(arg input_topic)" />
         <param name="/output_topic" value="$(arg output_topic)" />
-        <param name="/instance_mode" value="$(arg instance_mode)" />
-        
     </node>
 </launch>
diff --git a/rubis_ws/src/rubis_pkg/launch/lidar_republisher_params.launch b/rubis_ws/src/rubis_pkg/launch/lidar_republisher_params.launch
index 84c50fc6..3f5a0762 100644
--- a/rubis_ws/src/rubis_pkg/launch/lidar_republisher_params.launch
+++ b/rubis_ws/src/rubis_pkg/launch/lidar_republisher_params.launch
@@ -2,10 +2,8 @@
     <arg name="input_topic" default="/points_raw_origin"/>
     <arg name="output_topic" default="/points_raw"/>
     <arg name="node_name" default="lidar_republisher"/>
-    <!-- <arg name="instance_mode" default="0" /> -->
-    <node pkg="rubis_pkg" type="lidar_republisher" name="$(arg node_name)">
+    <node pkg="rubis_pkg" type="lidar_republisher" name="$(arg node_name)" output="screen">
         <param name="/input_topic" value="$(arg input_topic)" />
         <param name="/output_topic" value="$(arg output_topic)" />
-        <!-- <param name="/instance_mode" value="$(arg instance_mode)" /> -->
     </node>
 </launch>
diff --git a/rubis_ws/src/rubis_pkg/launch/vel_pose_connect.launch b/rubis_ws/src/rubis_pkg/launch/vel_pose_connect.launch
index 28ae3347..031c4ecc 100644
--- a/rubis_ws/src/rubis_pkg/launch/vel_pose_connect.launch
+++ b/rubis_ws/src/rubis_pkg/launch/vel_pose_connect.launch
@@ -5,11 +5,8 @@
   <!-- send table.xml to param server -->
   <arg name="topic_pose_stamped" default="" />
   <arg name="topic_twist_stamped" default="" />
-  <arg name="instance_mode" default="0" />
 
-  <node pkg="rubis_pkg" type="rubis_pose_relay" name="pose_relay" args="$(arg topic_pose_stamped) /current_pose">
-    <param name="instance_mode" value="$(arg instance_mode)" />
-  </node>
+  <node pkg="rubis_pkg" type="rubis_pose_relay" name="pose_relay" args="$(arg topic_pose_stamped) /current_pose"/>
   <node pkg="topic_tools" type="relay" name="vel_relay" args="$(arg topic_twist_stamped) /current_velocity"/>
   
 
diff --git a/rubis_ws/src/rubis_pkg/launch/vel_pose_connect_params.launch b/rubis_ws/src/rubis_pkg/launch/vel_pose_connect_params.launch
index 7abb5b98..031c4ecc 100644
--- a/rubis_ws/src/rubis_pkg/launch/vel_pose_connect_params.launch
+++ b/rubis_ws/src/rubis_pkg/launch/vel_pose_connect_params.launch
@@ -5,11 +5,8 @@
   <!-- send table.xml to param server -->
   <arg name="topic_pose_stamped" default="" />
   <arg name="topic_twist_stamped" default="" />
-  <!-- <arg name="instance_mode" default="0" /> -->
 
-  <node pkg="rubis_pkg" type="rubis_pose_relay" name="pose_relay" args="$(arg topic_pose_stamped) /current_pose">
-    <!-- <param name="instance_mode" value="$(arg instance_mode)" /> -->
-  </node>
+  <node pkg="rubis_pkg" type="rubis_pose_relay" name="pose_relay" args="$(arg topic_pose_stamped) /current_pose"/>
   <node pkg="topic_tools" type="relay" name="vel_relay" args="$(arg topic_twist_stamped) /current_velocity"/>
   
 
diff --git a/rubis_ws/src/rubis_pkg/src/gnss_localizer.cpp b/rubis_ws/src/rubis_pkg/src/gnss_localizer.cpp
index 7f094c5d..a7c7a342 100644
--- a/rubis_ws/src/rubis_pkg/src/gnss_localizer.cpp
+++ b/rubis_ws/src/rubis_pkg/src/gnss_localizer.cpp
@@ -70,17 +70,39 @@ void Nmea2TFPoseNode::initForROS()
   }
 
   // setup subscriber
-  sub1_ = nh_.subscribe("nmea_sentence", 100, &Nmea2TFPoseNode::callbackFromNmeaSentence, this);
-  sub2_ = nh_.subscribe("imu_raw", 100, &Nmea2TFPoseNode::callbackFromIMU, this);
+  sub1_ = nh_.subscribe("nmea_sentence", 1, &Nmea2TFPoseNode::callbackFromNmeaSentence, this);
+  sub2_ = nh_.subscribe("imu_raw", 1, &Nmea2TFPoseNode::callbackFromIMU, this);
 
   // setup publisher
   if(enable_offset_){
-    pub1_ = nh_.advertise<geometry_msgs::PoseStamped>("gnss_offset_pose", 10);
-    pub2_ = nh_.advertise<geometry_msgs::PoseStamped>("gnss_transformed_pose", 10);
+    pub1_ = nh_.advertise<geometry_msgs::PoseStamped>("gnss_offset_pose", 1);
+    pub2_ = nh_.advertise<geometry_msgs::PoseStamped>("gnss_transformed_pose", 1);
   }
   else
-    pub1_ = nh_.advertise<geometry_msgs::PoseStamped>("gnss_pose", 10);
-  vel_pub_ = nh_.advertise<geometry_msgs::TwistStamped>("gnss_vel", 10);
+    pub1_ = nh_.advertise<geometry_msgs::PoseStamped>("gnss_pose", 1);
+  vel_pub_ = nh_.advertise<geometry_msgs::TwistStamped>("gnss_vel", 1);
+
+  // Scheduling & Profiling Setup
+  std::string node_name = ros::this_node::getName();
+  std::string task_response_time_filename;
+  nh_.param<std::string>(node_name+"/task_response_time_filename", task_response_time_filename, "~/Documents/profiling/response_time/gnss_localizer.csv");
+
+  int rate;
+  nh_.param<int>(node_name+"/rate", rate, 10);
+
+  struct rubis::sched_attr attr;
+  std::string policy;
+  int priority, exec_time ,deadline, period;
+    
+  nh_.param(node_name+"/task_scheduling_configs/policy", policy, std::string("NONE"));    
+  nh_.param(node_name+"/task_scheduling_configs/priority", priority, 99);
+  nh_.param(node_name+"/task_scheduling_configs/exec_time", exec_time, 0);
+  nh_.param(node_name+"/task_scheduling_configs/deadline", deadline, 0);
+  nh_.param(node_name+"/task_scheduling_configs/period", period, 0);
+  attr = rubis::create_sched_attr(priority, exec_time, deadline, period);    
+  rubis::init_task_scheduling(policy, attr);
+
+  rubis::init_task_profiling(task_response_time_filename);
 }
 
 void Nmea2TFPoseNode::run()
diff --git a/rubis_ws/src/rubis_pkg/src/lidar_republisher.cpp b/rubis_ws/src/rubis_pkg/src/lidar_republisher.cpp
index 8d24cf4e..2a4da217 100644
--- a/rubis_ws/src/rubis_pkg/src/lidar_republisher.cpp
+++ b/rubis_ws/src/rubis_pkg/src/lidar_republisher.cpp
@@ -9,6 +9,8 @@ static ros::Publisher pub, pub_rubis;
 int is_topic_ready = 1;
 
 void points_cb(const sensor_msgs::PointCloud2ConstPtr& msg){
+    rubis::start_task_profiling();
+
     sensor_msgs::PointCloud2 msg_with_intensity = *msg;
     
     msg_with_intensity.fields.at(3).datatype = 7;
@@ -16,15 +18,31 @@ void points_cb(const sensor_msgs::PointCloud2ConstPtr& msg){
 
     pub.publish(msg_with_intensity);
 
-    if(rubis::instance_mode_){
-        rubis_msgs::PointCloud2 rubis_msg_with_intensity;
-        rubis_msg_with_intensity.instance = rubis::instance_;
-        rubis_msg_with_intensity.msg = msg_with_intensity;
-        pub_rubis.publish(rubis_msg_with_intensity);
-    }
+    rubis_msgs::PointCloud2 rubis_msg_with_intensity;
+    rubis_msg_with_intensity.instance = rubis::instance_;
+    rubis_msg_with_intensity.msg = msg_with_intensity;
+    pub_rubis.publish(rubis_msg_with_intensity);
 
-    if(rubis::sched::is_task_ready_ == TASK_NOT_READY) rubis::sched::init_task();
-    rubis::sched::task_state_ = TASK_STATE_DONE;
+    rubis::stop_task_profiling(rubis::instance_, 0);
+    rubis::instance_ = rubis::instance_+1;
+    rubis::obj_instance_ = rubis::obj_instance_+1;
+}
+
+std::string exec(const char* cmd) {
+    char buffer[128];
+    std::string result = "";
+    FILE* pipe = popen(cmd, "r");
+    if (!pipe) throw std::runtime_error("popen() failed!");
+    try {
+        while (fgets(buffer, sizeof(buffer), pipe) != NULL) {
+            result += buffer;
+        }
+    } catch (...) {
+        pclose(pipe);
+        throw;
+    }
+    pclose(pipe);
+    return result;
 }
 
 int main(int argc, char** argv){
@@ -39,72 +57,36 @@ int main(int argc, char** argv){
     std::string output_topic_name = node_name + "/output_topic";
     std::string rubis_output_topic;
 
-    nh.param<int>(node_name+"/instance_mode", rubis::instance_mode_, 0);
     nh.param<std::string>(input_topic_name, input_topic, "/points_raw_origin");
     nh.param<std::string>(output_topic_name, output_topic, "/points_raw");
 
     sub = nh.subscribe(input_topic, 1, points_cb);      
     pub = nh.advertise<sensor_msgs::PointCloud2>(output_topic, 1);
-    if(rubis::instance_mode_){
-        rubis_output_topic = "/rubis_"+output_topic.substr(1);
-        pub_rubis = nh.advertise<rubis_msgs::PointCloud2>(rubis_output_topic, 1);
-    }
-
-    // Scheduling Setup
-    int task_scheduling_flag;
-    int task_profiling_flag;
+    rubis_output_topic = "/rubis_"+output_topic.substr(1);
+    pub_rubis = nh.advertise<rubis_msgs::PointCloud2>(rubis_output_topic, 1);
+    
+    // Scheduling & Profiling Setup
     std::string task_response_time_filename;
-    int rate;
-    double task_minimum_inter_release_time;
-    double task_execution_time;
-    double task_relative_deadline; 
+    private_nh.param<std::string>(node_name+"/task_response_time_filename", task_response_time_filename, "~/Documents/profiling/response_time/lidar_republisher.csv");
 
-    private_nh.param<int>("/lidar_republisher/task_scheduling_flag", task_scheduling_flag, 0);
-    private_nh.param<int>("/lidar_republisher/task_profiling_flag", task_profiling_flag, 0);
-    private_nh.param<std::string>("/lidar_republisher/task_response_time_filename", task_response_time_filename, "~/Documents/profiling/response_time/lidar_republisher.csv");
-    private_nh.param<int>("/lidar_republisher/rate", rate, 10);
-    private_nh.param("/lidar_republisher/task_minimum_inter_release_time", task_minimum_inter_release_time, (double)10);
-    private_nh.param("/lidar_republisher/task_execution_time", task_execution_time, (double)10);
-    private_nh.param("/lidar_republisher/task_relative_deadline", task_relative_deadline, (double)10);
-
-    /* For Task scheduling */
-    if(task_profiling_flag) rubis::sched::init_task_profiling(task_response_time_filename);
-
-    if(!task_scheduling_flag && !task_profiling_flag){
-        ros::spin();
-    }
-    else{
-        ros::Rate r(rate);
-        // Initialize task ( Wait until first necessary topic is published )
-        while(ros::ok()){
-            if(rubis::sched::is_task_ready_ == TASK_READY) break;
-            ros::spinOnce();
-            r.sleep();      
-        }
-
-        // Executing task
-        while(ros::ok()){
-            if(task_profiling_flag) rubis::sched::start_task_profiling();
-
-            if(rubis::sched::task_state_ == TASK_STATE_READY){                
-                if(task_scheduling_flag) rubis::sched::request_task_scheduling(task_minimum_inter_release_time, task_execution_time, task_relative_deadline); 
-                rubis::sched::task_state_ = TASK_STATE_RUNNING;     
-            }
+    int rate;
+    private_nh.param<int>(node_name+"/rate", rate, 10);
 
-            ros::spinOnce();
+    struct rubis::sched_attr attr;
+    std::string policy;
+    int priority, exec_time ,deadline, period;
 
-            if(task_profiling_flag) rubis::sched::stop_task_profiling(rubis::instance_, rubis::sched::task_state_);
+    private_nh.param(node_name+"/task_scheduling_configs/policy", policy, std::string("NONE"));    
+    private_nh.param(node_name+"/task_scheduling_configs/priority", priority, 99);
+    private_nh.param(node_name+"/task_scheduling_configs/exec_time", exec_time, 0);
+    private_nh.param(node_name+"/task_scheduling_configs/deadline", deadline, 0);
+    private_nh.param(node_name+"/task_scheduling_configs/period", period, 0);
+    attr = rubis::create_sched_attr(priority, exec_time, deadline, period);    
+    rubis::init_task_scheduling(policy, attr);
 
-            if(rubis::sched::task_state_ == TASK_STATE_DONE){
-                if(task_scheduling_flag) rubis::sched::yield_task_scheduling();
-                rubis::sched::task_state_ = TASK_STATE_READY;
-                rubis::instance_ = rubis::instance_+1;
-            }
-            
-        
-            r.sleep();
-        }
-    }
+    rubis::init_task_profiling(task_response_time_filename);
+    
+    ros::spin();
     
     return 0;
 }
\ No newline at end of file
diff --git a/rubis_ws/src/rubis_pkg/src/rubis_pose_relay.cpp b/rubis_ws/src/rubis_pkg/src/rubis_pose_relay.cpp
index 54e6cd23..a81a3cbd 100644
--- a/rubis_ws/src/rubis_pkg/src/rubis_pose_relay.cpp
+++ b/rubis_ws/src/rubis_pkg/src/rubis_pose_relay.cpp
@@ -8,20 +8,15 @@ ros::Subscriber rubis_sub_, sub_;
 ros::Publisher rubis_pub_, pub_;
 
 inline void relay(const geometry_msgs::PoseStampedConstPtr& msg){
-    if(rubis::instance_mode_ && rubis::instance_ != RUBIS_NO_INSTANCE){
-        rubis_msgs::PoseStamped rubis_msg;
-        rubis_msg.instance = rubis::instance_;
-        rubis_msg.msg = *msg;
-        rubis_pub_.publish(rubis_msg);
-    }
+    rubis_msgs::PoseStamped rubis_msg;
+    rubis_msg.instance = rubis::instance_;
+    rubis_msg.msg = *msg;
+    rubis_pub_.publish(rubis_msg);
     pub_.publish(msg);
-
-    if(rubis::sched::is_task_ready_ == TASK_NOT_READY) rubis::sched::init_task();
-    rubis::sched::task_state_ = TASK_STATE_DONE;
 }
 
 void cb(const geometry_msgs::PoseStampedConstPtr& msg){
-    rubis::instance_ = RUBIS_NO_INSTANCE;
+    rubis::instance_ = 0;
     relay(msg);
 }
 
@@ -35,8 +30,6 @@ int main(int argc, char* argv[]){
     ros::init(argc, argv, "pose_relay");  
 
     // Scheduling Setup
-    int task_scheduling_flag;
-    int task_profiling_flag;
     std::string task_response_time_filename;
     int rate;
     double task_minimum_inter_release_time;
@@ -45,65 +38,34 @@ int main(int argc, char* argv[]){
 
     ros::NodeHandle nh;
 
-    nh.param<int>("/pose_relay/task_scheduling_flag", task_scheduling_flag, 0);
-    nh.param<int>("/pose_relay/task_profiling_flag", task_profiling_flag, 0);
     nh.param<std::string>("/pose_relay/task_response_time_filename", task_response_time_filename, "~/Documents/profiling/response_time/pose_relay.csv");
     nh.param<int>("/pose_relay/rate", rate, 10);
     nh.param("/pose_relay/task_minimum_inter_release_time", task_minimum_inter_release_time, (double)10);
     nh.param("/pose_relay/task_execution_time", task_execution_time, (double)10);
     nh.param("/pose_relay/task_relative_deadline", task_relative_deadline, (double)10);
-    nh.param<int>("/pose_relay/instance_mode", rubis::instance_mode_, 0);
 
     input_topic_ = std::string(argv[1]);
 
     std::cout<<"!!! input topic  "<<input_topic_<<std::endl;
 
-    if(rubis::instance_mode_){
-        rubis_input_topic_ = "/rubis_"+input_topic_.substr(1);
-        rubis_sub_ = nh.subscribe(rubis_input_topic_, 10, rubis_cb);
-        rubis_pub_ = nh.advertise<rubis_msgs::PoseStamped>("/rubis_current_pose", 10);
-    }
-    else{
-        rubis_sub_ = nh.subscribe(input_topic_, 10, cb);
-    }
+    rubis_input_topic_ = "/rubis_"+input_topic_.substr(1);
+    rubis_sub_ = nh.subscribe(rubis_input_topic_, 10, rubis_cb);
+    rubis_pub_ = nh.advertise<rubis_msgs::PoseStamped>("/rubis_current_pose", 10);
 
     pub_ = nh.advertise<geometry_msgs::PoseStamped>("/current_pose", 10);
 
     /* For Task scheduling */
-    if(task_profiling_flag) rubis::sched::init_task_profiling(task_response_time_filename);
+    rubis::init_task_profiling(task_response_time_filename);
 
-    if(!task_scheduling_flag && !task_profiling_flag){
-        ros::spin();
-    }
-    else{
-        ros::Rate r(rate);
-        // Initialize task ( Wait until first necessary topic is published )
-        while(ros::ok()){
-            if(rubis::sched::is_task_ready_ == TASK_READY) break;
-            ros::spinOnce();
-            r.sleep();      
-        }
-
-        // Executing task
-        while(ros::ok()){
-            if(task_profiling_flag) rubis::sched::start_task_profiling();
-
-            if(rubis::sched::task_state_ == TASK_STATE_READY){                
-                if(task_scheduling_flag) rubis::sched::request_task_scheduling(task_minimum_inter_release_time, task_execution_time, task_relative_deadline); 
-                rubis::sched::task_state_ = TASK_STATE_RUNNING;     
-            }
-
-            ros::spinOnce();
-
-            if(task_profiling_flag) rubis::sched::stop_task_profiling(rubis::instance_, rubis::sched::task_state_);
-
-            if(rubis::sched::task_state_ == TASK_STATE_DONE){
-                if(task_scheduling_flag) rubis::sched::yield_task_scheduling();
-                rubis::sched::task_state_ = TASK_STATE_READY;
-            }
-        
-            r.sleep();
-        }
+    ros::Rate r(rate);
+    while(ros::ok()){
+        rubis::start_task_profiling();
+
+        ros::spinOnce();
+
+        rubis::stop_task_profiling(rubis::instance_, 0);
+
+        r.sleep();
     }
 
     return 0;
diff --git a/rubis_ws/src/topic_tools/src/relay.cpp b/rubis_ws/src/topic_tools/src/relay.cpp
index 60862697..4a12f860 100644
--- a/rubis_ws/src/topic_tools/src/relay.cpp
+++ b/rubis_ws/src/topic_tools/src/relay.cpp
@@ -110,10 +110,6 @@ void in_cb(const ros::MessageEvent<ShapeShifter>& msg_event)
   }
   else
     g_pub.publish(msg);
-  
-  if(rubis::sched::is_task_ready_ == TASK_NOT_READY) rubis::sched::init_task();
-  rubis::sched::task_state_ = TASK_STATE_DONE;
-
 }
 
 void timer_cb(const ros::TimerEvent&)
@@ -184,73 +180,10 @@ int main(int argc, char **argv)
     pnh.param<double>("monitor_rate", monitor_rate, 1.0);
     monitor_timer = n.createTimer(ros::Duration(monitor_rate), &timer_cb);
   }
-  
-
-  // scheduling
-  int task_scheduling_flag = 0;
-  int task_profiling_flag = 0;
-  std::string task_response_time_filename;
-  int rate = 0;
-  double task_minimum_inter_release_time = 0;
-  double task_execution_time = 0;
-  double task_relative_deadline = 0;
-
-  if(g_output_topic == std::string("/current_velocity")){
-    pnh.param<int>("/vel_relay/task_scheduling_flag", task_scheduling_flag, 0);
-    pnh.param<int>("/vel_relay/task_profiling_flag", task_profiling_flag, 0);
-    pnh.param<std::string>("/vel_relay/task_response_time_filename", task_response_time_filename, "~/Documents/profiling/response_time/vel_relay.csv");
-    pnh.param<int>("/vel_relay/rate", rate, 10);
-    pnh.param("/vel_relay/task_minimum_inter_release_time", task_minimum_inter_release_time, (double)100000000);
-    pnh.param("/vel_relay/task_execution_time", task_execution_time, (double)100000000);
-    pnh.param("/vel_relay/task_relative_deadline", task_relative_deadline, (double)100000000);
-  }
-  else if (g_output_topic == std::string("/current_pose")){
-    pnh.param<int>("/pose_relay/task_scheduling_flag", task_scheduling_flag, 0);
-    pnh.param<int>("/pose_relay/task_profiling_flag", task_profiling_flag, 0);
-    pnh.param<std::string>("/pose_relay/task_response_time_filename", task_response_time_filename, "~/Documents/profiling/response_time/pose_relay.csv");
-    pnh.param<int>("/pose_relay/rate", rate, 10);
-    pnh.param("/pose_relay/task_minimum_inter_release_time", task_minimum_inter_release_time, (double)100000000);
-    pnh.param("/pose_relay/task_execution_time", task_execution_time, (double)100000000);
-    pnh.param("/pose_relay/task_relative_deadline", task_relative_deadline, (double)100000000);
-  }
-
-  if(task_profiling_flag) rubis::sched::init_task_profiling(task_response_time_filename);
 
   subscribe();
 
-  if(!task_scheduling_flag && !task_profiling_flag){
-    ros::spin();
-  }
-  else{
-    ros::Rate r(rate);
-    // Initialize task ( Wait until first necessary topic is published )
-    while(ros::ok()){
-      if(rubis::sched::is_task_ready_ == TASK_READY) break;
-      ros::spinOnce();
-      r.sleep();      
-    }
-
-    // Executing task
-    while(ros::ok()){
-      if(task_profiling_flag) rubis::sched::start_task_profiling();
-
-      if(rubis::sched::task_state_ == TASK_STATE_READY){        
-        if(task_scheduling_flag) rubis::sched::request_task_scheduling(task_minimum_inter_release_time, task_execution_time, task_relative_deadline); 
-        rubis::sched::task_state_ = TASK_STATE_RUNNING;     
-      }
-
-      ros::spinOnce();
-
-      if(task_profiling_flag) rubis::sched::stop_task_profiling(RUBIS_NO_INSTANCE, rubis::sched::task_state_);
-
-      if(rubis::sched::task_state_ == TASK_STATE_DONE){        
-        if(task_scheduling_flag) rubis::sched::yield_task_scheduling();
-        rubis::sched::task_state_ = TASK_STATE_READY;
-      }
-      
-      r.sleep();
-    }
-  }
+  ros::spin();
 
   return 0;
 }
diff --git a/setup/setup.sh b/setup/setup.sh
index 50df55a6..29fb165c 100755
--- a/setup/setup.sh
+++ b/setup/setup.sh
@@ -42,21 +42,6 @@ if [ ! -d ~/Documents/profiling/response_time ]; then
     printf "~/Documents/profiling/response_time is created.\n"
 fi
 
-if [ ! -d ~/Documents/gpu_profiling ]; then
-    mkdir ~/Documents/gpu_profiling
-    printf "~/Documents/gpu_profiling is created.\n"
-fi
-
-if [ ! -d ~/Documents/gpu_profiling ]; then
-    mkdir ~/Documents/gpu_profiling
-    printf "~/Documents/gpu_profiling is created.\n"
-fi
-
-if [ ! -d ~/Documents/gpu_deadline ]; then
-    mkdir ~/Documents/gpu_deadline
-    printf "~/Documents/gpu_deadline is created.\n"
-fi
-
 echo "Necessary directory paths are created to /home/${1}/Documents"
 
 sudo ./setup_bashrc.sh $1
